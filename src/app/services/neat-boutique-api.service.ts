//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.4.0.0 (NJsonSchema v11.3.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface INeatBoutiqueApiService {
    /**
     * @param body (optional) 
     * @return Success
     */
    getAccounts(body: Request | undefined): Observable<ProfilesResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    createAccount(body: AccountCreateRequest | undefined): Observable<ProfilesResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    deleteAccountInit(body: AccountDeletionRequest | undefined): Observable<Response>;
    /**
     * @param body (optional) 
     * @return Success
     */
    deleteAccountRollBack(body: AccountDeletionRequest | undefined): Observable<Response>;
    /**
     * @param body (optional) 
     * @return Success
     */
    deleteAccountFinal(body: AccountDeletionRequest | undefined): Observable<Response>;
    /**
     * @param body (optional) 
     * @return Success
     */
    updateEmail(body: Request | undefined): Observable<ProfilesResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    updateUsername(body: Request | undefined): Observable<ProfilesResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    updateAccountNotificationSettings(body: AccountNotificationCategoriesRequest | undefined): Observable<Response>;
    /**
     * @param body (optional) 
     * @return Success
     */
    updateAccountNotificationToken(body: NotificationTokenRequest | undefined): Observable<Response>;
    /**
     * @param body (optional) 
     * @return Success
     */
    updateAccountFeedSettings(body: AccountFeedSettingsRequest | undefined): Observable<Response>;
    /**
     * @param body (optional) 
     * @return Success
     */
    answerQuestionWithVendor(body: AnswerWithVendorRequest | undefined): Observable<PostResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    answerQuestionWithGooglePlace(body: AnswerWithGooglePlaceRequest | undefined): Observable<PostResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    removeAnswerVoteFromAnswer(body: AnswerVoteRemoveRequest | undefined): Observable<PostResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    addVoteToPollAnswer(body: PollAnswerRequest | undefined): Observable<PostResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    removeVoteFromPollAnswer(body: AnswerVoteRemoveRequest | undefined): Observable<PostResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    getAllDataForCategories(body: CategoryRequest | undefined): Observable<CategoryResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    addCommentToPost(body: CommentRequest | undefined): Observable<CommentResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    removeCommentFromPost(body: CommentRemoveRequest | undefined): Observable<Response>;
    /**
     * @param body (optional) 
     * @return Success
     */
    addLikeToComment(body: CommentLikeAddRequest | undefined): Observable<CommentResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    removeLikeFromComment(body: CommentLikeRemoveRequest | undefined): Observable<CommentResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    updateCommentBodyOnPost(body: CommentUpdateRequest | undefined): Observable<CommentResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    addVendorToMyPlaces(body: MyPlacesRequest | undefined): Observable<Response>;
    /**
     * @param body (optional) 
     * @return Success
     */
    removeVendorFromMyPlaces(body: MyPlacesRequest | undefined): Observable<Response>;
    /**
     * @param body (optional) 
     * @return Success
     */
    getMyQuestions(body: MyQuestionsRequest | undefined): Observable<PostsResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    getConsumerProfileByPath(body: ConsumerProfileRequest | undefined): Observable<ConsumerProfileResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    getRecentActivityByConsumerId(body: ConsumerProfileActivityRequest | undefined): Observable<ConsumerProfileActivityResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    uploadConsumerProfileImage(body: ConsumerImageRequest | undefined): Observable<ConsumerProfileResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    updateConsumerDescription(body: ConsumerDescriptionRequest | undefined): Observable<ConsumerProfileResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    updateConsumerBorderColor(body: ConsumerBorderColorRequest | undefined): Observable<ConsumerProfileResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    updateNotificationSettings(body: ConsumerNotificationSettingsRequest | undefined): Observable<ConsumerProfileResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    updateFeedSettings(body: ConsumerFeedSettingsRequest | undefined): Observable<ConsumerProfileResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    sendContactUs(body: ContactUsRequest | undefined): Observable<Response>;
    /**
     * @param body (optional) 
     * @return Success
     */
    getHeroAdTemplatesForVendor(body: VendorProfileRequest | undefined): Observable<HeroAdTemplatesResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    createHeroAdForVendor(body: CreateHeroAdRequest | undefined): Observable<Response>;
    /**
     * @param body (optional) 
     * @return Success
     */
    createNetwork(body: CreateNetworkRequest | undefined): Observable<NetworkResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    addVendorToNetwork(body: AddVendorToNetworkRequest | undefined): Observable<void>;
    /**
     * @param body (optional) 
     * @return Success
     */
    updateVendorMembershipInNetwork(body: UpdateVendorMembershipinNetworkRequest | undefined): Observable<NetworkWithVendorsResponse>;
    /**
     * @param networkId (optional) 
     * @param vendorId (optional) 
     * @return Success
     */
    removeVendorFromNetwork(networkId: string | null | undefined, vendorId: string | null | undefined): Observable<void>;
    /**
     * @param networkId (optional) 
     * @return Success
     */
    deleteNetwork(networkId: string | null | undefined): Observable<Response>;
    /**
     * @param body (optional) 
     * @return Success
     */
    getNetworkWithVendorNetworkMemberships(body: NetworkRequest | undefined): Observable<NetworkWithVendorsResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    getVendorNetworkMembershipInvite(body: NetworkInviteRequest | undefined): Observable<VendorNetworkMembershipResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    getNetworkByMembershipIdWithInviteLink(body: NetworkRequest | undefined): Observable<NetworkWithVendorsResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    declineNetworkInvite(body: NetworkRequest | undefined): Observable<Response>;
    /**
     * @param body (optional) 
     * @return Success
     */
    acceptNetworkInvite(body: UpdateVendorMembershipinNetworkRequest | undefined): Observable<NetworkWithVendorsResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    createStripeCheckout(body: StripeCheckoutRequest | undefined): Observable<StripeCheckoutResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    applyPromoCode(body: PromoCodeReqeust | undefined): Observable<PromotionalDiscountResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    create3MonthsFreePromotionalDiscount(body: CreatePromotionalDiscountRequest | undefined): Observable<PromotionalDiscountResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    create6MonthsFreePromotionalDiscount(body: CreatePromotionalDiscountRequest | undefined): Observable<PromotionalDiscountResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    createFreeForeverPromotionalDiscount(body: CreatePromotionalDiscountRequest | undefined): Observable<PromotionalDiscountResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    changeVendorSubscriptionToPremium(body: ChangeVendorSubscriptionRequest | undefined): Observable<VendorProfileResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    cancelVendorSubscription(body: VendorProfileCancelRequest | undefined): Observable<VendorProfileResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    changeVendorSubscriptionToStandard(body: ChangeVendorSubscriptionRequest | undefined): Observable<VendorProfileResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    getVendorSubscriptionId(body: Request | undefined): Observable<VendorSubscriptionResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    createConsumerQuestion(body: PostRequest | undefined): Observable<PostResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    createRouteFeedQuestion(body: PostRequest | undefined): Observable<PostResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    createVendorPost(body: VendorPostRequest | undefined): Observable<PostResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    getPostById(body: PostRequest | undefined): Observable<PostResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    getSampleOfReviews(body: Request | undefined): Observable<ReviewsResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    addReviewToVendor(body: ReviewRequest | undefined): Observable<ReviewResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    removeReviewFromVendor(body: ReviewRemoveRequest | undefined): Observable<Response>;
    /**
     * @param body (optional) 
     * @return Success
     */
    updateReviewOnVendor(body: ReviewUpdateRequest | undefined): Observable<ReviewResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    getRouteById(body: RouteRequest | undefined): Observable<RouteResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    getMyVisitsOnRouteByRouteId(body: RouteRequest | undefined): Observable<MyVisitsResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    autoCompleteSearchVendorProfiles(body: AnswerSearchRequest | undefined): Observable<VendorProfilesResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    autocompleteSearchForAnswer(body: AnswerSearchRequest | undefined): Observable<AnswerSearchResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    autocompleteSearchForGooglePlace(body: GooglePlacesSearchRequest | undefined): Observable<GooglePlaceSearchResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    getGooglePlaceDetails(body: GooglePlaceRequest | undefined): Observable<GooglePlaceDetailsResponse>;
    /**
     * @return Success
     */
    changeAnswers(): Observable<Response>;
    /**
     * @return Success
     */
    setVendorProfilePath(): Observable<Response>;
    /**
     * @return Success
     */
    changeVendorPhotos(): Observable<Response>;
    /**
     * @return Success
     */
    updateConsumerProfilesSeedData(): Observable<Response>;
    /**
     * @return Success
     */
    updateConsumerProfilesPathsSeedData(): Observable<Response>;
    /**
     * @return Success
     */
    updateVendorProfilesSeedData(): Observable<Response>;
    /**
     * @return Success
     */
    addHeroAdTemplatesSeedData(): Observable<Response>;
    /**
     * @param body (optional) 
     * @return Success
     */
    getSettings(body: Request | undefined): Observable<Settings>;
    /**
     * @return Success
     */
    stripeWebHook(): Observable<void>;
    /**
     * @return Success
     */
    cancelSession(id: string | null): Observable<void>;
    /**
     * @param body (optional) 
     * @return Success
     */
    getVendorsByCategoryName(body: VendorProfilesRequest | undefined): Observable<VendorProfilesResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    getSampleOfVendors(body: Request | undefined): Observable<VendorProfilesResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    getVendorProfileWithReviewsById(body: VendorProfileRequest | undefined): Observable<VendorProfileWithReviewsResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    getVendorProfileWithReviewsByPath(body: VendorProfileRequest | undefined): Observable<VendorProfileWithReviewsResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    getVendorProfileByVendorInfo(body: GetVendorProfileByInfoRequest | undefined): Observable<VendorProfileResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    getVendorProfilesForMyPlaces(body: Request | undefined): Observable<VendorProfilesResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    uploadVendorPhoto(body: VendorImageRequest | undefined): Observable<VendorProfileResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    uploadVendorLogo(body: VendorImageRequest | undefined): Observable<VendorProfileResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    updateVendorDescription(body: VendorDescriptionRequest | undefined): Observable<VendorProfileResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    updateSocialLinks(body: VendorSocialLinksRequest | undefined): Observable<VendorProfileResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    updateCategories(body: VendorCategoriesRequest | undefined): Observable<VendorProfileResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    updateVendorBorderColor(body: VendorBorderColorRequest | undefined): Observable<VendorProfileResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    updateVendorGeneralDiscounts(body: VendorGeneralDiscountsRequest | undefined): Observable<VendorProfileResponse>;
}

@Injectable()
export class NeatBoutiqueApiService implements INeatBoutiqueApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getAccounts(body: Request | undefined): Observable<ProfilesResponse> {
        let url_ = this.baseUrl + "/Accounts/GetAccountsAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAccounts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAccounts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProfilesResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProfilesResponse>;
        }));
    }

    protected processGetAccounts(response: HttpResponseBase): Observable<ProfilesResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProfilesResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProfilesResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createAccount(body: AccountCreateRequest | undefined): Observable<ProfilesResponse> {
        let url_ = this.baseUrl + "/Accounts/CreateAccountAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateAccount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProfilesResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProfilesResponse>;
        }));
    }

    protected processCreateAccount(response: HttpResponseBase): Observable<ProfilesResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProfilesResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProfilesResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deleteAccountInit(body: AccountDeletionRequest | undefined): Observable<Response> {
        let url_ = this.baseUrl + "/Accounts/DeleteAccountInitAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAccountInit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAccountInit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Response>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Response>;
        }));
    }

    protected processDeleteAccountInit(response: HttpResponseBase): Observable<Response> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Response.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Response>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deleteAccountRollBack(body: AccountDeletionRequest | undefined): Observable<Response> {
        let url_ = this.baseUrl + "/Accounts/DeleteAccountRollBackAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAccountRollBack(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAccountRollBack(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Response>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Response>;
        }));
    }

    protected processDeleteAccountRollBack(response: HttpResponseBase): Observable<Response> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Response.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Response>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deleteAccountFinal(body: AccountDeletionRequest | undefined): Observable<Response> {
        let url_ = this.baseUrl + "/Accounts/DeleteAccountFinalAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAccountFinal(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAccountFinal(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Response>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Response>;
        }));
    }

    protected processDeleteAccountFinal(response: HttpResponseBase): Observable<Response> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Response.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Response>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateEmail(body: Request | undefined): Observable<ProfilesResponse> {
        let url_ = this.baseUrl + "/Accounts/UpdateEmailAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateEmail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProfilesResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProfilesResponse>;
        }));
    }

    protected processUpdateEmail(response: HttpResponseBase): Observable<ProfilesResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProfilesResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProfilesResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateUsername(body: Request | undefined): Observable<ProfilesResponse> {
        let url_ = this.baseUrl + "/Accounts/UpdateUsernameAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUsername(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUsername(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProfilesResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProfilesResponse>;
        }));
    }

    protected processUpdateUsername(response: HttpResponseBase): Observable<ProfilesResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProfilesResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProfilesResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateAccountNotificationSettings(body: AccountNotificationCategoriesRequest | undefined): Observable<Response> {
        let url_ = this.baseUrl + "/Accounts/UpdateAccountNotificationSettingsAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAccountNotificationSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAccountNotificationSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Response>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Response>;
        }));
    }

    protected processUpdateAccountNotificationSettings(response: HttpResponseBase): Observable<Response> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Response.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Response>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateAccountNotificationToken(body: NotificationTokenRequest | undefined): Observable<Response> {
        let url_ = this.baseUrl + "/Accounts/UpdateAccountNotificationTokenAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAccountNotificationToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAccountNotificationToken(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Response>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Response>;
        }));
    }

    protected processUpdateAccountNotificationToken(response: HttpResponseBase): Observable<Response> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Response.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Response>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateAccountFeedSettings(body: AccountFeedSettingsRequest | undefined): Observable<Response> {
        let url_ = this.baseUrl + "/Accounts/UpdateAccountFeedSettingsAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAccountFeedSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAccountFeedSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Response>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Response>;
        }));
    }

    protected processUpdateAccountFeedSettings(response: HttpResponseBase): Observable<Response> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Response.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Response>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    answerQuestionWithVendor(body: AnswerWithVendorRequest | undefined): Observable<PostResponse> {
        let url_ = this.baseUrl + "/Answers/AnswerQuestionWithVendorAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAnswerQuestionWithVendor(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAnswerQuestionWithVendor(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PostResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PostResponse>;
        }));
    }

    protected processAnswerQuestionWithVendor(response: HttpResponseBase): Observable<PostResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PostResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PostResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    answerQuestionWithGooglePlace(body: AnswerWithGooglePlaceRequest | undefined): Observable<PostResponse> {
        let url_ = this.baseUrl + "/Answers/AnswerQuestionWithGooglePlaceAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAnswerQuestionWithGooglePlace(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAnswerQuestionWithGooglePlace(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PostResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PostResponse>;
        }));
    }

    protected processAnswerQuestionWithGooglePlace(response: HttpResponseBase): Observable<PostResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PostResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PostResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    removeAnswerVoteFromAnswer(body: AnswerVoteRemoveRequest | undefined): Observable<PostResponse> {
        let url_ = this.baseUrl + "/Answers/RemoveAnswerVoteFromAnswerAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveAnswerVoteFromAnswer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveAnswerVoteFromAnswer(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PostResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PostResponse>;
        }));
    }

    protected processRemoveAnswerVoteFromAnswer(response: HttpResponseBase): Observable<PostResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PostResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PostResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addVoteToPollAnswer(body: PollAnswerRequest | undefined): Observable<PostResponse> {
        let url_ = this.baseUrl + "/Answers/AddVoteToPollAnswerAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddVoteToPollAnswer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddVoteToPollAnswer(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PostResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PostResponse>;
        }));
    }

    protected processAddVoteToPollAnswer(response: HttpResponseBase): Observable<PostResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PostResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PostResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    removeVoteFromPollAnswer(body: AnswerVoteRemoveRequest | undefined): Observable<PostResponse> {
        let url_ = this.baseUrl + "/Answers/RemoveVoteFromPollAnswerAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveVoteFromPollAnswer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveVoteFromPollAnswer(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PostResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PostResponse>;
        }));
    }

    protected processRemoveVoteFromPollAnswer(response: HttpResponseBase): Observable<PostResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PostResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PostResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getAllDataForCategories(body: CategoryRequest | undefined): Observable<CategoryResponse> {
        let url_ = this.baseUrl + "/Category/GetAllDataForCategoriesAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDataForCategories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDataForCategories(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CategoryResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CategoryResponse>;
        }));
    }

    protected processGetAllDataForCategories(response: HttpResponseBase): Observable<CategoryResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CategoryResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CategoryResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addCommentToPost(body: CommentRequest | undefined): Observable<CommentResponse> {
        let url_ = this.baseUrl + "/Comments/AddCommentToPostAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddCommentToPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddCommentToPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CommentResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CommentResponse>;
        }));
    }

    protected processAddCommentToPost(response: HttpResponseBase): Observable<CommentResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommentResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommentResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    removeCommentFromPost(body: CommentRemoveRequest | undefined): Observable<Response> {
        let url_ = this.baseUrl + "/Comments/RemoveCommentFromPostAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveCommentFromPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveCommentFromPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Response>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Response>;
        }));
    }

    protected processRemoveCommentFromPost(response: HttpResponseBase): Observable<Response> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Response.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Response>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addLikeToComment(body: CommentLikeAddRequest | undefined): Observable<CommentResponse> {
        let url_ = this.baseUrl + "/Comments/AddLikeToCommentAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddLikeToComment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddLikeToComment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CommentResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CommentResponse>;
        }));
    }

    protected processAddLikeToComment(response: HttpResponseBase): Observable<CommentResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommentResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommentResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    removeLikeFromComment(body: CommentLikeRemoveRequest | undefined): Observable<CommentResponse> {
        let url_ = this.baseUrl + "/Comments/RemoveLikeFromCommentAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveLikeFromComment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveLikeFromComment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CommentResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CommentResponse>;
        }));
    }

    protected processRemoveLikeFromComment(response: HttpResponseBase): Observable<CommentResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommentResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommentResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateCommentBodyOnPost(body: CommentUpdateRequest | undefined): Observable<CommentResponse> {
        let url_ = this.baseUrl + "/Comments/UpdateCommentBodyOnPostAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCommentBodyOnPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCommentBodyOnPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CommentResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CommentResponse>;
        }));
    }

    protected processUpdateCommentBodyOnPost(response: HttpResponseBase): Observable<CommentResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommentResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommentResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addVendorToMyPlaces(body: MyPlacesRequest | undefined): Observable<Response> {
        let url_ = this.baseUrl + "/Consumers/AddVendorToMyPlacesAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddVendorToMyPlaces(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddVendorToMyPlaces(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Response>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Response>;
        }));
    }

    protected processAddVendorToMyPlaces(response: HttpResponseBase): Observable<Response> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Response.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Response>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    removeVendorFromMyPlaces(body: MyPlacesRequest | undefined): Observable<Response> {
        let url_ = this.baseUrl + "/Consumers/RemoveVendorFromMyPlacesAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveVendorFromMyPlaces(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveVendorFromMyPlaces(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Response>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Response>;
        }));
    }

    protected processRemoveVendorFromMyPlaces(response: HttpResponseBase): Observable<Response> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Response.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Response>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getMyQuestions(body: MyQuestionsRequest | undefined): Observable<PostsResponse> {
        let url_ = this.baseUrl + "/Consumers/GetMyQuestionsAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMyQuestions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMyQuestions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PostsResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PostsResponse>;
        }));
    }

    protected processGetMyQuestions(response: HttpResponseBase): Observable<PostsResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PostsResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PostsResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getConsumerProfileByPath(body: ConsumerProfileRequest | undefined): Observable<ConsumerProfileResponse> {
        let url_ = this.baseUrl + "/Consumers/GetConsumerProfileByPathAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetConsumerProfileByPath(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetConsumerProfileByPath(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ConsumerProfileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ConsumerProfileResponse>;
        }));
    }

    protected processGetConsumerProfileByPath(response: HttpResponseBase): Observable<ConsumerProfileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ConsumerProfileResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ConsumerProfileResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getRecentActivityByConsumerId(body: ConsumerProfileActivityRequest | undefined): Observable<ConsumerProfileActivityResponse> {
        let url_ = this.baseUrl + "/Consumers/GetRecentActivityByConsumerIdAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecentActivityByConsumerId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecentActivityByConsumerId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ConsumerProfileActivityResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ConsumerProfileActivityResponse>;
        }));
    }

    protected processGetRecentActivityByConsumerId(response: HttpResponseBase): Observable<ConsumerProfileActivityResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ConsumerProfileActivityResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ConsumerProfileActivityResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    uploadConsumerProfileImage(body: ConsumerImageRequest | undefined): Observable<ConsumerProfileResponse> {
        let url_ = this.baseUrl + "/Consumers/UploadConsumerProfileImageAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadConsumerProfileImage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadConsumerProfileImage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ConsumerProfileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ConsumerProfileResponse>;
        }));
    }

    protected processUploadConsumerProfileImage(response: HttpResponseBase): Observable<ConsumerProfileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ConsumerProfileResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ConsumerProfileResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateConsumerDescription(body: ConsumerDescriptionRequest | undefined): Observable<ConsumerProfileResponse> {
        let url_ = this.baseUrl + "/Consumers/UpdateConsumerDescriptionAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateConsumerDescription(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateConsumerDescription(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ConsumerProfileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ConsumerProfileResponse>;
        }));
    }

    protected processUpdateConsumerDescription(response: HttpResponseBase): Observable<ConsumerProfileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ConsumerProfileResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ConsumerProfileResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateConsumerBorderColor(body: ConsumerBorderColorRequest | undefined): Observable<ConsumerProfileResponse> {
        let url_ = this.baseUrl + "/Consumers/UpdateConsumerBorderColorAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateConsumerBorderColor(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateConsumerBorderColor(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ConsumerProfileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ConsumerProfileResponse>;
        }));
    }

    protected processUpdateConsumerBorderColor(response: HttpResponseBase): Observable<ConsumerProfileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ConsumerProfileResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ConsumerProfileResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateNotificationSettings(body: ConsumerNotificationSettingsRequest | undefined): Observable<ConsumerProfileResponse> {
        let url_ = this.baseUrl + "/Consumers/UpdateNotificationSettingsAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateNotificationSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateNotificationSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ConsumerProfileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ConsumerProfileResponse>;
        }));
    }

    protected processUpdateNotificationSettings(response: HttpResponseBase): Observable<ConsumerProfileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ConsumerProfileResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ConsumerProfileResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateFeedSettings(body: ConsumerFeedSettingsRequest | undefined): Observable<ConsumerProfileResponse> {
        let url_ = this.baseUrl + "/Consumers/UpdateFeedSettingsAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateFeedSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateFeedSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ConsumerProfileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ConsumerProfileResponse>;
        }));
    }

    protected processUpdateFeedSettings(response: HttpResponseBase): Observable<ConsumerProfileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ConsumerProfileResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ConsumerProfileResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendContactUs(body: ContactUsRequest | undefined): Observable<Response> {
        let url_ = this.baseUrl + "/Email/SendContactUsAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendContactUs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendContactUs(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Response>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Response>;
        }));
    }

    protected processSendContactUs(response: HttpResponseBase): Observable<Response> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Response.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Response>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getHeroAdTemplatesForVendor(body: VendorProfileRequest | undefined): Observable<HeroAdTemplatesResponse> {
        let url_ = this.baseUrl + "/HeroAd/GetHeroAdTemplatesForVendorAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHeroAdTemplatesForVendor(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHeroAdTemplatesForVendor(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HeroAdTemplatesResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HeroAdTemplatesResponse>;
        }));
    }

    protected processGetHeroAdTemplatesForVendor(response: HttpResponseBase): Observable<HeroAdTemplatesResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HeroAdTemplatesResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HeroAdTemplatesResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createHeroAdForVendor(body: CreateHeroAdRequest | undefined): Observable<Response> {
        let url_ = this.baseUrl + "/HeroAd/CreateHeroAdForVendorAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateHeroAdForVendor(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateHeroAdForVendor(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Response>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Response>;
        }));
    }

    protected processCreateHeroAdForVendor(response: HttpResponseBase): Observable<Response> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Response.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Response>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createNetwork(body: CreateNetworkRequest | undefined): Observable<NetworkResponse> {
        let url_ = this.baseUrl + "/api/Networks/CreateNetwork";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateNetwork(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateNetwork(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NetworkResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NetworkResponse>;
        }));
    }

    protected processCreateNetwork(response: HttpResponseBase): Observable<NetworkResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NetworkResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NetworkResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addVendorToNetwork(body: AddVendorToNetworkRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Networks/AddVendorToNetwork";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddVendorToNetwork(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddVendorToNetwork(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAddVendorToNetwork(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateVendorMembershipInNetwork(body: UpdateVendorMembershipinNetworkRequest | undefined): Observable<NetworkWithVendorsResponse> {
        let url_ = this.baseUrl + "/api/Networks/UpdateVendorMembershipInNetwork";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateVendorMembershipInNetwork(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateVendorMembershipInNetwork(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NetworkWithVendorsResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NetworkWithVendorsResponse>;
        }));
    }

    protected processUpdateVendorMembershipInNetwork(response: HttpResponseBase): Observable<NetworkWithVendorsResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NetworkWithVendorsResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NetworkWithVendorsResponse>(null as any);
    }

    /**
     * @param networkId (optional) 
     * @param vendorId (optional) 
     * @return Success
     */
    removeVendorFromNetwork(networkId: string | null | undefined, vendorId: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Networks/RemoveVendorFromNetwork?";
        if (networkId !== undefined && networkId !== null)
            url_ += "networkId=" + encodeURIComponent("" + networkId) + "&";
        if (vendorId !== undefined && vendorId !== null)
            url_ += "vendorId=" + encodeURIComponent("" + vendorId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveVendorFromNetwork(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveVendorFromNetwork(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRemoveVendorFromNetwork(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param networkId (optional) 
     * @return Success
     */
    deleteNetwork(networkId: string | null | undefined): Observable<Response> {
        let url_ = this.baseUrl + "/api/Networks/DeleteNetwork?";
        if (networkId !== undefined && networkId !== null)
            url_ += "networkId=" + encodeURIComponent("" + networkId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteNetwork(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteNetwork(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Response>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Response>;
        }));
    }

    protected processDeleteNetwork(response: HttpResponseBase): Observable<Response> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Response.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Response>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getNetworkWithVendorNetworkMemberships(body: NetworkRequest | undefined): Observable<NetworkWithVendorsResponse> {
        let url_ = this.baseUrl + "/api/Networks/GetNetworkWithVendorNetworkMemberships";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNetworkWithVendorNetworkMemberships(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNetworkWithVendorNetworkMemberships(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NetworkWithVendorsResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NetworkWithVendorsResponse>;
        }));
    }

    protected processGetNetworkWithVendorNetworkMemberships(response: HttpResponseBase): Observable<NetworkWithVendorsResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NetworkWithVendorsResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NetworkWithVendorsResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getVendorNetworkMembershipInvite(body: NetworkInviteRequest | undefined): Observable<VendorNetworkMembershipResponse> {
        let url_ = this.baseUrl + "/api/Networks/GetVendorNetworkMembershipInvite";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVendorNetworkMembershipInvite(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVendorNetworkMembershipInvite(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VendorNetworkMembershipResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VendorNetworkMembershipResponse>;
        }));
    }

    protected processGetVendorNetworkMembershipInvite(response: HttpResponseBase): Observable<VendorNetworkMembershipResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VendorNetworkMembershipResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VendorNetworkMembershipResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getNetworkByMembershipIdWithInviteLink(body: NetworkRequest | undefined): Observable<NetworkWithVendorsResponse> {
        let url_ = this.baseUrl + "/api/Networks/GetNetworkByMembershipIdWithInviteLink";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNetworkByMembershipIdWithInviteLink(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNetworkByMembershipIdWithInviteLink(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NetworkWithVendorsResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NetworkWithVendorsResponse>;
        }));
    }

    protected processGetNetworkByMembershipIdWithInviteLink(response: HttpResponseBase): Observable<NetworkWithVendorsResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NetworkWithVendorsResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NetworkWithVendorsResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    declineNetworkInvite(body: NetworkRequest | undefined): Observable<Response> {
        let url_ = this.baseUrl + "/api/Networks/DeclineNetworkInvite";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeclineNetworkInvite(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeclineNetworkInvite(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Response>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Response>;
        }));
    }

    protected processDeclineNetworkInvite(response: HttpResponseBase): Observable<Response> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Response.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Response>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    acceptNetworkInvite(body: UpdateVendorMembershipinNetworkRequest | undefined): Observable<NetworkWithVendorsResponse> {
        let url_ = this.baseUrl + "/api/Networks/AcceptNetworkInvite";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAcceptNetworkInvite(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAcceptNetworkInvite(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NetworkWithVendorsResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NetworkWithVendorsResponse>;
        }));
    }

    protected processAcceptNetworkInvite(response: HttpResponseBase): Observable<NetworkWithVendorsResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NetworkWithVendorsResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NetworkWithVendorsResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createStripeCheckout(body: StripeCheckoutRequest | undefined): Observable<StripeCheckoutResponse> {
        let url_ = this.baseUrl + "/Payments/CreateStripeCheckoutAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateStripeCheckout(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateStripeCheckout(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StripeCheckoutResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StripeCheckoutResponse>;
        }));
    }

    protected processCreateStripeCheckout(response: HttpResponseBase): Observable<StripeCheckoutResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StripeCheckoutResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StripeCheckoutResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    applyPromoCode(body: PromoCodeReqeust | undefined): Observable<PromotionalDiscountResponse> {
        let url_ = this.baseUrl + "/Payments/ApplyPromoCodeAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApplyPromoCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApplyPromoCode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PromotionalDiscountResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PromotionalDiscountResponse>;
        }));
    }

    protected processApplyPromoCode(response: HttpResponseBase): Observable<PromotionalDiscountResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PromotionalDiscountResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PromotionalDiscountResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create3MonthsFreePromotionalDiscount(body: CreatePromotionalDiscountRequest | undefined): Observable<PromotionalDiscountResponse> {
        let url_ = this.baseUrl + "/Payments/Create3MonthsFreePromotionalDiscountAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate3MonthsFreePromotionalDiscount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate3MonthsFreePromotionalDiscount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PromotionalDiscountResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PromotionalDiscountResponse>;
        }));
    }

    protected processCreate3MonthsFreePromotionalDiscount(response: HttpResponseBase): Observable<PromotionalDiscountResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PromotionalDiscountResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PromotionalDiscountResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create6MonthsFreePromotionalDiscount(body: CreatePromotionalDiscountRequest | undefined): Observable<PromotionalDiscountResponse> {
        let url_ = this.baseUrl + "/Payments/Create6MonthsFreePromotionalDiscountAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate6MonthsFreePromotionalDiscount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate6MonthsFreePromotionalDiscount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PromotionalDiscountResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PromotionalDiscountResponse>;
        }));
    }

    protected processCreate6MonthsFreePromotionalDiscount(response: HttpResponseBase): Observable<PromotionalDiscountResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PromotionalDiscountResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PromotionalDiscountResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createFreeForeverPromotionalDiscount(body: CreatePromotionalDiscountRequest | undefined): Observable<PromotionalDiscountResponse> {
        let url_ = this.baseUrl + "/Payments/CreateFreeForeverPromotionalDiscountAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateFreeForeverPromotionalDiscount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateFreeForeverPromotionalDiscount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PromotionalDiscountResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PromotionalDiscountResponse>;
        }));
    }

    protected processCreateFreeForeverPromotionalDiscount(response: HttpResponseBase): Observable<PromotionalDiscountResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PromotionalDiscountResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PromotionalDiscountResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changeVendorSubscriptionToPremium(body: ChangeVendorSubscriptionRequest | undefined): Observable<VendorProfileResponse> {
        let url_ = this.baseUrl + "/Payments/ChangeVendorSubscriptionToPremiumAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeVendorSubscriptionToPremium(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeVendorSubscriptionToPremium(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VendorProfileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VendorProfileResponse>;
        }));
    }

    protected processChangeVendorSubscriptionToPremium(response: HttpResponseBase): Observable<VendorProfileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VendorProfileResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VendorProfileResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cancelVendorSubscription(body: VendorProfileCancelRequest | undefined): Observable<VendorProfileResponse> {
        let url_ = this.baseUrl + "/Payments/CancelVendorSubscriptionAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancelVendorSubscription(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancelVendorSubscription(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VendorProfileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VendorProfileResponse>;
        }));
    }

    protected processCancelVendorSubscription(response: HttpResponseBase): Observable<VendorProfileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VendorProfileResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VendorProfileResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changeVendorSubscriptionToStandard(body: ChangeVendorSubscriptionRequest | undefined): Observable<VendorProfileResponse> {
        let url_ = this.baseUrl + "/Payments/ChangeVendorSubscriptionToStandardAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeVendorSubscriptionToStandard(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeVendorSubscriptionToStandard(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VendorProfileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VendorProfileResponse>;
        }));
    }

    protected processChangeVendorSubscriptionToStandard(response: HttpResponseBase): Observable<VendorProfileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VendorProfileResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VendorProfileResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getVendorSubscriptionId(body: Request | undefined): Observable<VendorSubscriptionResponse> {
        let url_ = this.baseUrl + "/Payments/GetVendorSubscriptionIdAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVendorSubscriptionId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVendorSubscriptionId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VendorSubscriptionResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VendorSubscriptionResponse>;
        }));
    }

    protected processGetVendorSubscriptionId(response: HttpResponseBase): Observable<VendorSubscriptionResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VendorSubscriptionResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VendorSubscriptionResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createConsumerQuestion(body: PostRequest | undefined): Observable<PostResponse> {
        let url_ = this.baseUrl + "/Posts/CreateConsumerQuestionAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateConsumerQuestion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateConsumerQuestion(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PostResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PostResponse>;
        }));
    }

    protected processCreateConsumerQuestion(response: HttpResponseBase): Observable<PostResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PostResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PostResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createRouteFeedQuestion(body: PostRequest | undefined): Observable<PostResponse> {
        let url_ = this.baseUrl + "/Posts/CreateRouteFeedQuestionAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateRouteFeedQuestion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateRouteFeedQuestion(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PostResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PostResponse>;
        }));
    }

    protected processCreateRouteFeedQuestion(response: HttpResponseBase): Observable<PostResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PostResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PostResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createVendorPost(body: VendorPostRequest | undefined): Observable<PostResponse> {
        let url_ = this.baseUrl + "/Posts/CreateVendorPostAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateVendorPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateVendorPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PostResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PostResponse>;
        }));
    }

    protected processCreateVendorPost(response: HttpResponseBase): Observable<PostResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PostResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PostResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getPostById(body: PostRequest | undefined): Observable<PostResponse> {
        let url_ = this.baseUrl + "/Posts/GetPostByIdAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPostById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPostById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PostResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PostResponse>;
        }));
    }

    protected processGetPostById(response: HttpResponseBase): Observable<PostResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PostResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PostResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getSampleOfReviews(body: Request | undefined): Observable<ReviewsResponse> {
        let url_ = this.baseUrl + "/Reviews/GetSampleOfReviewsAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSampleOfReviews(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSampleOfReviews(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReviewsResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReviewsResponse>;
        }));
    }

    protected processGetSampleOfReviews(response: HttpResponseBase): Observable<ReviewsResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReviewsResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReviewsResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addReviewToVendor(body: ReviewRequest | undefined): Observable<ReviewResponse> {
        let url_ = this.baseUrl + "/Reviews/AddReviewToVendorAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddReviewToVendor(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddReviewToVendor(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReviewResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReviewResponse>;
        }));
    }

    protected processAddReviewToVendor(response: HttpResponseBase): Observable<ReviewResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReviewResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReviewResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    removeReviewFromVendor(body: ReviewRemoveRequest | undefined): Observable<Response> {
        let url_ = this.baseUrl + "/Reviews/RemoveReviewFromVendorAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveReviewFromVendor(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveReviewFromVendor(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Response>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Response>;
        }));
    }

    protected processRemoveReviewFromVendor(response: HttpResponseBase): Observable<Response> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Response.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Response>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateReviewOnVendor(body: ReviewUpdateRequest | undefined): Observable<ReviewResponse> {
        let url_ = this.baseUrl + "/Reviews/UpdateReviewOnVendorAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateReviewOnVendor(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateReviewOnVendor(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReviewResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReviewResponse>;
        }));
    }

    protected processUpdateReviewOnVendor(response: HttpResponseBase): Observable<ReviewResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReviewResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReviewResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getRouteById(body: RouteRequest | undefined): Observable<RouteResponse> {
        let url_ = this.baseUrl + "/Routes/GetRouteByIdAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRouteById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRouteById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RouteResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RouteResponse>;
        }));
    }

    protected processGetRouteById(response: HttpResponseBase): Observable<RouteResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RouteResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RouteResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getMyVisitsOnRouteByRouteId(body: RouteRequest | undefined): Observable<MyVisitsResponse> {
        let url_ = this.baseUrl + "/Routes/GetMyVisitsOnRouteByRouteIdAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMyVisitsOnRouteByRouteId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMyVisitsOnRouteByRouteId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MyVisitsResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MyVisitsResponse>;
        }));
    }

    protected processGetMyVisitsOnRouteByRouteId(response: HttpResponseBase): Observable<MyVisitsResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MyVisitsResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MyVisitsResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    autoCompleteSearchVendorProfiles(body: AnswerSearchRequest | undefined): Observable<VendorProfilesResponse> {
        let url_ = this.baseUrl + "/Search/AutoCompleteSearchVendorProfilesAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAutoCompleteSearchVendorProfiles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAutoCompleteSearchVendorProfiles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VendorProfilesResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VendorProfilesResponse>;
        }));
    }

    protected processAutoCompleteSearchVendorProfiles(response: HttpResponseBase): Observable<VendorProfilesResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VendorProfilesResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VendorProfilesResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    autocompleteSearchForAnswer(body: AnswerSearchRequest | undefined): Observable<AnswerSearchResponse> {
        let url_ = this.baseUrl + "/Search/AutocompleteSearchForAnswerAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAutocompleteSearchForAnswer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAutocompleteSearchForAnswer(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AnswerSearchResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AnswerSearchResponse>;
        }));
    }

    protected processAutocompleteSearchForAnswer(response: HttpResponseBase): Observable<AnswerSearchResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AnswerSearchResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AnswerSearchResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    autocompleteSearchForGooglePlace(body: GooglePlacesSearchRequest | undefined): Observable<GooglePlaceSearchResponse> {
        let url_ = this.baseUrl + "/Search/AutocompleteSearchForGooglePlaceAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAutocompleteSearchForGooglePlace(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAutocompleteSearchForGooglePlace(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GooglePlaceSearchResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GooglePlaceSearchResponse>;
        }));
    }

    protected processAutocompleteSearchForGooglePlace(response: HttpResponseBase): Observable<GooglePlaceSearchResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GooglePlaceSearchResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GooglePlaceSearchResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getGooglePlaceDetails(body: GooglePlaceRequest | undefined): Observable<GooglePlaceDetailsResponse> {
        let url_ = this.baseUrl + "/Search/GetGooglePlaceDetailsAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGooglePlaceDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGooglePlaceDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GooglePlaceDetailsResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GooglePlaceDetailsResponse>;
        }));
    }

    protected processGetGooglePlaceDetails(response: HttpResponseBase): Observable<GooglePlaceDetailsResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GooglePlaceDetailsResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GooglePlaceDetailsResponse>(null as any);
    }

    /**
     * @return Success
     */
    changeAnswers(): Observable<Response> {
        let url_ = this.baseUrl + "/SeedData/ChangeAnswersAsync";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeAnswers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeAnswers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Response>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Response>;
        }));
    }

    protected processChangeAnswers(response: HttpResponseBase): Observable<Response> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Response.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Response>(null as any);
    }

    /**
     * @return Success
     */
    setVendorProfilePath(): Observable<Response> {
        let url_ = this.baseUrl + "/SeedData/SetVendorProfilePathAsync";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetVendorProfilePath(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetVendorProfilePath(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Response>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Response>;
        }));
    }

    protected processSetVendorProfilePath(response: HttpResponseBase): Observable<Response> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Response.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Response>(null as any);
    }

    /**
     * @return Success
     */
    changeVendorPhotos(): Observable<Response> {
        let url_ = this.baseUrl + "/SeedData/ChangeVendorPhotosAsync";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeVendorPhotos(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeVendorPhotos(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Response>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Response>;
        }));
    }

    protected processChangeVendorPhotos(response: HttpResponseBase): Observable<Response> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Response.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Response>(null as any);
    }

    /**
     * @return Success
     */
    updateConsumerProfilesSeedData(): Observable<Response> {
        let url_ = this.baseUrl + "/SeedData/UpdateConsumerProfilesSeedDataAsync";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateConsumerProfilesSeedData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateConsumerProfilesSeedData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Response>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Response>;
        }));
    }

    protected processUpdateConsumerProfilesSeedData(response: HttpResponseBase): Observable<Response> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Response.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Response>(null as any);
    }

    /**
     * @return Success
     */
    updateConsumerProfilesPathsSeedData(): Observable<Response> {
        let url_ = this.baseUrl + "/SeedData/UpdateConsumerProfilesPathsSeedDataAsync";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateConsumerProfilesPathsSeedData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateConsumerProfilesPathsSeedData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Response>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Response>;
        }));
    }

    protected processUpdateConsumerProfilesPathsSeedData(response: HttpResponseBase): Observable<Response> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Response.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Response>(null as any);
    }

    /**
     * @return Success
     */
    updateVendorProfilesSeedData(): Observable<Response> {
        let url_ = this.baseUrl + "/SeedData/UpdateVendorProfilesSeedDataAsync";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateVendorProfilesSeedData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateVendorProfilesSeedData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Response>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Response>;
        }));
    }

    protected processUpdateVendorProfilesSeedData(response: HttpResponseBase): Observable<Response> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Response.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Response>(null as any);
    }

    /**
     * @return Success
     */
    addHeroAdTemplatesSeedData(): Observable<Response> {
        let url_ = this.baseUrl + "/SeedData/AddHeroAdTemplatesSeedDataAsync";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddHeroAdTemplatesSeedData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddHeroAdTemplatesSeedData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Response>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Response>;
        }));
    }

    protected processAddHeroAdTemplatesSeedData(response: HttpResponseBase): Observable<Response> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Response.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Response>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getSettings(body: Request | undefined): Observable<Settings> {
        let url_ = this.baseUrl + "/Settings/GetSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Settings>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Settings>;
        }));
    }

    protected processGetSettings(response: HttpResponseBase): Observable<Settings> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Settings.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Settings>(null as any);
    }

    /**
     * @return Success
     */
    stripeWebHook(): Observable<void> {
        let url_ = this.baseUrl + "/StripeWebHook";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStripeWebHook(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStripeWebHook(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processStripeWebHook(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    cancelSession(id: string | null): Observable<void> {
        let url_ = this.baseUrl + "/StripeWebHook/CancelSessionAsync/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancelSession(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancelSession(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCancelSession(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getVendorsByCategoryName(body: VendorProfilesRequest | undefined): Observable<VendorProfilesResponse> {
        let url_ = this.baseUrl + "/Vendors/GetVendorsByCategoryNameAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVendorsByCategoryName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVendorsByCategoryName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VendorProfilesResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VendorProfilesResponse>;
        }));
    }

    protected processGetVendorsByCategoryName(response: HttpResponseBase): Observable<VendorProfilesResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VendorProfilesResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VendorProfilesResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getSampleOfVendors(body: Request | undefined): Observable<VendorProfilesResponse> {
        let url_ = this.baseUrl + "/Vendors/GetSampleOfVendorsAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSampleOfVendors(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSampleOfVendors(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VendorProfilesResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VendorProfilesResponse>;
        }));
    }

    protected processGetSampleOfVendors(response: HttpResponseBase): Observable<VendorProfilesResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VendorProfilesResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VendorProfilesResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getVendorProfileWithReviewsById(body: VendorProfileRequest | undefined): Observable<VendorProfileWithReviewsResponse> {
        let url_ = this.baseUrl + "/Vendors/GetVendorProfileWithReviewsByIdAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVendorProfileWithReviewsById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVendorProfileWithReviewsById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VendorProfileWithReviewsResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VendorProfileWithReviewsResponse>;
        }));
    }

    protected processGetVendorProfileWithReviewsById(response: HttpResponseBase): Observable<VendorProfileWithReviewsResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VendorProfileWithReviewsResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VendorProfileWithReviewsResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getVendorProfileWithReviewsByPath(body: VendorProfileRequest | undefined): Observable<VendorProfileWithReviewsResponse> {
        let url_ = this.baseUrl + "/Vendors/GetVendorProfileWithReviewsByPathAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVendorProfileWithReviewsByPath(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVendorProfileWithReviewsByPath(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VendorProfileWithReviewsResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VendorProfileWithReviewsResponse>;
        }));
    }

    protected processGetVendorProfileWithReviewsByPath(response: HttpResponseBase): Observable<VendorProfileWithReviewsResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VendorProfileWithReviewsResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VendorProfileWithReviewsResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getVendorProfileByVendorInfo(body: GetVendorProfileByInfoRequest | undefined): Observable<VendorProfileResponse> {
        let url_ = this.baseUrl + "/Vendors/GetVendorProfileByVendorInfoAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVendorProfileByVendorInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVendorProfileByVendorInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VendorProfileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VendorProfileResponse>;
        }));
    }

    protected processGetVendorProfileByVendorInfo(response: HttpResponseBase): Observable<VendorProfileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VendorProfileResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VendorProfileResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getVendorProfilesForMyPlaces(body: Request | undefined): Observable<VendorProfilesResponse> {
        let url_ = this.baseUrl + "/Vendors/GetVendorProfilesForMyPlacesAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVendorProfilesForMyPlaces(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVendorProfilesForMyPlaces(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VendorProfilesResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VendorProfilesResponse>;
        }));
    }

    protected processGetVendorProfilesForMyPlaces(response: HttpResponseBase): Observable<VendorProfilesResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VendorProfilesResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VendorProfilesResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    uploadVendorPhoto(body: VendorImageRequest | undefined): Observable<VendorProfileResponse> {
        let url_ = this.baseUrl + "/Vendors/UploadVendorPhotoAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadVendorPhoto(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadVendorPhoto(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VendorProfileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VendorProfileResponse>;
        }));
    }

    protected processUploadVendorPhoto(response: HttpResponseBase): Observable<VendorProfileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VendorProfileResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VendorProfileResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    uploadVendorLogo(body: VendorImageRequest | undefined): Observable<VendorProfileResponse> {
        let url_ = this.baseUrl + "/Vendors/UploadVendorLogoAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadVendorLogo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadVendorLogo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VendorProfileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VendorProfileResponse>;
        }));
    }

    protected processUploadVendorLogo(response: HttpResponseBase): Observable<VendorProfileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VendorProfileResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VendorProfileResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateVendorDescription(body: VendorDescriptionRequest | undefined): Observable<VendorProfileResponse> {
        let url_ = this.baseUrl + "/Vendors/UpdateVendorDescriptionAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateVendorDescription(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateVendorDescription(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VendorProfileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VendorProfileResponse>;
        }));
    }

    protected processUpdateVendorDescription(response: HttpResponseBase): Observable<VendorProfileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VendorProfileResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VendorProfileResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateSocialLinks(body: VendorSocialLinksRequest | undefined): Observable<VendorProfileResponse> {
        let url_ = this.baseUrl + "/Vendors/UpdateSocialLinksAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateSocialLinks(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSocialLinks(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VendorProfileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VendorProfileResponse>;
        }));
    }

    protected processUpdateSocialLinks(response: HttpResponseBase): Observable<VendorProfileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VendorProfileResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VendorProfileResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateCategories(body: VendorCategoriesRequest | undefined): Observable<VendorProfileResponse> {
        let url_ = this.baseUrl + "/Vendors/UpdateCategoriesAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCategories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCategories(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VendorProfileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VendorProfileResponse>;
        }));
    }

    protected processUpdateCategories(response: HttpResponseBase): Observable<VendorProfileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VendorProfileResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VendorProfileResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateVendorBorderColor(body: VendorBorderColorRequest | undefined): Observable<VendorProfileResponse> {
        let url_ = this.baseUrl + "/Vendors/UpdateVendorBorderColorAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateVendorBorderColor(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateVendorBorderColor(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VendorProfileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VendorProfileResponse>;
        }));
    }

    protected processUpdateVendorBorderColor(response: HttpResponseBase): Observable<VendorProfileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VendorProfileResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VendorProfileResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateVendorGeneralDiscounts(body: VendorGeneralDiscountsRequest | undefined): Observable<VendorProfileResponse> {
        let url_ = this.baseUrl + "/Vendors/UpdateVendorGeneralDiscountsAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateVendorGeneralDiscounts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateVendorGeneralDiscounts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VendorProfileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VendorProfileResponse>;
        }));
    }

    protected processUpdateVendorGeneralDiscounts(response: HttpResponseBase): Observable<VendorProfileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VendorProfileResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VendorProfileResponse>(null as any);
    }
}

export class Request implements IRequest {

    constructor(data?: IRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): Request {
        data = typeof data === 'object' ? data : {};
        let result = new Request();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IRequest {
}

export class ErrorDto implements IErrorDto {
    errorMessage?: string | undefined;
    errorCode?: string | undefined;

    constructor(data?: IErrorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
        }
    }

    static fromJS(data: any): ErrorDto {
        data = typeof data === 'object' ? data : {};
        let result = new ErrorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        return data;
    }
}

export interface IErrorDto {
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
}

export class ConsumerProfile implements IConsumerProfile {
    id?: string | undefined;
    createdDateUtc?: Date;
    lastUpdatedDateUtc?: Date;
    name?: string | undefined;
    avatarSourceURL?: string | undefined;
    email?: string | undefined;
    emailVerified?: boolean;
    myPlacesVendorIds?: string[] | undefined;
    profilePath?: string | undefined;
    hometown?: string | undefined;
    borderColor?: string | undefined;
    description?: string | undefined;
    notificationsForAnsweredQuestions?: boolean;
    questionsAskedCount?: number;
    questionsAnsweredCount?: number;
    reviewsCount?: number;

    constructor(data?: IConsumerProfile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdDateUtc = _data["createdDateUtc"] ? new Date(_data["createdDateUtc"].toString()) : <any>undefined;
            this.lastUpdatedDateUtc = _data["lastUpdatedDateUtc"] ? new Date(_data["lastUpdatedDateUtc"].toString()) : <any>undefined;
            this.name = _data["name"];
            this.avatarSourceURL = _data["avatarSourceURL"];
            this.email = _data["email"];
            this.emailVerified = _data["emailVerified"];
            if (Array.isArray(_data["myPlacesVendorIds"])) {
                this.myPlacesVendorIds = [] as any;
                for (let item of _data["myPlacesVendorIds"])
                    this.myPlacesVendorIds!.push(item);
            }
            this.profilePath = _data["profilePath"];
            this.hometown = _data["hometown"];
            this.borderColor = _data["borderColor"];
            this.description = _data["description"];
            this.notificationsForAnsweredQuestions = _data["notificationsForAnsweredQuestions"];
            this.questionsAskedCount = _data["questionsAskedCount"];
            this.questionsAnsweredCount = _data["questionsAnsweredCount"];
            this.reviewsCount = _data["reviewsCount"];
        }
    }

    static fromJS(data: any): ConsumerProfile {
        data = typeof data === 'object' ? data : {};
        let result = new ConsumerProfile();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdDateUtc"] = this.createdDateUtc ? this.createdDateUtc.toISOString() : <any>undefined;
        data["lastUpdatedDateUtc"] = this.lastUpdatedDateUtc ? this.lastUpdatedDateUtc.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["avatarSourceURL"] = this.avatarSourceURL;
        data["email"] = this.email;
        data["emailVerified"] = this.emailVerified;
        if (Array.isArray(this.myPlacesVendorIds)) {
            data["myPlacesVendorIds"] = [];
            for (let item of this.myPlacesVendorIds)
                data["myPlacesVendorIds"].push(item);
        }
        data["profilePath"] = this.profilePath;
        data["hometown"] = this.hometown;
        data["borderColor"] = this.borderColor;
        data["description"] = this.description;
        data["notificationsForAnsweredQuestions"] = this.notificationsForAnsweredQuestions;
        data["questionsAskedCount"] = this.questionsAskedCount;
        data["questionsAnsweredCount"] = this.questionsAnsweredCount;
        data["reviewsCount"] = this.reviewsCount;
        return data;
    }
}

export interface IConsumerProfile {
    id?: string | undefined;
    createdDateUtc?: Date;
    lastUpdatedDateUtc?: Date;
    name?: string | undefined;
    avatarSourceURL?: string | undefined;
    email?: string | undefined;
    emailVerified?: boolean;
    myPlacesVendorIds?: string[] | undefined;
    profilePath?: string | undefined;
    hometown?: string | undefined;
    borderColor?: string | undefined;
    description?: string | undefined;
    notificationsForAnsweredQuestions?: boolean;
    questionsAskedCount?: number;
    questionsAnsweredCount?: number;
    reviewsCount?: number;
}

export class CustomerDiscount implements ICustomerDiscount {
    visitsThreshold?: number;
    description?: string | undefined;

    constructor(data?: ICustomerDiscount) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.visitsThreshold = _data["visitsThreshold"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): CustomerDiscount {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerDiscount();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["visitsThreshold"] = this.visitsThreshold;
        data["description"] = this.description;
        return data;
    }
}

export interface ICustomerDiscount {
    visitsThreshold?: number;
    description?: string | undefined;
}

export class NeatBoutiqueEntity implements INeatBoutiqueEntity {
    id?: string | undefined;
    role?: string | undefined;
    name?: string | undefined;
    avatarSourceURL?: string | undefined;
    profilePath?: string | undefined;
    borderColor?: string | undefined;

    constructor(data?: INeatBoutiqueEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.role = _data["role"];
            this.name = _data["name"];
            this.avatarSourceURL = _data["avatarSourceURL"];
            this.profilePath = _data["profilePath"];
            this.borderColor = _data["borderColor"];
        }
    }

    static fromJS(data: any): NeatBoutiqueEntity {
        data = typeof data === 'object' ? data : {};
        let result = new NeatBoutiqueEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["role"] = this.role;
        data["name"] = this.name;
        data["avatarSourceURL"] = this.avatarSourceURL;
        data["profilePath"] = this.profilePath;
        data["borderColor"] = this.borderColor;
        return data;
    }
}

export interface INeatBoutiqueEntity {
    id?: string | undefined;
    role?: string | undefined;
    name?: string | undefined;
    avatarSourceURL?: string | undefined;
    profilePath?: string | undefined;
    borderColor?: string | undefined;
}

export class Comment implements IComment {
    id?: string | undefined;
    createdDateUtc?: Date;
    lastUpdatedDateUtc?: Date;
    postId?: string | undefined;
    body?: string | undefined;
    author?: NeatBoutiqueEntity;
    likers?: NeatBoutiqueEntity[] | undefined;

    constructor(data?: IComment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdDateUtc = _data["createdDateUtc"] ? new Date(_data["createdDateUtc"].toString()) : <any>undefined;
            this.lastUpdatedDateUtc = _data["lastUpdatedDateUtc"] ? new Date(_data["lastUpdatedDateUtc"].toString()) : <any>undefined;
            this.postId = _data["postId"];
            this.body = _data["body"];
            this.author = _data["author"] ? NeatBoutiqueEntity.fromJS(_data["author"]) : <any>undefined;
            if (Array.isArray(_data["likers"])) {
                this.likers = [] as any;
                for (let item of _data["likers"])
                    this.likers!.push(NeatBoutiqueEntity.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Comment {
        data = typeof data === 'object' ? data : {};
        let result = new Comment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdDateUtc"] = this.createdDateUtc ? this.createdDateUtc.toISOString() : <any>undefined;
        data["lastUpdatedDateUtc"] = this.lastUpdatedDateUtc ? this.lastUpdatedDateUtc.toISOString() : <any>undefined;
        data["postId"] = this.postId;
        data["body"] = this.body;
        data["author"] = this.author ? this.author.toJSON() : <any>undefined;
        if (Array.isArray(this.likers)) {
            data["likers"] = [];
            for (let item of this.likers)
                data["likers"].push(item ? item.toJSON() : <any>undefined);
        }
        return data;
    }
}

export interface IComment {
    id?: string | undefined;
    createdDateUtc?: Date;
    lastUpdatedDateUtc?: Date;
    postId?: string | undefined;
    body?: string | undefined;
    author?: NeatBoutiqueEntity;
    likers?: NeatBoutiqueEntity[] | undefined;
}

export class GeometryLocation implements IGeometryLocation {
    latitude?: number;
    longitude?: number;

    constructor(data?: IGeometryLocation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.latitude = _data["latitude"];
            this.longitude = _data["longitude"];
        }
    }

    static fromJS(data: any): GeometryLocation {
        data = typeof data === 'object' ? data : {};
        let result = new GeometryLocation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        return data;
    }
}

export interface IGeometryLocation {
    latitude?: number;
    longitude?: number;
}

export class GooglePlacesEntity implements IGooglePlacesEntity {
    placeId?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;

    constructor(data?: IGooglePlacesEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.placeId = _data["placeId"];
            this.name = _data["name"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): GooglePlacesEntity {
        data = typeof data === 'object' ? data : {};
        let result = new GooglePlacesEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["placeId"] = this.placeId;
        data["name"] = this.name;
        data["description"] = this.description;
        return data;
    }
}

export interface IGooglePlacesEntity {
    placeId?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
}

export class SelectionVote implements ISelectionVote {
    id?: string | undefined;
    createdDateUtc?: Date;
    lastUpdatedDateUtc?: Date;
    postId?: string | undefined;
    selectionId?: string | undefined;
    voter?: NeatBoutiqueEntity;
    voteRanking?: string | undefined;

    constructor(data?: ISelectionVote) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdDateUtc = _data["createdDateUtc"] ? new Date(_data["createdDateUtc"].toString()) : <any>undefined;
            this.lastUpdatedDateUtc = _data["lastUpdatedDateUtc"] ? new Date(_data["lastUpdatedDateUtc"].toString()) : <any>undefined;
            this.postId = _data["postId"];
            this.selectionId = _data["selectionId"];
            this.voter = _data["voter"] ? NeatBoutiqueEntity.fromJS(_data["voter"]) : <any>undefined;
            this.voteRanking = _data["voteRanking"];
        }
    }

    static fromJS(data: any): SelectionVote {
        data = typeof data === 'object' ? data : {};
        let result = new SelectionVote();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdDateUtc"] = this.createdDateUtc ? this.createdDateUtc.toISOString() : <any>undefined;
        data["lastUpdatedDateUtc"] = this.lastUpdatedDateUtc ? this.lastUpdatedDateUtc.toISOString() : <any>undefined;
        data["postId"] = this.postId;
        data["selectionId"] = this.selectionId;
        data["voter"] = this.voter ? this.voter.toJSON() : <any>undefined;
        data["voteRanking"] = this.voteRanking;
        return data;
    }
}

export interface ISelectionVote {
    id?: string | undefined;
    createdDateUtc?: Date;
    lastUpdatedDateUtc?: Date;
    postId?: string | undefined;
    selectionId?: string | undefined;
    voter?: NeatBoutiqueEntity;
    voteRanking?: string | undefined;
}

export class Selection implements ISelection {
    id?: string | undefined;
    createdDateUtc?: Date;
    lastUpdatedDateUtc?: Date;
    postId?: string | undefined;
    freeFormAnswer?: string | undefined;
    vendor?: NeatBoutiqueEntity;
    geometryLocation?: GeometryLocation;
    googlePlace?: GooglePlacesEntity;
    votes?: SelectionVote[] | undefined;

    constructor(data?: ISelection) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdDateUtc = _data["createdDateUtc"] ? new Date(_data["createdDateUtc"].toString()) : <any>undefined;
            this.lastUpdatedDateUtc = _data["lastUpdatedDateUtc"] ? new Date(_data["lastUpdatedDateUtc"].toString()) : <any>undefined;
            this.postId = _data["postId"];
            this.freeFormAnswer = _data["freeFormAnswer"];
            this.vendor = _data["vendor"] ? NeatBoutiqueEntity.fromJS(_data["vendor"]) : <any>undefined;
            this.geometryLocation = _data["geometryLocation"] ? GeometryLocation.fromJS(_data["geometryLocation"]) : <any>undefined;
            this.googlePlace = _data["googlePlace"] ? GooglePlacesEntity.fromJS(_data["googlePlace"]) : <any>undefined;
            if (Array.isArray(_data["votes"])) {
                this.votes = [] as any;
                for (let item of _data["votes"])
                    this.votes!.push(SelectionVote.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Selection {
        data = typeof data === 'object' ? data : {};
        let result = new Selection();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdDateUtc"] = this.createdDateUtc ? this.createdDateUtc.toISOString() : <any>undefined;
        data["lastUpdatedDateUtc"] = this.lastUpdatedDateUtc ? this.lastUpdatedDateUtc.toISOString() : <any>undefined;
        data["postId"] = this.postId;
        data["freeFormAnswer"] = this.freeFormAnswer;
        data["vendor"] = this.vendor ? this.vendor.toJSON() : <any>undefined;
        data["geometryLocation"] = this.geometryLocation ? this.geometryLocation.toJSON() : <any>undefined;
        data["googlePlace"] = this.googlePlace ? this.googlePlace.toJSON() : <any>undefined;
        if (Array.isArray(this.votes)) {
            data["votes"] = [];
            for (let item of this.votes)
                data["votes"].push(item ? item.toJSON() : <any>undefined);
        }
        return data;
    }
}

export interface ISelection {
    id?: string | undefined;
    createdDateUtc?: Date;
    lastUpdatedDateUtc?: Date;
    postId?: string | undefined;
    freeFormAnswer?: string | undefined;
    vendor?: NeatBoutiqueEntity;
    geometryLocation?: GeometryLocation;
    googlePlace?: GooglePlacesEntity;
    votes?: SelectionVote[] | undefined;
}

export class Post implements IPost {
    id?: string | undefined;
    createdDateUtc?: Date;
    lastUpdatedDateUtc?: Date;
    postType?: string | undefined;
    subject?: string | undefined;
    category?: CategoryType;
    feedContextId?: string | undefined;
    startDateUtc?: Date | undefined;
    endDateUtc?: Date | undefined;
    author?: NeatBoutiqueEntity;
    comments?: Comment[] | undefined;
    selections?: Selection[] | undefined;

    constructor(data?: IPost) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdDateUtc = _data["createdDateUtc"] ? new Date(_data["createdDateUtc"].toString()) : <any>undefined;
            this.lastUpdatedDateUtc = _data["lastUpdatedDateUtc"] ? new Date(_data["lastUpdatedDateUtc"].toString()) : <any>undefined;
            this.postType = _data["postType"];
            this.subject = _data["subject"];
            this.category = _data["category"];
            this.feedContextId = _data["feedContextId"];
            this.startDateUtc = _data["startDateUtc"] ? new Date(_data["startDateUtc"].toString()) : <any>undefined;
            this.endDateUtc = _data["endDateUtc"] ? new Date(_data["endDateUtc"].toString()) : <any>undefined;
            this.author = _data["author"] ? NeatBoutiqueEntity.fromJS(_data["author"]) : <any>undefined;
            if (Array.isArray(_data["comments"])) {
                this.comments = [] as any;
                for (let item of _data["comments"])
                    this.comments!.push(Comment.fromJS(item));
            }
            if (Array.isArray(_data["selections"])) {
                this.selections = [] as any;
                for (let item of _data["selections"])
                    this.selections!.push(Selection.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Post {
        data = typeof data === 'object' ? data : {};
        let result = new Post();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdDateUtc"] = this.createdDateUtc ? this.createdDateUtc.toISOString() : <any>undefined;
        data["lastUpdatedDateUtc"] = this.lastUpdatedDateUtc ? this.lastUpdatedDateUtc.toISOString() : <any>undefined;
        data["postType"] = this.postType;
        data["subject"] = this.subject;
        data["category"] = this.category;
        data["feedContextId"] = this.feedContextId;
        data["startDateUtc"] = this.startDateUtc ? this.startDateUtc.toISOString() : <any>undefined;
        data["endDateUtc"] = this.endDateUtc ? this.endDateUtc.toISOString() : <any>undefined;
        data["author"] = this.author ? this.author.toJSON() : <any>undefined;
        if (Array.isArray(this.comments)) {
            data["comments"] = [];
            for (let item of this.comments)
                data["comments"].push(item ? item.toJSON() : <any>undefined);
        }
        if (Array.isArray(this.selections)) {
            data["selections"] = [];
            for (let item of this.selections)
                data["selections"].push(item ? item.toJSON() : <any>undefined);
        }
        return data;
    }
}

export interface IPost {
    id?: string | undefined;
    createdDateUtc?: Date;
    lastUpdatedDateUtc?: Date;
    postType?: string | undefined;
    subject?: string | undefined;
    category?: CategoryType;
    feedContextId?: string | undefined;
    startDateUtc?: Date | undefined;
    endDateUtc?: Date | undefined;
    author?: NeatBoutiqueEntity;
    comments?: Comment[] | undefined;
    selections?: Selection[] | undefined;
}

export class NetworkTopVisitor implements INetworkTopVisitor {
    visitor?: NeatBoutiqueEntity;
    networkVisitsCount?: number;

    constructor(data?: INetworkTopVisitor) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.visitor = _data["visitor"] ? NeatBoutiqueEntity.fromJS(_data["visitor"]) : <any>undefined;
            this.networkVisitsCount = _data["networkVisitsCount"];
        }
    }

    static fromJS(data: any): NetworkTopVisitor {
        data = typeof data === 'object' ? data : {};
        let result = new NetworkTopVisitor();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["visitor"] = this.visitor ? this.visitor.toJSON() : <any>undefined;
        data["networkVisitsCount"] = this.networkVisitsCount;
        return data;
    }
}

export interface INetworkTopVisitor {
    visitor?: NeatBoutiqueEntity;
    networkVisitsCount?: number;
}

export class Network implements INetwork {
    id?: string | undefined;
    createdDateUtc?: Date;
    lastUpdatedDateUtc?: Date;
    postId?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    post?: Post;
    networkTopVisitors?: NetworkTopVisitor[] | undefined;

    constructor(data?: INetwork) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdDateUtc = _data["createdDateUtc"] ? new Date(_data["createdDateUtc"].toString()) : <any>undefined;
            this.lastUpdatedDateUtc = _data["lastUpdatedDateUtc"] ? new Date(_data["lastUpdatedDateUtc"].toString()) : <any>undefined;
            this.postId = _data["postId"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.post = _data["post"] ? Post.fromJS(_data["post"]) : <any>undefined;
            if (Array.isArray(_data["networkTopVisitors"])) {
                this.networkTopVisitors = [] as any;
                for (let item of _data["networkTopVisitors"])
                    this.networkTopVisitors!.push(NetworkTopVisitor.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Network {
        data = typeof data === 'object' ? data : {};
        let result = new Network();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdDateUtc"] = this.createdDateUtc ? this.createdDateUtc.toISOString() : <any>undefined;
        data["lastUpdatedDateUtc"] = this.lastUpdatedDateUtc ? this.lastUpdatedDateUtc.toISOString() : <any>undefined;
        data["postId"] = this.postId;
        data["name"] = this.name;
        data["description"] = this.description;
        data["post"] = this.post ? this.post.toJSON() : <any>undefined;
        if (Array.isArray(this.networkTopVisitors)) {
            data["networkTopVisitors"] = [];
            for (let item of this.networkTopVisitors)
                data["networkTopVisitors"].push(item ? item.toJSON() : <any>undefined);
        }
        return data;
    }
}

export interface INetwork {
    id?: string | undefined;
    createdDateUtc?: Date;
    lastUpdatedDateUtc?: Date;
    postId?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    post?: Post;
    networkTopVisitors?: NetworkTopVisitor[] | undefined;
}

export class VendorProfile implements IVendorProfile {
    id?: string | undefined;
    createdDateUtc?: Date;
    lastUpdatedDateUtc?: Date;
    googlePlaceId?: string | undefined;
    googlePlaceSearchReference?: string | undefined;
    vendorSubscriptionPlan?: string | undefined;
    stripePriceId?: string | undefined;
    name?: string | undefined;
    address?: string | undefined;
    city?: string | undefined;
    state?: string | undefined;
    country?: string | undefined;
    zip?: string | undefined;
    phoneNumber?: string | undefined;
    websiteURL?: string | undefined;
    businessEmail?: string | undefined;
    facebookURL?: string | undefined;
    instagramURL?: string | undefined;
    twitterURL?: string | undefined;
    photosDictionary?: { [key: string]: string; } | undefined;
    description?: string | undefined;
    avatarSourceURL?: string | undefined;
    profilePath?: string | undefined;
    borderColor?: string | undefined;
    categories?: CategoryType[] | undefined;
    reviewCount?: number;
    reviewRatingTotal?: number;
    generalDiscounts?: CustomerDiscount[] | undefined;
    questionsAnsweredCount?: number;
    network?: Network;

    constructor(data?: IVendorProfile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdDateUtc = _data["createdDateUtc"] ? new Date(_data["createdDateUtc"].toString()) : <any>undefined;
            this.lastUpdatedDateUtc = _data["lastUpdatedDateUtc"] ? new Date(_data["lastUpdatedDateUtc"].toString()) : <any>undefined;
            this.googlePlaceId = _data["googlePlaceId"];
            this.googlePlaceSearchReference = _data["googlePlaceSearchReference"];
            this.vendorSubscriptionPlan = _data["vendorSubscriptionPlan"];
            this.stripePriceId = _data["stripePriceId"];
            this.name = _data["name"];
            this.address = _data["address"];
            this.city = _data["city"];
            this.state = _data["state"];
            this.country = _data["country"];
            this.zip = _data["zip"];
            this.phoneNumber = _data["phoneNumber"];
            this.websiteURL = _data["websiteURL"];
            this.businessEmail = _data["businessEmail"];
            this.facebookURL = _data["facebookURL"];
            this.instagramURL = _data["instagramURL"];
            this.twitterURL = _data["twitterURL"];
            if (_data["photosDictionary"]) {
                this.photosDictionary = {} as any;
                for (let key in _data["photosDictionary"]) {
                    if (_data["photosDictionary"].hasOwnProperty(key))
                        (<any>this.photosDictionary)![key] = _data["photosDictionary"][key];
                }
            }
            this.description = _data["description"];
            this.avatarSourceURL = _data["avatarSourceURL"];
            this.profilePath = _data["profilePath"];
            this.borderColor = _data["borderColor"];
            if (Array.isArray(_data["categories"])) {
                this.categories = [] as any;
                for (let item of _data["categories"])
                    this.categories!.push(item);
            }
            this.reviewCount = _data["reviewCount"];
            this.reviewRatingTotal = _data["reviewRatingTotal"];
            if (Array.isArray(_data["generalDiscounts"])) {
                this.generalDiscounts = [] as any;
                for (let item of _data["generalDiscounts"])
                    this.generalDiscounts!.push(CustomerDiscount.fromJS(item));
            }
            this.questionsAnsweredCount = _data["questionsAnsweredCount"];
            this.network = _data["network"] ? Network.fromJS(_data["network"]) : <any>undefined;
        }
    }

    static fromJS(data: any): VendorProfile {
        data = typeof data === 'object' ? data : {};
        let result = new VendorProfile();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdDateUtc"] = this.createdDateUtc ? this.createdDateUtc.toISOString() : <any>undefined;
        data["lastUpdatedDateUtc"] = this.lastUpdatedDateUtc ? this.lastUpdatedDateUtc.toISOString() : <any>undefined;
        data["googlePlaceId"] = this.googlePlaceId;
        data["googlePlaceSearchReference"] = this.googlePlaceSearchReference;
        data["vendorSubscriptionPlan"] = this.vendorSubscriptionPlan;
        data["stripePriceId"] = this.stripePriceId;
        data["name"] = this.name;
        data["address"] = this.address;
        data["city"] = this.city;
        data["state"] = this.state;
        data["country"] = this.country;
        data["zip"] = this.zip;
        data["phoneNumber"] = this.phoneNumber;
        data["websiteURL"] = this.websiteURL;
        data["businessEmail"] = this.businessEmail;
        data["facebookURL"] = this.facebookURL;
        data["instagramURL"] = this.instagramURL;
        data["twitterURL"] = this.twitterURL;
        if (this.photosDictionary) {
            data["photosDictionary"] = {};
            for (let key in this.photosDictionary) {
                if (this.photosDictionary.hasOwnProperty(key))
                    (<any>data["photosDictionary"])[key] = (<any>this.photosDictionary)[key];
            }
        }
        data["description"] = this.description;
        data["avatarSourceURL"] = this.avatarSourceURL;
        data["profilePath"] = this.profilePath;
        data["borderColor"] = this.borderColor;
        if (Array.isArray(this.categories)) {
            data["categories"] = [];
            for (let item of this.categories)
                data["categories"].push(item);
        }
        data["reviewCount"] = this.reviewCount;
        data["reviewRatingTotal"] = this.reviewRatingTotal;
        if (Array.isArray(this.generalDiscounts)) {
            data["generalDiscounts"] = [];
            for (let item of this.generalDiscounts)
                data["generalDiscounts"].push(item ? item.toJSON() : <any>undefined);
        }
        data["questionsAnsweredCount"] = this.questionsAnsweredCount;
        data["network"] = this.network ? this.network.toJSON() : <any>undefined;
        return data;
    }
}

export interface IVendorProfile {
    id?: string | undefined;
    createdDateUtc?: Date;
    lastUpdatedDateUtc?: Date;
    googlePlaceId?: string | undefined;
    googlePlaceSearchReference?: string | undefined;
    vendorSubscriptionPlan?: string | undefined;
    stripePriceId?: string | undefined;
    name?: string | undefined;
    address?: string | undefined;
    city?: string | undefined;
    state?: string | undefined;
    country?: string | undefined;
    zip?: string | undefined;
    phoneNumber?: string | undefined;
    websiteURL?: string | undefined;
    businessEmail?: string | undefined;
    facebookURL?: string | undefined;
    instagramURL?: string | undefined;
    twitterURL?: string | undefined;
    photosDictionary?: { [key: string]: string; } | undefined;
    description?: string | undefined;
    avatarSourceURL?: string | undefined;
    profilePath?: string | undefined;
    borderColor?: string | undefined;
    categories?: CategoryType[] | undefined;
    reviewCount?: number;
    reviewRatingTotal?: number;
    generalDiscounts?: CustomerDiscount[] | undefined;
    questionsAnsweredCount?: number;
    network?: Network;
}

export class ProfilesResponse implements IProfilesResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    consumerProfile?: ConsumerProfile;
    vendorProfile?: VendorProfile;
    notificationCategories?: CategoryType[] | undefined;
    feedCategoriesToShow?: CategoryType[] | undefined;
    notificationsForAnsweredQuestions?: boolean;
    isAdmin?: boolean;

    constructor(data?: IProfilesResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ErrorDto.fromJS(item));
            }
            this.isSuccess = _data["isSuccess"];
            this.consumerProfile = _data["consumerProfile"] ? ConsumerProfile.fromJS(_data["consumerProfile"]) : <any>undefined;
            this.vendorProfile = _data["vendorProfile"] ? VendorProfile.fromJS(_data["vendorProfile"]) : <any>undefined;
            if (Array.isArray(_data["notificationCategories"])) {
                this.notificationCategories = [] as any;
                for (let item of _data["notificationCategories"])
                    this.notificationCategories!.push(item);
            }
            if (Array.isArray(_data["feedCategoriesToShow"])) {
                this.feedCategoriesToShow = [] as any;
                for (let item of _data["feedCategoriesToShow"])
                    this.feedCategoriesToShow!.push(item);
            }
            this.notificationsForAnsweredQuestions = _data["notificationsForAnsweredQuestions"];
            this.isAdmin = _data["isAdmin"];
        }
    }

    static fromJS(data: any): ProfilesResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ProfilesResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item ? item.toJSON() : <any>undefined);
        }
        data["isSuccess"] = this.isSuccess;
        data["consumerProfile"] = this.consumerProfile ? this.consumerProfile.toJSON() : <any>undefined;
        data["vendorProfile"] = this.vendorProfile ? this.vendorProfile.toJSON() : <any>undefined;
        if (Array.isArray(this.notificationCategories)) {
            data["notificationCategories"] = [];
            for (let item of this.notificationCategories)
                data["notificationCategories"].push(item);
        }
        if (Array.isArray(this.feedCategoriesToShow)) {
            data["feedCategoriesToShow"] = [];
            for (let item of this.feedCategoriesToShow)
                data["feedCategoriesToShow"].push(item);
        }
        data["notificationsForAnsweredQuestions"] = this.notificationsForAnsweredQuestions;
        data["isAdmin"] = this.isAdmin;
        return data;
    }
}

export interface IProfilesResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    consumerProfile?: ConsumerProfile;
    vendorProfile?: VendorProfile;
    notificationCategories?: CategoryType[] | undefined;
    feedCategoriesToShow?: CategoryType[] | undefined;
    notificationsForAnsweredQuestions?: boolean;
    isAdmin?: boolean;
}

export class AccountCreateRequest implements IAccountCreateRequest {
    googleAuthUserId?: string | undefined;
    username?: string | undefined;
    email?: string | undefined;

    constructor(data?: IAccountCreateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.googleAuthUserId = _data["googleAuthUserId"];
            this.username = _data["username"];
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): AccountCreateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AccountCreateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["googleAuthUserId"] = this.googleAuthUserId;
        data["username"] = this.username;
        data["email"] = this.email;
        return data;
    }
}

export interface IAccountCreateRequest {
    googleAuthUserId?: string | undefined;
    username?: string | undefined;
    email?: string | undefined;
}

export class AccountDeletionRequest implements IAccountDeletionRequest {
    userId?: string | undefined;
    token?: string | undefined;

    constructor(data?: IAccountDeletionRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.token = _data["token"];
        }
    }

    static fromJS(data: any): AccountDeletionRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AccountDeletionRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["token"] = this.token;
        return data;
    }
}

export interface IAccountDeletionRequest {
    userId?: string | undefined;
    token?: string | undefined;
}

export class Response implements IResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;

    constructor(data?: IResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ErrorDto.fromJS(item));
            }
            this.isSuccess = _data["isSuccess"];
        }
    }

    static fromJS(data: any): Response {
        data = typeof data === 'object' ? data : {};
        let result = new Response();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item ? item.toJSON() : <any>undefined);
        }
        data["isSuccess"] = this.isSuccess;
        return data;
    }
}

export interface IResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
}

export class AccountNotificationCategoriesRequest implements IAccountNotificationCategoriesRequest {
    notificationToken?: string | undefined;
    notificationCategories?: CategoryType[] | undefined;
    notificationsForAnsweredQuestions?: boolean;

    constructor(data?: IAccountNotificationCategoriesRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.notificationToken = _data["notificationToken"];
            if (Array.isArray(_data["notificationCategories"])) {
                this.notificationCategories = [] as any;
                for (let item of _data["notificationCategories"])
                    this.notificationCategories!.push(item);
            }
            this.notificationsForAnsweredQuestions = _data["notificationsForAnsweredQuestions"];
        }
    }

    static fromJS(data: any): AccountNotificationCategoriesRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AccountNotificationCategoriesRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["notificationToken"] = this.notificationToken;
        if (Array.isArray(this.notificationCategories)) {
            data["notificationCategories"] = [];
            for (let item of this.notificationCategories)
                data["notificationCategories"].push(item);
        }
        data["notificationsForAnsweredQuestions"] = this.notificationsForAnsweredQuestions;
        return data;
    }
}

export interface IAccountNotificationCategoriesRequest {
    notificationToken?: string | undefined;
    notificationCategories?: CategoryType[] | undefined;
    notificationsForAnsweredQuestions?: boolean;
}

export class NotificationTokenRequest implements INotificationTokenRequest {
    notificationToken?: string | undefined;

    constructor(data?: INotificationTokenRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.notificationToken = _data["notificationToken"];
        }
    }

    static fromJS(data: any): NotificationTokenRequest {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationTokenRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["notificationToken"] = this.notificationToken;
        return data;
    }
}

export interface INotificationTokenRequest {
    notificationToken?: string | undefined;
}

export class AccountFeedSettingsRequest implements IAccountFeedSettingsRequest {
    feedCategoriesToShow?: CategoryType[] | undefined;

    constructor(data?: IAccountFeedSettingsRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["feedCategoriesToShow"])) {
                this.feedCategoriesToShow = [] as any;
                for (let item of _data["feedCategoriesToShow"])
                    this.feedCategoriesToShow!.push(item);
            }
        }
    }

    static fromJS(data: any): AccountFeedSettingsRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AccountFeedSettingsRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.feedCategoriesToShow)) {
            data["feedCategoriesToShow"] = [];
            for (let item of this.feedCategoriesToShow)
                data["feedCategoriesToShow"].push(item);
        }
        return data;
    }
}

export interface IAccountFeedSettingsRequest {
    feedCategoriesToShow?: CategoryType[] | undefined;
}

export class AnswerWithVendorRequest implements IAnswerWithVendorRequest {
    postId?: string | undefined;
    vendor?: NeatBoutiqueEntity;
    voteRanking?: string | undefined;

    constructor(data?: IAnswerWithVendorRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.postId = _data["postId"];
            this.vendor = _data["vendor"] ? NeatBoutiqueEntity.fromJS(_data["vendor"]) : <any>undefined;
            this.voteRanking = _data["voteRanking"];
        }
    }

    static fromJS(data: any): AnswerWithVendorRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AnswerWithVendorRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["postId"] = this.postId;
        data["vendor"] = this.vendor ? this.vendor.toJSON() : <any>undefined;
        data["voteRanking"] = this.voteRanking;
        return data;
    }
}

export interface IAnswerWithVendorRequest {
    postId?: string | undefined;
    vendor?: NeatBoutiqueEntity;
    voteRanking?: string | undefined;
}

export class PostResponse implements IPostResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    post?: Post;

    constructor(data?: IPostResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ErrorDto.fromJS(item));
            }
            this.isSuccess = _data["isSuccess"];
            this.post = _data["post"] ? Post.fromJS(_data["post"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PostResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PostResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item ? item.toJSON() : <any>undefined);
        }
        data["isSuccess"] = this.isSuccess;
        data["post"] = this.post ? this.post.toJSON() : <any>undefined;
        return data;
    }
}

export interface IPostResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    post?: Post;
}

export class AnswerWithGooglePlaceRequest implements IAnswerWithGooglePlaceRequest {
    postId?: string | undefined;
    googlePlace?: GooglePlacesEntity;
    googleSearchSessionToken?: string | undefined;
    voteRanking?: string | undefined;

    constructor(data?: IAnswerWithGooglePlaceRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.postId = _data["postId"];
            this.googlePlace = _data["googlePlace"] ? GooglePlacesEntity.fromJS(_data["googlePlace"]) : <any>undefined;
            this.googleSearchSessionToken = _data["googleSearchSessionToken"];
            this.voteRanking = _data["voteRanking"];
        }
    }

    static fromJS(data: any): AnswerWithGooglePlaceRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AnswerWithGooglePlaceRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["postId"] = this.postId;
        data["googlePlace"] = this.googlePlace ? this.googlePlace.toJSON() : <any>undefined;
        data["googleSearchSessionToken"] = this.googleSearchSessionToken;
        data["voteRanking"] = this.voteRanking;
        return data;
    }
}

export interface IAnswerWithGooglePlaceRequest {
    postId?: string | undefined;
    googlePlace?: GooglePlacesEntity;
    googleSearchSessionToken?: string | undefined;
    voteRanking?: string | undefined;
}

export class AnswerVoteRemoveRequest implements IAnswerVoteRemoveRequest {
    answerVote?: SelectionVote;

    constructor(data?: IAnswerVoteRemoveRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.answerVote = _data["answerVote"] ? SelectionVote.fromJS(_data["answerVote"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AnswerVoteRemoveRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AnswerVoteRemoveRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["answerVote"] = this.answerVote ? this.answerVote.toJSON() : <any>undefined;
        return data;
    }
}

export interface IAnswerVoteRemoveRequest {
    answerVote?: SelectionVote;
}

export class PollAnswerRequest implements IPollAnswerRequest {
    answerId?: string | undefined;
    voteRanking?: string | undefined;

    constructor(data?: IPollAnswerRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.answerId = _data["answerId"];
            this.voteRanking = _data["voteRanking"];
        }
    }

    static fromJS(data: any): PollAnswerRequest {
        data = typeof data === 'object' ? data : {};
        let result = new PollAnswerRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["answerId"] = this.answerId;
        data["voteRanking"] = this.voteRanking;
        return data;
    }
}

export interface IPollAnswerRequest {
    answerId?: string | undefined;
    voteRanking?: string | undefined;
}

export class CategoryRequest implements ICategoryRequest {
    categories?: CategoryType[] | undefined;
    pageNumber?: number;
    pageSize?: number;
    includeRecentPostsCount?: number;

    constructor(data?: ICategoryRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["categories"])) {
                this.categories = [] as any;
                for (let item of _data["categories"])
                    this.categories!.push(item);
            }
            this.pageNumber = _data["pageNumber"];
            this.pageSize = _data["pageSize"];
            this.includeRecentPostsCount = _data["includeRecentPostsCount"];
        }
    }

    static fromJS(data: any): CategoryRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.categories)) {
            data["categories"] = [];
            for (let item of this.categories)
                data["categories"].push(item);
        }
        data["pageNumber"] = this.pageNumber;
        data["pageSize"] = this.pageSize;
        data["includeRecentPostsCount"] = this.includeRecentPostsCount;
        return data;
    }
}

export interface ICategoryRequest {
    categories?: CategoryType[] | undefined;
    pageNumber?: number;
    pageSize?: number;
    includeRecentPostsCount?: number;
}

export class AdTagline implements IAdTagline {
    primaryAdTagline?: string | undefined;
    secondaryAdTagline?: string | undefined;

    constructor(data?: IAdTagline) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.primaryAdTagline = _data["primaryAdTagline"];
            this.secondaryAdTagline = _data["secondaryAdTagline"];
        }
    }

    static fromJS(data: any): AdTagline {
        data = typeof data === 'object' ? data : {};
        let result = new AdTagline();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["primaryAdTagline"] = this.primaryAdTagline;
        data["secondaryAdTagline"] = this.secondaryAdTagline;
        return data;
    }
}

export interface IAdTagline {
    primaryAdTagline?: string | undefined;
    secondaryAdTagline?: string | undefined;
}

export class HeroAd implements IHeroAd {
    id?: string | undefined;
    createdDateUtc?: Date;
    lastUpdatedDateUtc?: Date;
    vendor?: NeatBoutiqueEntity;
    campaignStartDateUtc?: Date;
    campaignEndDateUtc?: Date;
    isActive?: boolean;
    imageUrl?: string | undefined;
    adTagline?: AdTagline;
    callToAction?: string | undefined;
    category?: CategoryType;

    constructor(data?: IHeroAd) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdDateUtc = _data["createdDateUtc"] ? new Date(_data["createdDateUtc"].toString()) : <any>undefined;
            this.lastUpdatedDateUtc = _data["lastUpdatedDateUtc"] ? new Date(_data["lastUpdatedDateUtc"].toString()) : <any>undefined;
            this.vendor = _data["vendor"] ? NeatBoutiqueEntity.fromJS(_data["vendor"]) : <any>undefined;
            this.campaignStartDateUtc = _data["campaignStartDateUtc"] ? new Date(_data["campaignStartDateUtc"].toString()) : <any>undefined;
            this.campaignEndDateUtc = _data["campaignEndDateUtc"] ? new Date(_data["campaignEndDateUtc"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
            this.imageUrl = _data["imageUrl"];
            this.adTagline = _data["adTagline"] ? AdTagline.fromJS(_data["adTagline"]) : <any>undefined;
            this.callToAction = _data["callToAction"];
            this.category = _data["category"];
        }
    }

    static fromJS(data: any): HeroAd {
        data = typeof data === 'object' ? data : {};
        let result = new HeroAd();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdDateUtc"] = this.createdDateUtc ? this.createdDateUtc.toISOString() : <any>undefined;
        data["lastUpdatedDateUtc"] = this.lastUpdatedDateUtc ? this.lastUpdatedDateUtc.toISOString() : <any>undefined;
        data["vendor"] = this.vendor ? this.vendor.toJSON() : <any>undefined;
        data["campaignStartDateUtc"] = this.campaignStartDateUtc ? this.campaignStartDateUtc.toISOString() : <any>undefined;
        data["campaignEndDateUtc"] = this.campaignEndDateUtc ? this.campaignEndDateUtc.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        data["imageUrl"] = this.imageUrl;
        data["adTagline"] = this.adTagline ? this.adTagline.toJSON() : <any>undefined;
        data["callToAction"] = this.callToAction;
        data["category"] = this.category;
        return data;
    }
}

export interface IHeroAd {
    id?: string | undefined;
    createdDateUtc?: Date;
    lastUpdatedDateUtc?: Date;
    vendor?: NeatBoutiqueEntity;
    campaignStartDateUtc?: Date;
    campaignEndDateUtc?: Date;
    isActive?: boolean;
    imageUrl?: string | undefined;
    adTagline?: AdTagline;
    callToAction?: string | undefined;
    category?: CategoryType;
}

export class CategoryResponse implements ICategoryResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    consumerQuestions?: Post[] | undefined;
    vendorPolls?: Post[] | undefined;
    recentConsumerQuestions?: Post[] | undefined;
    vendorRoutes?: Post[] | undefined;
    heroAds?: HeroAd[] | undefined;

    constructor(data?: ICategoryResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ErrorDto.fromJS(item));
            }
            this.isSuccess = _data["isSuccess"];
            if (Array.isArray(_data["consumerQuestions"])) {
                this.consumerQuestions = [] as any;
                for (let item of _data["consumerQuestions"])
                    this.consumerQuestions!.push(Post.fromJS(item));
            }
            if (Array.isArray(_data["vendorPolls"])) {
                this.vendorPolls = [] as any;
                for (let item of _data["vendorPolls"])
                    this.vendorPolls!.push(Post.fromJS(item));
            }
            if (Array.isArray(_data["recentConsumerQuestions"])) {
                this.recentConsumerQuestions = [] as any;
                for (let item of _data["recentConsumerQuestions"])
                    this.recentConsumerQuestions!.push(Post.fromJS(item));
            }
            if (Array.isArray(_data["vendorRoutes"])) {
                this.vendorRoutes = [] as any;
                for (let item of _data["vendorRoutes"])
                    this.vendorRoutes!.push(Post.fromJS(item));
            }
            if (Array.isArray(_data["heroAds"])) {
                this.heroAds = [] as any;
                for (let item of _data["heroAds"])
                    this.heroAds!.push(HeroAd.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CategoryResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item ? item.toJSON() : <any>undefined);
        }
        data["isSuccess"] = this.isSuccess;
        if (Array.isArray(this.consumerQuestions)) {
            data["consumerQuestions"] = [];
            for (let item of this.consumerQuestions)
                data["consumerQuestions"].push(item ? item.toJSON() : <any>undefined);
        }
        if (Array.isArray(this.vendorPolls)) {
            data["vendorPolls"] = [];
            for (let item of this.vendorPolls)
                data["vendorPolls"].push(item ? item.toJSON() : <any>undefined);
        }
        if (Array.isArray(this.recentConsumerQuestions)) {
            data["recentConsumerQuestions"] = [];
            for (let item of this.recentConsumerQuestions)
                data["recentConsumerQuestions"].push(item ? item.toJSON() : <any>undefined);
        }
        if (Array.isArray(this.vendorRoutes)) {
            data["vendorRoutes"] = [];
            for (let item of this.vendorRoutes)
                data["vendorRoutes"].push(item ? item.toJSON() : <any>undefined);
        }
        if (Array.isArray(this.heroAds)) {
            data["heroAds"] = [];
            for (let item of this.heroAds)
                data["heroAds"].push(item ? item.toJSON() : <any>undefined);
        }
        return data;
    }
}

export interface ICategoryResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    consumerQuestions?: Post[] | undefined;
    vendorPolls?: Post[] | undefined;
    recentConsumerQuestions?: Post[] | undefined;
    vendorRoutes?: Post[] | undefined;
    heroAds?: HeroAd[] | undefined;
}

export class CommentRequest implements ICommentRequest {
    postId?: string | undefined;
    body?: string | undefined;
    authorRole?: string | undefined;
    authorId?: string | undefined;

    constructor(data?: ICommentRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.postId = _data["postId"];
            this.body = _data["body"];
            this.authorRole = _data["authorRole"];
            this.authorId = _data["authorId"];
        }
    }

    static fromJS(data: any): CommentRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CommentRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["postId"] = this.postId;
        data["body"] = this.body;
        data["authorRole"] = this.authorRole;
        data["authorId"] = this.authorId;
        return data;
    }
}

export interface ICommentRequest {
    postId?: string | undefined;
    body?: string | undefined;
    authorRole?: string | undefined;
    authorId?: string | undefined;
}

export class CommentResponse implements ICommentResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    comment?: Comment;

    constructor(data?: ICommentResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ErrorDto.fromJS(item));
            }
            this.isSuccess = _data["isSuccess"];
            this.comment = _data["comment"] ? Comment.fromJS(_data["comment"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CommentResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CommentResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item ? item.toJSON() : <any>undefined);
        }
        data["isSuccess"] = this.isSuccess;
        data["comment"] = this.comment ? this.comment.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICommentResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    comment?: Comment;
}

export class CommentRemoveRequest implements ICommentRemoveRequest {
    commentId?: string | undefined;
    authorId?: string | undefined;

    constructor(data?: ICommentRemoveRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.commentId = _data["commentId"];
            this.authorId = _data["authorId"];
        }
    }

    static fromJS(data: any): CommentRemoveRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CommentRemoveRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commentId"] = this.commentId;
        data["authorId"] = this.authorId;
        return data;
    }
}

export interface ICommentRemoveRequest {
    commentId?: string | undefined;
    authorId?: string | undefined;
}

export class CommentLikeAddRequest implements ICommentLikeAddRequest {
    commentId?: string | undefined;
    likerId?: string | undefined;
    likerRole?: string | undefined;

    constructor(data?: ICommentLikeAddRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.commentId = _data["commentId"];
            this.likerId = _data["likerId"];
            this.likerRole = _data["likerRole"];
        }
    }

    static fromJS(data: any): CommentLikeAddRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CommentLikeAddRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commentId"] = this.commentId;
        data["likerId"] = this.likerId;
        data["likerRole"] = this.likerRole;
        return data;
    }
}

export interface ICommentLikeAddRequest {
    commentId?: string | undefined;
    likerId?: string | undefined;
    likerRole?: string | undefined;
}

export class CommentLikeRemoveRequest implements ICommentLikeRemoveRequest {
    commentId?: string | undefined;
    likerId?: string | undefined;

    constructor(data?: ICommentLikeRemoveRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.commentId = _data["commentId"];
            this.likerId = _data["likerId"];
        }
    }

    static fromJS(data: any): CommentLikeRemoveRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CommentLikeRemoveRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commentId"] = this.commentId;
        data["likerId"] = this.likerId;
        return data;
    }
}

export interface ICommentLikeRemoveRequest {
    commentId?: string | undefined;
    likerId?: string | undefined;
}

export class CommentUpdateRequest implements ICommentUpdateRequest {
    commentId?: string | undefined;
    authorId?: string | undefined;
    body?: string | undefined;

    constructor(data?: ICommentUpdateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.commentId = _data["commentId"];
            this.authorId = _data["authorId"];
            this.body = _data["body"];
        }
    }

    static fromJS(data: any): CommentUpdateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CommentUpdateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commentId"] = this.commentId;
        data["authorId"] = this.authorId;
        data["body"] = this.body;
        return data;
    }
}

export interface ICommentUpdateRequest {
    commentId?: string | undefined;
    authorId?: string | undefined;
    body?: string | undefined;
}

export class MyPlacesRequest implements IMyPlacesRequest {
    vendorId?: string | undefined;

    constructor(data?: IMyPlacesRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.vendorId = _data["vendorId"];
        }
    }

    static fromJS(data: any): MyPlacesRequest {
        data = typeof data === 'object' ? data : {};
        let result = new MyPlacesRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vendorId"] = this.vendorId;
        return data;
    }
}

export interface IMyPlacesRequest {
    vendorId?: string | undefined;
}

export class MyQuestionsRequest implements IMyQuestionsRequest {
    pageNumber?: number;
    pageSize?: number;

    constructor(data?: IMyQuestionsRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageNumber = _data["pageNumber"];
            this.pageSize = _data["pageSize"];
        }
    }

    static fromJS(data: any): MyQuestionsRequest {
        data = typeof data === 'object' ? data : {};
        let result = new MyQuestionsRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageNumber"] = this.pageNumber;
        data["pageSize"] = this.pageSize;
        return data;
    }
}

export interface IMyQuestionsRequest {
    pageNumber?: number;
    pageSize?: number;
}

export class PostsResponse implements IPostsResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    posts?: Post[] | undefined;

    constructor(data?: IPostsResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ErrorDto.fromJS(item));
            }
            this.isSuccess = _data["isSuccess"];
            if (Array.isArray(_data["posts"])) {
                this.posts = [] as any;
                for (let item of _data["posts"])
                    this.posts!.push(Post.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PostsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PostsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item ? item.toJSON() : <any>undefined);
        }
        data["isSuccess"] = this.isSuccess;
        if (Array.isArray(this.posts)) {
            data["posts"] = [];
            for (let item of this.posts)
                data["posts"].push(item ? item.toJSON() : <any>undefined);
        }
        return data;
    }
}

export interface IPostsResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    posts?: Post[] | undefined;
}

export class ConsumerProfileRequest implements IConsumerProfileRequest {
    profilePath?: string | undefined;

    constructor(data?: IConsumerProfileRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.profilePath = _data["profilePath"];
        }
    }

    static fromJS(data: any): ConsumerProfileRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ConsumerProfileRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["profilePath"] = this.profilePath;
        return data;
    }
}

export interface IConsumerProfileRequest {
    profilePath?: string | undefined;
}

export class ConsumerProfileResponse implements IConsumerProfileResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    consumerProfile?: ConsumerProfile;

    constructor(data?: IConsumerProfileResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ErrorDto.fromJS(item));
            }
            this.isSuccess = _data["isSuccess"];
            this.consumerProfile = _data["consumerProfile"] ? ConsumerProfile.fromJS(_data["consumerProfile"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ConsumerProfileResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ConsumerProfileResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item ? item.toJSON() : <any>undefined);
        }
        data["isSuccess"] = this.isSuccess;
        data["consumerProfile"] = this.consumerProfile ? this.consumerProfile.toJSON() : <any>undefined;
        return data;
    }
}

export interface IConsumerProfileResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    consumerProfile?: ConsumerProfile;
}

export class ConsumerProfileActivityRequest implements IConsumerProfileActivityRequest {
    consumerId?: string | undefined;
    pageNumber?: number;
    pageSize?: number;

    constructor(data?: IConsumerProfileActivityRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.consumerId = _data["consumerId"];
            this.pageNumber = _data["pageNumber"];
            this.pageSize = _data["pageSize"];
        }
    }

    static fromJS(data: any): ConsumerProfileActivityRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ConsumerProfileActivityRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["consumerId"] = this.consumerId;
        data["pageNumber"] = this.pageNumber;
        data["pageSize"] = this.pageSize;
        return data;
    }
}

export interface IConsumerProfileActivityRequest {
    consumerId?: string | undefined;
    pageNumber?: number;
    pageSize?: number;
}

export class Review implements IReview {
    id?: string | undefined;
    createdDateUtc?: Date;
    lastUpdatedDateUtc?: Date;
    vendorId?: string | undefined;
    author?: NeatBoutiqueEntity;
    title?: string | undefined;
    body?: string | undefined;
    rating?: number;

    constructor(data?: IReview) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdDateUtc = _data["createdDateUtc"] ? new Date(_data["createdDateUtc"].toString()) : <any>undefined;
            this.lastUpdatedDateUtc = _data["lastUpdatedDateUtc"] ? new Date(_data["lastUpdatedDateUtc"].toString()) : <any>undefined;
            this.vendorId = _data["vendorId"];
            this.author = _data["author"] ? NeatBoutiqueEntity.fromJS(_data["author"]) : <any>undefined;
            this.title = _data["title"];
            this.body = _data["body"];
            this.rating = _data["rating"];
        }
    }

    static fromJS(data: any): Review {
        data = typeof data === 'object' ? data : {};
        let result = new Review();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdDateUtc"] = this.createdDateUtc ? this.createdDateUtc.toISOString() : <any>undefined;
        data["lastUpdatedDateUtc"] = this.lastUpdatedDateUtc ? this.lastUpdatedDateUtc.toISOString() : <any>undefined;
        data["vendorId"] = this.vendorId;
        data["author"] = this.author ? this.author.toJSON() : <any>undefined;
        data["title"] = this.title;
        data["body"] = this.body;
        data["rating"] = this.rating;
        return data;
    }
}

export interface IReview {
    id?: string | undefined;
    createdDateUtc?: Date;
    lastUpdatedDateUtc?: Date;
    vendorId?: string | undefined;
    author?: NeatBoutiqueEntity;
    title?: string | undefined;
    body?: string | undefined;
    rating?: number;
}

export class ConsumerProfileActivityResponse implements IConsumerProfileActivityResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    recentQuestions?: Post[] | undefined;
    recentAnswers?: Post[] | undefined;
    recentReviews?: Review[] | undefined;
    questionsAskedCount?: number;
    questionsAnsweredCount?: number;
    reviewsCount?: number;

    constructor(data?: IConsumerProfileActivityResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ErrorDto.fromJS(item));
            }
            this.isSuccess = _data["isSuccess"];
            if (Array.isArray(_data["recentQuestions"])) {
                this.recentQuestions = [] as any;
                for (let item of _data["recentQuestions"])
                    this.recentQuestions!.push(Post.fromJS(item));
            }
            if (Array.isArray(_data["recentAnswers"])) {
                this.recentAnswers = [] as any;
                for (let item of _data["recentAnswers"])
                    this.recentAnswers!.push(Post.fromJS(item));
            }
            if (Array.isArray(_data["recentReviews"])) {
                this.recentReviews = [] as any;
                for (let item of _data["recentReviews"])
                    this.recentReviews!.push(Review.fromJS(item));
            }
            this.questionsAskedCount = _data["questionsAskedCount"];
            this.questionsAnsweredCount = _data["questionsAnsweredCount"];
            this.reviewsCount = _data["reviewsCount"];
        }
    }

    static fromJS(data: any): ConsumerProfileActivityResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ConsumerProfileActivityResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item ? item.toJSON() : <any>undefined);
        }
        data["isSuccess"] = this.isSuccess;
        if (Array.isArray(this.recentQuestions)) {
            data["recentQuestions"] = [];
            for (let item of this.recentQuestions)
                data["recentQuestions"].push(item ? item.toJSON() : <any>undefined);
        }
        if (Array.isArray(this.recentAnswers)) {
            data["recentAnswers"] = [];
            for (let item of this.recentAnswers)
                data["recentAnswers"].push(item ? item.toJSON() : <any>undefined);
        }
        if (Array.isArray(this.recentReviews)) {
            data["recentReviews"] = [];
            for (let item of this.recentReviews)
                data["recentReviews"].push(item ? item.toJSON() : <any>undefined);
        }
        data["questionsAskedCount"] = this.questionsAskedCount;
        data["questionsAnsweredCount"] = this.questionsAnsweredCount;
        data["reviewsCount"] = this.reviewsCount;
        return data;
    }
}

export interface IConsumerProfileActivityResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    recentQuestions?: Post[] | undefined;
    recentAnswers?: Post[] | undefined;
    recentReviews?: Review[] | undefined;
    questionsAskedCount?: number;
    questionsAnsweredCount?: number;
    reviewsCount?: number;
}

export class ConsumerImageRequest implements IConsumerImageRequest {
    base64Image?: string | undefined;

    constructor(data?: IConsumerImageRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.base64Image = _data["base64Image"];
        }
    }

    static fromJS(data: any): ConsumerImageRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ConsumerImageRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["base64Image"] = this.base64Image;
        return data;
    }
}

export interface IConsumerImageRequest {
    base64Image?: string | undefined;
}

export class ConsumerDescriptionRequest implements IConsumerDescriptionRequest {
    description?: string | undefined;

    constructor(data?: IConsumerDescriptionRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): ConsumerDescriptionRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ConsumerDescriptionRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        return data;
    }
}

export interface IConsumerDescriptionRequest {
    description?: string | undefined;
}

export class ConsumerBorderColorRequest implements IConsumerBorderColorRequest {
    borderColor?: string | undefined;

    constructor(data?: IConsumerBorderColorRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.borderColor = _data["borderColor"];
        }
    }

    static fromJS(data: any): ConsumerBorderColorRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ConsumerBorderColorRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["borderColor"] = this.borderColor;
        return data;
    }
}

export interface IConsumerBorderColorRequest {
    borderColor?: string | undefined;
}

export class ConsumerNotificationSettingsRequest implements IConsumerNotificationSettingsRequest {
    notificationToken?: string | undefined;
    notificationCategories?: CategoryType[] | undefined;
    notificationsForAnsweredQuestions?: boolean;

    constructor(data?: IConsumerNotificationSettingsRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.notificationToken = _data["notificationToken"];
            if (Array.isArray(_data["notificationCategories"])) {
                this.notificationCategories = [] as any;
                for (let item of _data["notificationCategories"])
                    this.notificationCategories!.push(item);
            }
            this.notificationsForAnsweredQuestions = _data["notificationsForAnsweredQuestions"];
        }
    }

    static fromJS(data: any): ConsumerNotificationSettingsRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ConsumerNotificationSettingsRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["notificationToken"] = this.notificationToken;
        if (Array.isArray(this.notificationCategories)) {
            data["notificationCategories"] = [];
            for (let item of this.notificationCategories)
                data["notificationCategories"].push(item);
        }
        data["notificationsForAnsweredQuestions"] = this.notificationsForAnsweredQuestions;
        return data;
    }
}

export interface IConsumerNotificationSettingsRequest {
    notificationToken?: string | undefined;
    notificationCategories?: CategoryType[] | undefined;
    notificationsForAnsweredQuestions?: boolean;
}

export class ConsumerFeedSettingsRequest implements IConsumerFeedSettingsRequest {
    feedCategoriesToShow?: CategoryType[] | undefined;

    constructor(data?: IConsumerFeedSettingsRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["feedCategoriesToShow"])) {
                this.feedCategoriesToShow = [] as any;
                for (let item of _data["feedCategoriesToShow"])
                    this.feedCategoriesToShow!.push(item);
            }
        }
    }

    static fromJS(data: any): ConsumerFeedSettingsRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ConsumerFeedSettingsRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.feedCategoriesToShow)) {
            data["feedCategoriesToShow"] = [];
            for (let item of this.feedCategoriesToShow)
                data["feedCategoriesToShow"].push(item);
        }
        return data;
    }
}

export interface IConsumerFeedSettingsRequest {
    feedCategoriesToShow?: CategoryType[] | undefined;
}

export class ContactUsRequest implements IContactUsRequest {
    email?: string | undefined;
    name?: string | undefined;
    body?: string | undefined;
    reCaptchaToken?: string | undefined;

    constructor(data?: IContactUsRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.name = _data["name"];
            this.body = _data["body"];
            this.reCaptchaToken = _data["reCaptchaToken"];
        }
    }

    static fromJS(data: any): ContactUsRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ContactUsRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["name"] = this.name;
        data["body"] = this.body;
        data["reCaptchaToken"] = this.reCaptchaToken;
        return data;
    }
}

export interface IContactUsRequest {
    email?: string | undefined;
    name?: string | undefined;
    body?: string | undefined;
    reCaptchaToken?: string | undefined;
}

export class VendorProfileRequest implements IVendorProfileRequest {
    vendorId?: string | undefined;
    profilePath?: string | undefined;

    constructor(data?: IVendorProfileRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.vendorId = _data["vendorId"];
            this.profilePath = _data["profilePath"];
        }
    }

    static fromJS(data: any): VendorProfileRequest {
        data = typeof data === 'object' ? data : {};
        let result = new VendorProfileRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vendorId"] = this.vendorId;
        data["profilePath"] = this.profilePath;
        return data;
    }
}

export interface IVendorProfileRequest {
    vendorId?: string | undefined;
    profilePath?: string | undefined;
}

export class HeroAdTemplate implements IHeroAdTemplate {
    id?: string | undefined;
    createdDateUtc?: Date;
    lastUpdatedDateUtc?: Date;
    imageUrls?: string[] | undefined;
    adTaglines?: AdTagline[] | undefined;
    callsToAction?: string[] | undefined;
    category?: CategoryType;

    constructor(data?: IHeroAdTemplate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdDateUtc = _data["createdDateUtc"] ? new Date(_data["createdDateUtc"].toString()) : <any>undefined;
            this.lastUpdatedDateUtc = _data["lastUpdatedDateUtc"] ? new Date(_data["lastUpdatedDateUtc"].toString()) : <any>undefined;
            if (Array.isArray(_data["imageUrls"])) {
                this.imageUrls = [] as any;
                for (let item of _data["imageUrls"])
                    this.imageUrls!.push(item);
            }
            if (Array.isArray(_data["adTaglines"])) {
                this.adTaglines = [] as any;
                for (let item of _data["adTaglines"])
                    this.adTaglines!.push(AdTagline.fromJS(item));
            }
            if (Array.isArray(_data["callsToAction"])) {
                this.callsToAction = [] as any;
                for (let item of _data["callsToAction"])
                    this.callsToAction!.push(item);
            }
            this.category = _data["category"];
        }
    }

    static fromJS(data: any): HeroAdTemplate {
        data = typeof data === 'object' ? data : {};
        let result = new HeroAdTemplate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdDateUtc"] = this.createdDateUtc ? this.createdDateUtc.toISOString() : <any>undefined;
        data["lastUpdatedDateUtc"] = this.lastUpdatedDateUtc ? this.lastUpdatedDateUtc.toISOString() : <any>undefined;
        if (Array.isArray(this.imageUrls)) {
            data["imageUrls"] = [];
            for (let item of this.imageUrls)
                data["imageUrls"].push(item);
        }
        if (Array.isArray(this.adTaglines)) {
            data["adTaglines"] = [];
            for (let item of this.adTaglines)
                data["adTaglines"].push(item ? item.toJSON() : <any>undefined);
        }
        if (Array.isArray(this.callsToAction)) {
            data["callsToAction"] = [];
            for (let item of this.callsToAction)
                data["callsToAction"].push(item);
        }
        data["category"] = this.category;
        return data;
    }
}

export interface IHeroAdTemplate {
    id?: string | undefined;
    createdDateUtc?: Date;
    lastUpdatedDateUtc?: Date;
    imageUrls?: string[] | undefined;
    adTaglines?: AdTagline[] | undefined;
    callsToAction?: string[] | undefined;
    category?: CategoryType;
}

export class HeroAdTemplatesResponse implements IHeroAdTemplatesResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    templates?: HeroAdTemplate[] | undefined;

    constructor(data?: IHeroAdTemplatesResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ErrorDto.fromJS(item));
            }
            this.isSuccess = _data["isSuccess"];
            if (Array.isArray(_data["templates"])) {
                this.templates = [] as any;
                for (let item of _data["templates"])
                    this.templates!.push(HeroAdTemplate.fromJS(item));
            }
        }
    }

    static fromJS(data: any): HeroAdTemplatesResponse {
        data = typeof data === 'object' ? data : {};
        let result = new HeroAdTemplatesResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item ? item.toJSON() : <any>undefined);
        }
        data["isSuccess"] = this.isSuccess;
        if (Array.isArray(this.templates)) {
            data["templates"] = [];
            for (let item of this.templates)
                data["templates"].push(item ? item.toJSON() : <any>undefined);
        }
        return data;
    }
}

export interface IHeroAdTemplatesResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    templates?: HeroAdTemplate[] | undefined;
}

export class CreateHeroAdRequest implements ICreateHeroAdRequest {
    category?: CategoryType;
    adTagline?: AdTagline;
    callToAction?: string | undefined;
    imageUrl?: string | undefined;
    vendorProfileId?: string | undefined;

    constructor(data?: ICreateHeroAdRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.category = _data["category"];
            this.adTagline = _data["adTagline"] ? AdTagline.fromJS(_data["adTagline"]) : <any>undefined;
            this.callToAction = _data["callToAction"];
            this.imageUrl = _data["imageUrl"];
            this.vendorProfileId = _data["vendorProfileId"];
        }
    }

    static fromJS(data: any): CreateHeroAdRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateHeroAdRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["category"] = this.category;
        data["adTagline"] = this.adTagline ? this.adTagline.toJSON() : <any>undefined;
        data["callToAction"] = this.callToAction;
        data["imageUrl"] = this.imageUrl;
        data["vendorProfileId"] = this.vendorProfileId;
        return data;
    }
}

export interface ICreateHeroAdRequest {
    category?: CategoryType;
    adTagline?: AdTagline;
    callToAction?: string | undefined;
    imageUrl?: string | undefined;
    vendorProfileId?: string | undefined;
}

export class CreateNetworkRequest implements ICreateNetworkRequest {
    name?: string | undefined;
    description?: string | undefined;
    vendorId?: string | undefined;
    discountsForNetworkMembers?: CustomerDiscount[] | undefined;

    constructor(data?: ICreateNetworkRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.vendorId = _data["vendorId"];
            if (Array.isArray(_data["discountsForNetworkMembers"])) {
                this.discountsForNetworkMembers = [] as any;
                for (let item of _data["discountsForNetworkMembers"])
                    this.discountsForNetworkMembers!.push(CustomerDiscount.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateNetworkRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateNetworkRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["vendorId"] = this.vendorId;
        if (Array.isArray(this.discountsForNetworkMembers)) {
            data["discountsForNetworkMembers"] = [];
            for (let item of this.discountsForNetworkMembers)
                data["discountsForNetworkMembers"].push(item ? item.toJSON() : <any>undefined);
        }
        return data;
    }
}

export interface ICreateNetworkRequest {
    name?: string | undefined;
    description?: string | undefined;
    vendorId?: string | undefined;
    discountsForNetworkMembers?: CustomerDiscount[] | undefined;
}

export class NetworkResponse implements INetworkResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    network?: Network;

    constructor(data?: INetworkResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ErrorDto.fromJS(item));
            }
            this.isSuccess = _data["isSuccess"];
            this.network = _data["network"] ? Network.fromJS(_data["network"]) : <any>undefined;
        }
    }

    static fromJS(data: any): NetworkResponse {
        data = typeof data === 'object' ? data : {};
        let result = new NetworkResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item ? item.toJSON() : <any>undefined);
        }
        data["isSuccess"] = this.isSuccess;
        data["network"] = this.network ? this.network.toJSON() : <any>undefined;
        return data;
    }
}

export interface INetworkResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    network?: Network;
}

export class AddVendorToNetworkRequest implements IAddVendorToNetworkRequest {
    networkId?: string | undefined;
    vendorId?: string | undefined;
    discountsForNetworkMembers?: CustomerDiscount[] | undefined;

    constructor(data?: IAddVendorToNetworkRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.networkId = _data["networkId"];
            this.vendorId = _data["vendorId"];
            if (Array.isArray(_data["discountsForNetworkMembers"])) {
                this.discountsForNetworkMembers = [] as any;
                for (let item of _data["discountsForNetworkMembers"])
                    this.discountsForNetworkMembers!.push(CustomerDiscount.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AddVendorToNetworkRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AddVendorToNetworkRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["networkId"] = this.networkId;
        data["vendorId"] = this.vendorId;
        if (Array.isArray(this.discountsForNetworkMembers)) {
            data["discountsForNetworkMembers"] = [];
            for (let item of this.discountsForNetworkMembers)
                data["discountsForNetworkMembers"].push(item ? item.toJSON() : <any>undefined);
        }
        return data;
    }
}

export interface IAddVendorToNetworkRequest {
    networkId?: string | undefined;
    vendorId?: string | undefined;
    discountsForNetworkMembers?: CustomerDiscount[] | undefined;
}

export class UpdateVendorMembershipinNetworkRequest implements IUpdateVendorMembershipinNetworkRequest {
    membershipId?: string | undefined;
    discountsForNetworkMembers?: CustomerDiscount[] | undefined;

    constructor(data?: IUpdateVendorMembershipinNetworkRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.membershipId = _data["membershipId"];
            if (Array.isArray(_data["discountsForNetworkMembers"])) {
                this.discountsForNetworkMembers = [] as any;
                for (let item of _data["discountsForNetworkMembers"])
                    this.discountsForNetworkMembers!.push(CustomerDiscount.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateVendorMembershipinNetworkRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateVendorMembershipinNetworkRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["membershipId"] = this.membershipId;
        if (Array.isArray(this.discountsForNetworkMembers)) {
            data["discountsForNetworkMembers"] = [];
            for (let item of this.discountsForNetworkMembers)
                data["discountsForNetworkMembers"].push(item ? item.toJSON() : <any>undefined);
        }
        return data;
    }
}

export interface IUpdateVendorMembershipinNetworkRequest {
    membershipId?: string | undefined;
    discountsForNetworkMembers?: CustomerDiscount[] | undefined;
}

export class VendorNetworkMembership implements IVendorNetworkMembership {
    id?: string | undefined;
    createdDateUtc?: Date;
    lastUpdatedDateUtc?: Date;
    vendorId?: string | undefined;
    networkId?: string | undefined;
    contactName?: string | undefined;
    contactEmail?: string | undefined;
    contactPhone?: string | undefined;
    monthlyCost?: number;
    joinedNetworkDateUtc?: Date;
    businessVisitDiscounts?: CustomerDiscount[] | undefined;
    networkVisitDiscounts?: CustomerDiscount[] | undefined;
    discountsForNetworkMembers?: CustomerDiscount[] | undefined;
    role?: string | undefined;
    geometryLocation?: GeometryLocation;
    googlePlace?: GooglePlacesEntity;
    vendorProfile?: VendorProfile;

    constructor(data?: IVendorNetworkMembership) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdDateUtc = _data["createdDateUtc"] ? new Date(_data["createdDateUtc"].toString()) : <any>undefined;
            this.lastUpdatedDateUtc = _data["lastUpdatedDateUtc"] ? new Date(_data["lastUpdatedDateUtc"].toString()) : <any>undefined;
            this.vendorId = _data["vendorId"];
            this.networkId = _data["networkId"];
            this.contactName = _data["contactName"];
            this.contactEmail = _data["contactEmail"];
            this.contactPhone = _data["contactPhone"];
            this.monthlyCost = _data["monthlyCost"];
            this.joinedNetworkDateUtc = _data["joinedNetworkDateUtc"] ? new Date(_data["joinedNetworkDateUtc"].toString()) : <any>undefined;
            if (Array.isArray(_data["businessVisitDiscounts"])) {
                this.businessVisitDiscounts = [] as any;
                for (let item of _data["businessVisitDiscounts"])
                    this.businessVisitDiscounts!.push(CustomerDiscount.fromJS(item));
            }
            if (Array.isArray(_data["networkVisitDiscounts"])) {
                this.networkVisitDiscounts = [] as any;
                for (let item of _data["networkVisitDiscounts"])
                    this.networkVisitDiscounts!.push(CustomerDiscount.fromJS(item));
            }
            if (Array.isArray(_data["discountsForNetworkMembers"])) {
                this.discountsForNetworkMembers = [] as any;
                for (let item of _data["discountsForNetworkMembers"])
                    this.discountsForNetworkMembers!.push(CustomerDiscount.fromJS(item));
            }
            this.role = _data["role"];
            this.geometryLocation = _data["geometryLocation"] ? GeometryLocation.fromJS(_data["geometryLocation"]) : <any>undefined;
            this.googlePlace = _data["googlePlace"] ? GooglePlacesEntity.fromJS(_data["googlePlace"]) : <any>undefined;
            this.vendorProfile = _data["vendorProfile"] ? VendorProfile.fromJS(_data["vendorProfile"]) : <any>undefined;
        }
    }

    static fromJS(data: any): VendorNetworkMembership {
        data = typeof data === 'object' ? data : {};
        let result = new VendorNetworkMembership();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdDateUtc"] = this.createdDateUtc ? this.createdDateUtc.toISOString() : <any>undefined;
        data["lastUpdatedDateUtc"] = this.lastUpdatedDateUtc ? this.lastUpdatedDateUtc.toISOString() : <any>undefined;
        data["vendorId"] = this.vendorId;
        data["networkId"] = this.networkId;
        data["contactName"] = this.contactName;
        data["contactEmail"] = this.contactEmail;
        data["contactPhone"] = this.contactPhone;
        data["monthlyCost"] = this.monthlyCost;
        data["joinedNetworkDateUtc"] = this.joinedNetworkDateUtc ? this.joinedNetworkDateUtc.toISOString() : <any>undefined;
        if (Array.isArray(this.businessVisitDiscounts)) {
            data["businessVisitDiscounts"] = [];
            for (let item of this.businessVisitDiscounts)
                data["businessVisitDiscounts"].push(item ? item.toJSON() : <any>undefined);
        }
        if (Array.isArray(this.networkVisitDiscounts)) {
            data["networkVisitDiscounts"] = [];
            for (let item of this.networkVisitDiscounts)
                data["networkVisitDiscounts"].push(item ? item.toJSON() : <any>undefined);
        }
        if (Array.isArray(this.discountsForNetworkMembers)) {
            data["discountsForNetworkMembers"] = [];
            for (let item of this.discountsForNetworkMembers)
                data["discountsForNetworkMembers"].push(item ? item.toJSON() : <any>undefined);
        }
        data["role"] = this.role;
        data["geometryLocation"] = this.geometryLocation ? this.geometryLocation.toJSON() : <any>undefined;
        data["googlePlace"] = this.googlePlace ? this.googlePlace.toJSON() : <any>undefined;
        data["vendorProfile"] = this.vendorProfile ? this.vendorProfile.toJSON() : <any>undefined;
        return data;
    }
}

export interface IVendorNetworkMembership {
    id?: string | undefined;
    createdDateUtc?: Date;
    lastUpdatedDateUtc?: Date;
    vendorId?: string | undefined;
    networkId?: string | undefined;
    contactName?: string | undefined;
    contactEmail?: string | undefined;
    contactPhone?: string | undefined;
    monthlyCost?: number;
    joinedNetworkDateUtc?: Date;
    businessVisitDiscounts?: CustomerDiscount[] | undefined;
    networkVisitDiscounts?: CustomerDiscount[] | undefined;
    discountsForNetworkMembers?: CustomerDiscount[] | undefined;
    role?: string | undefined;
    geometryLocation?: GeometryLocation;
    googlePlace?: GooglePlacesEntity;
    vendorProfile?: VendorProfile;
}

export class NetworkWithVendorsResponse implements INetworkWithVendorsResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    network?: Network;
    memberships?: VendorNetworkMembership[] | undefined;

    constructor(data?: INetworkWithVendorsResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ErrorDto.fromJS(item));
            }
            this.isSuccess = _data["isSuccess"];
            this.network = _data["network"] ? Network.fromJS(_data["network"]) : <any>undefined;
            if (Array.isArray(_data["memberships"])) {
                this.memberships = [] as any;
                for (let item of _data["memberships"])
                    this.memberships!.push(VendorNetworkMembership.fromJS(item));
            }
        }
    }

    static fromJS(data: any): NetworkWithVendorsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new NetworkWithVendorsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item ? item.toJSON() : <any>undefined);
        }
        data["isSuccess"] = this.isSuccess;
        data["network"] = this.network ? this.network.toJSON() : <any>undefined;
        if (Array.isArray(this.memberships)) {
            data["memberships"] = [];
            for (let item of this.memberships)
                data["memberships"].push(item ? item.toJSON() : <any>undefined);
        }
        return data;
    }
}

export interface INetworkWithVendorsResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    network?: Network;
    memberships?: VendorNetworkMembership[] | undefined;
}

export class NetworkRequest implements INetworkRequest {
    networkId?: string | undefined;
    vendorNetworkMembershipId?: string | undefined;

    constructor(data?: INetworkRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.networkId = _data["networkId"];
            this.vendorNetworkMembershipId = _data["vendorNetworkMembershipId"];
        }
    }

    static fromJS(data: any): NetworkRequest {
        data = typeof data === 'object' ? data : {};
        let result = new NetworkRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["networkId"] = this.networkId;
        data["vendorNetworkMembershipId"] = this.vendorNetworkMembershipId;
        return data;
    }
}

export interface INetworkRequest {
    networkId?: string | undefined;
    vendorNetworkMembershipId?: string | undefined;
}

export class NetworkInviteRequest implements INetworkInviteRequest {
    networkId?: string | undefined;
    vendorId?: string | undefined;

    constructor(data?: INetworkInviteRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.networkId = _data["networkId"];
            this.vendorId = _data["vendorId"];
        }
    }

    static fromJS(data: any): NetworkInviteRequest {
        data = typeof data === 'object' ? data : {};
        let result = new NetworkInviteRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["networkId"] = this.networkId;
        data["vendorId"] = this.vendorId;
        return data;
    }
}

export interface INetworkInviteRequest {
    networkId?: string | undefined;
    vendorId?: string | undefined;
}

export class VendorNetworkMembershipResponse implements IVendorNetworkMembershipResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    vendorNetworkMembership?: VendorNetworkMembership;

    constructor(data?: IVendorNetworkMembershipResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ErrorDto.fromJS(item));
            }
            this.isSuccess = _data["isSuccess"];
            this.vendorNetworkMembership = _data["vendorNetworkMembership"] ? VendorNetworkMembership.fromJS(_data["vendorNetworkMembership"]) : <any>undefined;
        }
    }

    static fromJS(data: any): VendorNetworkMembershipResponse {
        data = typeof data === 'object' ? data : {};
        let result = new VendorNetworkMembershipResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item ? item.toJSON() : <any>undefined);
        }
        data["isSuccess"] = this.isSuccess;
        data["vendorNetworkMembership"] = this.vendorNetworkMembership ? this.vendorNetworkMembership.toJSON() : <any>undefined;
        return data;
    }
}

export interface IVendorNetworkMembershipResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    vendorNetworkMembership?: VendorNetworkMembership;
}

export class StripeCheckoutRequest implements IStripeCheckoutRequest {
    stripePriceId?: string | undefined;
    planTier?: string | undefined;
    promoCode?: string | undefined;
    vendorProfile?: VendorProfile;
    googlePlace?: GooglePlacesEntity;

    constructor(data?: IStripeCheckoutRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.stripePriceId = _data["stripePriceId"];
            this.planTier = _data["planTier"];
            this.promoCode = _data["promoCode"];
            this.vendorProfile = _data["vendorProfile"] ? VendorProfile.fromJS(_data["vendorProfile"]) : <any>undefined;
            this.googlePlace = _data["googlePlace"] ? GooglePlacesEntity.fromJS(_data["googlePlace"]) : <any>undefined;
        }
    }

    static fromJS(data: any): StripeCheckoutRequest {
        data = typeof data === 'object' ? data : {};
        let result = new StripeCheckoutRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["stripePriceId"] = this.stripePriceId;
        data["planTier"] = this.planTier;
        data["promoCode"] = this.promoCode;
        data["vendorProfile"] = this.vendorProfile ? this.vendorProfile.toJSON() : <any>undefined;
        data["googlePlace"] = this.googlePlace ? this.googlePlace.toJSON() : <any>undefined;
        return data;
    }
}

export interface IStripeCheckoutRequest {
    stripePriceId?: string | undefined;
    planTier?: string | undefined;
    promoCode?: string | undefined;
    vendorProfile?: VendorProfile;
    googlePlace?: GooglePlacesEntity;
}

export class StripeCheckoutResponse implements IStripeCheckoutResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    stripeSessionUrl?: string | undefined;
    isStripeBypassFreeForever?: boolean;

    constructor(data?: IStripeCheckoutResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ErrorDto.fromJS(item));
            }
            this.isSuccess = _data["isSuccess"];
            this.stripeSessionUrl = _data["stripeSessionUrl"];
            this.isStripeBypassFreeForever = _data["isStripeBypassFreeForever"];
        }
    }

    static fromJS(data: any): StripeCheckoutResponse {
        data = typeof data === 'object' ? data : {};
        let result = new StripeCheckoutResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item ? item.toJSON() : <any>undefined);
        }
        data["isSuccess"] = this.isSuccess;
        data["stripeSessionUrl"] = this.stripeSessionUrl;
        data["isStripeBypassFreeForever"] = this.isStripeBypassFreeForever;
        return data;
    }
}

export interface IStripeCheckoutResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    stripeSessionUrl?: string | undefined;
    isStripeBypassFreeForever?: boolean;
}

export class PromoCodeReqeust implements IPromoCodeReqeust {
    promoCode?: string | undefined;

    constructor(data?: IPromoCodeReqeust) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.promoCode = _data["promoCode"];
        }
    }

    static fromJS(data: any): PromoCodeReqeust {
        data = typeof data === 'object' ? data : {};
        let result = new PromoCodeReqeust();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["promoCode"] = this.promoCode;
        return data;
    }
}

export interface IPromoCodeReqeust {
    promoCode?: string | undefined;
}

export class PromotionalDiscount implements IPromotionalDiscount {
    id?: string | undefined;
    createdDateUtc?: Date;
    lastUpdatedDateUtc?: Date;
    promoCode?: string | undefined;
    message?: string | undefined;

    constructor(data?: IPromotionalDiscount) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdDateUtc = _data["createdDateUtc"] ? new Date(_data["createdDateUtc"].toString()) : <any>undefined;
            this.lastUpdatedDateUtc = _data["lastUpdatedDateUtc"] ? new Date(_data["lastUpdatedDateUtc"].toString()) : <any>undefined;
            this.promoCode = _data["promoCode"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): PromotionalDiscount {
        data = typeof data === 'object' ? data : {};
        let result = new PromotionalDiscount();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdDateUtc"] = this.createdDateUtc ? this.createdDateUtc.toISOString() : <any>undefined;
        data["lastUpdatedDateUtc"] = this.lastUpdatedDateUtc ? this.lastUpdatedDateUtc.toISOString() : <any>undefined;
        data["promoCode"] = this.promoCode;
        data["message"] = this.message;
        return data;
    }
}

export interface IPromotionalDiscount {
    id?: string | undefined;
    createdDateUtc?: Date;
    lastUpdatedDateUtc?: Date;
    promoCode?: string | undefined;
    message?: string | undefined;
}

export class PromotionalDiscountResponse implements IPromotionalDiscountResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    promotionalDiscount?: PromotionalDiscount;

    constructor(data?: IPromotionalDiscountResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ErrorDto.fromJS(item));
            }
            this.isSuccess = _data["isSuccess"];
            this.promotionalDiscount = _data["promotionalDiscount"] ? PromotionalDiscount.fromJS(_data["promotionalDiscount"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PromotionalDiscountResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PromotionalDiscountResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item ? item.toJSON() : <any>undefined);
        }
        data["isSuccess"] = this.isSuccess;
        data["promotionalDiscount"] = this.promotionalDiscount ? this.promotionalDiscount.toJSON() : <any>undefined;
        return data;
    }
}

export interface IPromotionalDiscountResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    promotionalDiscount?: PromotionalDiscount;
}

export class CreatePromotionalDiscountRequest implements ICreatePromotionalDiscountRequest {
    message?: string | undefined;

    constructor(data?: ICreatePromotionalDiscountRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): CreatePromotionalDiscountRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePromotionalDiscountRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message;
        return data;
    }
}

export interface ICreatePromotionalDiscountRequest {
    message?: string | undefined;
}

export class ChangeVendorSubscriptionRequest implements IChangeVendorSubscriptionRequest {
    stripePriceId?: string | undefined;
    vendorProfileId?: string | undefined;

    constructor(data?: IChangeVendorSubscriptionRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.stripePriceId = _data["stripePriceId"];
            this.vendorProfileId = _data["vendorProfileId"];
        }
    }

    static fromJS(data: any): ChangeVendorSubscriptionRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeVendorSubscriptionRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["stripePriceId"] = this.stripePriceId;
        data["vendorProfileId"] = this.vendorProfileId;
        return data;
    }
}

export interface IChangeVendorSubscriptionRequest {
    stripePriceId?: string | undefined;
    vendorProfileId?: string | undefined;
}

export class VendorProfileResponse implements IVendorProfileResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    vendorProfile?: VendorProfile;

    constructor(data?: IVendorProfileResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ErrorDto.fromJS(item));
            }
            this.isSuccess = _data["isSuccess"];
            this.vendorProfile = _data["vendorProfile"] ? VendorProfile.fromJS(_data["vendorProfile"]) : <any>undefined;
        }
    }

    static fromJS(data: any): VendorProfileResponse {
        data = typeof data === 'object' ? data : {};
        let result = new VendorProfileResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item ? item.toJSON() : <any>undefined);
        }
        data["isSuccess"] = this.isSuccess;
        data["vendorProfile"] = this.vendorProfile ? this.vendorProfile.toJSON() : <any>undefined;
        return data;
    }
}

export interface IVendorProfileResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    vendorProfile?: VendorProfile;
}

export class VendorProfileCancelRequest implements IVendorProfileCancelRequest {
    vendorProfileId?: string | undefined;

    constructor(data?: IVendorProfileCancelRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.vendorProfileId = _data["vendorProfileId"];
        }
    }

    static fromJS(data: any): VendorProfileCancelRequest {
        data = typeof data === 'object' ? data : {};
        let result = new VendorProfileCancelRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vendorProfileId"] = this.vendorProfileId;
        return data;
    }
}

export interface IVendorProfileCancelRequest {
    vendorProfileId?: string | undefined;
}

export class VendorSubscriptionResponse implements IVendorSubscriptionResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    vendorSubscriptionId?: string | undefined;

    constructor(data?: IVendorSubscriptionResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ErrorDto.fromJS(item));
            }
            this.isSuccess = _data["isSuccess"];
            this.vendorSubscriptionId = _data["vendorSubscriptionId"];
        }
    }

    static fromJS(data: any): VendorSubscriptionResponse {
        data = typeof data === 'object' ? data : {};
        let result = new VendorSubscriptionResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item ? item.toJSON() : <any>undefined);
        }
        data["isSuccess"] = this.isSuccess;
        data["vendorSubscriptionId"] = this.vendorSubscriptionId;
        return data;
    }
}

export interface IVendorSubscriptionResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    vendorSubscriptionId?: string | undefined;
}

export class PostRequest implements IPostRequest {
    postId?: string | undefined;
    post?: Post;

    constructor(data?: IPostRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.postId = _data["postId"];
            this.post = _data["post"] ? Post.fromJS(_data["post"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PostRequest {
        data = typeof data === 'object' ? data : {};
        let result = new PostRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["postId"] = this.postId;
        data["post"] = this.post ? this.post.toJSON() : <any>undefined;
        return data;
    }
}

export interface IPostRequest {
    postId?: string | undefined;
    post?: Post;
}

export class VendorPostRequest implements IVendorPostRequest {
    post?: Post;

    constructor(data?: IVendorPostRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.post = _data["post"] ? Post.fromJS(_data["post"]) : <any>undefined;
        }
    }

    static fromJS(data: any): VendorPostRequest {
        data = typeof data === 'object' ? data : {};
        let result = new VendorPostRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["post"] = this.post ? this.post.toJSON() : <any>undefined;
        return data;
    }
}

export interface IVendorPostRequest {
    post?: Post;
}

export class ReviewsResponse implements IReviewsResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    reviews?: Review[] | undefined;

    constructor(data?: IReviewsResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ErrorDto.fromJS(item));
            }
            this.isSuccess = _data["isSuccess"];
            if (Array.isArray(_data["reviews"])) {
                this.reviews = [] as any;
                for (let item of _data["reviews"])
                    this.reviews!.push(Review.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ReviewsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ReviewsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item ? item.toJSON() : <any>undefined);
        }
        data["isSuccess"] = this.isSuccess;
        if (Array.isArray(this.reviews)) {
            data["reviews"] = [];
            for (let item of this.reviews)
                data["reviews"].push(item ? item.toJSON() : <any>undefined);
        }
        return data;
    }
}

export interface IReviewsResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    reviews?: Review[] | undefined;
}

export class ReviewRequest implements IReviewRequest {
    vendorId?: string | undefined;
    title?: string | undefined;
    body?: string | undefined;
    rating?: number;
    authorId?: string | undefined;

    constructor(data?: IReviewRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.vendorId = _data["vendorId"];
            this.title = _data["title"];
            this.body = _data["body"];
            this.rating = _data["rating"];
            this.authorId = _data["authorId"];
        }
    }

    static fromJS(data: any): ReviewRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ReviewRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vendorId"] = this.vendorId;
        data["title"] = this.title;
        data["body"] = this.body;
        data["rating"] = this.rating;
        data["authorId"] = this.authorId;
        return data;
    }
}

export interface IReviewRequest {
    vendorId?: string | undefined;
    title?: string | undefined;
    body?: string | undefined;
    rating?: number;
    authorId?: string | undefined;
}

export class ReviewResponse implements IReviewResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    review?: Review;

    constructor(data?: IReviewResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ErrorDto.fromJS(item));
            }
            this.isSuccess = _data["isSuccess"];
            this.review = _data["review"] ? Review.fromJS(_data["review"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ReviewResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ReviewResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item ? item.toJSON() : <any>undefined);
        }
        data["isSuccess"] = this.isSuccess;
        data["review"] = this.review ? this.review.toJSON() : <any>undefined;
        return data;
    }
}

export interface IReviewResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    review?: Review;
}

export class ReviewRemoveRequest implements IReviewRemoveRequest {
    reviewId?: string | undefined;
    authorId?: string | undefined;

    constructor(data?: IReviewRemoveRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.reviewId = _data["reviewId"];
            this.authorId = _data["authorId"];
        }
    }

    static fromJS(data: any): ReviewRemoveRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ReviewRemoveRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reviewId"] = this.reviewId;
        data["authorId"] = this.authorId;
        return data;
    }
}

export interface IReviewRemoveRequest {
    reviewId?: string | undefined;
    authorId?: string | undefined;
}

export class ReviewUpdateRequest implements IReviewUpdateRequest {
    reviewId?: string | undefined;
    authorId?: string | undefined;
    body?: string | undefined;
    title?: string | undefined;
    rating?: number;

    constructor(data?: IReviewUpdateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.reviewId = _data["reviewId"];
            this.authorId = _data["authorId"];
            this.body = _data["body"];
            this.title = _data["title"];
            this.rating = _data["rating"];
        }
    }

    static fromJS(data: any): ReviewUpdateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ReviewUpdateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reviewId"] = this.reviewId;
        data["authorId"] = this.authorId;
        data["body"] = this.body;
        data["title"] = this.title;
        data["rating"] = this.rating;
        return data;
    }
}

export interface IReviewUpdateRequest {
    reviewId?: string | undefined;
    authorId?: string | undefined;
    body?: string | undefined;
    title?: string | undefined;
    rating?: number;
}

export class RouteRequest implements IRouteRequest {
    routeId?: string | undefined;

    constructor(data?: IRouteRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.routeId = _data["routeId"];
        }
    }

    static fromJS(data: any): RouteRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RouteRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["routeId"] = this.routeId;
        return data;
    }
}

export interface IRouteRequest {
    routeId?: string | undefined;
}

export class RouteTopUser implements IRouteTopUser {
    visitor?: NeatBoutiqueEntity;
    routeVisits?: number;

    constructor(data?: IRouteTopUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.visitor = _data["visitor"] ? NeatBoutiqueEntity.fromJS(_data["visitor"]) : <any>undefined;
            this.routeVisits = _data["routeVisits"];
        }
    }

    static fromJS(data: any): RouteTopUser {
        data = typeof data === 'object' ? data : {};
        let result = new RouteTopUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["visitor"] = this.visitor ? this.visitor.toJSON() : <any>undefined;
        data["routeVisits"] = this.routeVisits;
        return data;
    }
}

export interface IRouteTopUser {
    visitor?: NeatBoutiqueEntity;
    routeVisits?: number;
}

export class Route implements IRoute {
    id?: string | undefined;
    createdDateUtc?: Date;
    lastUpdatedDateUtc?: Date;
    postId?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    category?: CategoryType;
    startDateUtc?: Date | undefined;
    endDateUtc?: Date | undefined;
    author?: NeatBoutiqueEntity;
    post?: Post;
    routeQuestions?: Post[] | undefined;
    routeTopUsers?: RouteTopUser[] | undefined;

    constructor(data?: IRoute) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdDateUtc = _data["createdDateUtc"] ? new Date(_data["createdDateUtc"].toString()) : <any>undefined;
            this.lastUpdatedDateUtc = _data["lastUpdatedDateUtc"] ? new Date(_data["lastUpdatedDateUtc"].toString()) : <any>undefined;
            this.postId = _data["postId"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.category = _data["category"];
            this.startDateUtc = _data["startDateUtc"] ? new Date(_data["startDateUtc"].toString()) : <any>undefined;
            this.endDateUtc = _data["endDateUtc"] ? new Date(_data["endDateUtc"].toString()) : <any>undefined;
            this.author = _data["author"] ? NeatBoutiqueEntity.fromJS(_data["author"]) : <any>undefined;
            this.post = _data["post"] ? Post.fromJS(_data["post"]) : <any>undefined;
            if (Array.isArray(_data["routeQuestions"])) {
                this.routeQuestions = [] as any;
                for (let item of _data["routeQuestions"])
                    this.routeQuestions!.push(Post.fromJS(item));
            }
            if (Array.isArray(_data["routeTopUsers"])) {
                this.routeTopUsers = [] as any;
                for (let item of _data["routeTopUsers"])
                    this.routeTopUsers!.push(RouteTopUser.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Route {
        data = typeof data === 'object' ? data : {};
        let result = new Route();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdDateUtc"] = this.createdDateUtc ? this.createdDateUtc.toISOString() : <any>undefined;
        data["lastUpdatedDateUtc"] = this.lastUpdatedDateUtc ? this.lastUpdatedDateUtc.toISOString() : <any>undefined;
        data["postId"] = this.postId;
        data["name"] = this.name;
        data["description"] = this.description;
        data["category"] = this.category;
        data["startDateUtc"] = this.startDateUtc ? this.startDateUtc.toISOString() : <any>undefined;
        data["endDateUtc"] = this.endDateUtc ? this.endDateUtc.toISOString() : <any>undefined;
        data["author"] = this.author ? this.author.toJSON() : <any>undefined;
        data["post"] = this.post ? this.post.toJSON() : <any>undefined;
        if (Array.isArray(this.routeQuestions)) {
            data["routeQuestions"] = [];
            for (let item of this.routeQuestions)
                data["routeQuestions"].push(item ? item.toJSON() : <any>undefined);
        }
        if (Array.isArray(this.routeTopUsers)) {
            data["routeTopUsers"] = [];
            for (let item of this.routeTopUsers)
                data["routeTopUsers"].push(item ? item.toJSON() : <any>undefined);
        }
        return data;
    }
}

export interface IRoute {
    id?: string | undefined;
    createdDateUtc?: Date;
    lastUpdatedDateUtc?: Date;
    postId?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    category?: CategoryType;
    startDateUtc?: Date | undefined;
    endDateUtc?: Date | undefined;
    author?: NeatBoutiqueEntity;
    post?: Post;
    routeQuestions?: Post[] | undefined;
    routeTopUsers?: RouteTopUser[] | undefined;
}

export class RouteResponse implements IRouteResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    route?: Route;

    constructor(data?: IRouteResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ErrorDto.fromJS(item));
            }
            this.isSuccess = _data["isSuccess"];
            this.route = _data["route"] ? Route.fromJS(_data["route"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RouteResponse {
        data = typeof data === 'object' ? data : {};
        let result = new RouteResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item ? item.toJSON() : <any>undefined);
        }
        data["isSuccess"] = this.isSuccess;
        data["route"] = this.route ? this.route.toJSON() : <any>undefined;
        return data;
    }
}

export interface IRouteResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    route?: Route;
}

export class RouteSelectionVisit implements IRouteSelectionVisit {
    id?: string | undefined;
    createdDateUtc?: Date;
    lastUpdatedDateUtc?: Date;
    routeId?: string | undefined;
    visitor?: NeatBoutiqueEntity;
    selectionId?: string | undefined;
    visitedDateUtc?: Date;

    constructor(data?: IRouteSelectionVisit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdDateUtc = _data["createdDateUtc"] ? new Date(_data["createdDateUtc"].toString()) : <any>undefined;
            this.lastUpdatedDateUtc = _data["lastUpdatedDateUtc"] ? new Date(_data["lastUpdatedDateUtc"].toString()) : <any>undefined;
            this.routeId = _data["routeId"];
            this.visitor = _data["visitor"] ? NeatBoutiqueEntity.fromJS(_data["visitor"]) : <any>undefined;
            this.selectionId = _data["selectionId"];
            this.visitedDateUtc = _data["visitedDateUtc"] ? new Date(_data["visitedDateUtc"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): RouteSelectionVisit {
        data = typeof data === 'object' ? data : {};
        let result = new RouteSelectionVisit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdDateUtc"] = this.createdDateUtc ? this.createdDateUtc.toISOString() : <any>undefined;
        data["lastUpdatedDateUtc"] = this.lastUpdatedDateUtc ? this.lastUpdatedDateUtc.toISOString() : <any>undefined;
        data["routeId"] = this.routeId;
        data["visitor"] = this.visitor ? this.visitor.toJSON() : <any>undefined;
        data["selectionId"] = this.selectionId;
        data["visitedDateUtc"] = this.visitedDateUtc ? this.visitedDateUtc.toISOString() : <any>undefined;
        return data;
    }
}

export interface IRouteSelectionVisit {
    id?: string | undefined;
    createdDateUtc?: Date;
    lastUpdatedDateUtc?: Date;
    routeId?: string | undefined;
    visitor?: NeatBoutiqueEntity;
    selectionId?: string | undefined;
    visitedDateUtc?: Date;
}

export class MyVisitsResponse implements IMyVisitsResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    myVisits?: RouteSelectionVisit[] | undefined;

    constructor(data?: IMyVisitsResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ErrorDto.fromJS(item));
            }
            this.isSuccess = _data["isSuccess"];
            if (Array.isArray(_data["myVisits"])) {
                this.myVisits = [] as any;
                for (let item of _data["myVisits"])
                    this.myVisits!.push(RouteSelectionVisit.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MyVisitsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new MyVisitsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item ? item.toJSON() : <any>undefined);
        }
        data["isSuccess"] = this.isSuccess;
        if (Array.isArray(this.myVisits)) {
            data["myVisits"] = [];
            for (let item of this.myVisits)
                data["myVisits"].push(item ? item.toJSON() : <any>undefined);
        }
        return data;
    }
}

export interface IMyVisitsResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    myVisits?: RouteSelectionVisit[] | undefined;
}

export class AnswerSearchRequest implements IAnswerSearchRequest {
    searchString?: string | undefined;

    constructor(data?: IAnswerSearchRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.searchString = _data["searchString"];
        }
    }

    static fromJS(data: any): AnswerSearchRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AnswerSearchRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchString"] = this.searchString;
        return data;
    }
}

export interface IAnswerSearchRequest {
    searchString?: string | undefined;
}

export class VendorProfilesResponse implements IVendorProfilesResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    vendorProfiles?: VendorProfile[] | undefined;

    constructor(data?: IVendorProfilesResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ErrorDto.fromJS(item));
            }
            this.isSuccess = _data["isSuccess"];
            if (Array.isArray(_data["vendorProfiles"])) {
                this.vendorProfiles = [] as any;
                for (let item of _data["vendorProfiles"])
                    this.vendorProfiles!.push(VendorProfile.fromJS(item));
            }
        }
    }

    static fromJS(data: any): VendorProfilesResponse {
        data = typeof data === 'object' ? data : {};
        let result = new VendorProfilesResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item ? item.toJSON() : <any>undefined);
        }
        data["isSuccess"] = this.isSuccess;
        if (Array.isArray(this.vendorProfiles)) {
            data["vendorProfiles"] = [];
            for (let item of this.vendorProfiles)
                data["vendorProfiles"].push(item ? item.toJSON() : <any>undefined);
        }
        return data;
    }
}

export interface IVendorProfilesResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    vendorProfiles?: VendorProfile[] | undefined;
}

export class AnswerSearchResponse implements IAnswerSearchResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    vendors?: NeatBoutiqueEntity[] | undefined;
    googlePlaces?: GooglePlacesEntity[] | undefined;

    constructor(data?: IAnswerSearchResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ErrorDto.fromJS(item));
            }
            this.isSuccess = _data["isSuccess"];
            if (Array.isArray(_data["vendors"])) {
                this.vendors = [] as any;
                for (let item of _data["vendors"])
                    this.vendors!.push(NeatBoutiqueEntity.fromJS(item));
            }
            if (Array.isArray(_data["googlePlaces"])) {
                this.googlePlaces = [] as any;
                for (let item of _data["googlePlaces"])
                    this.googlePlaces!.push(GooglePlacesEntity.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AnswerSearchResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AnswerSearchResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item ? item.toJSON() : <any>undefined);
        }
        data["isSuccess"] = this.isSuccess;
        if (Array.isArray(this.vendors)) {
            data["vendors"] = [];
            for (let item of this.vendors)
                data["vendors"].push(item ? item.toJSON() : <any>undefined);
        }
        if (Array.isArray(this.googlePlaces)) {
            data["googlePlaces"] = [];
            for (let item of this.googlePlaces)
                data["googlePlaces"].push(item ? item.toJSON() : <any>undefined);
        }
        return data;
    }
}

export interface IAnswerSearchResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    vendors?: NeatBoutiqueEntity[] | undefined;
    googlePlaces?: GooglePlacesEntity[] | undefined;
}

export class GooglePlacesSearchRequest implements IGooglePlacesSearchRequest {
    searchString?: string | undefined;

    constructor(data?: IGooglePlacesSearchRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.searchString = _data["searchString"];
        }
    }

    static fromJS(data: any): GooglePlacesSearchRequest {
        data = typeof data === 'object' ? data : {};
        let result = new GooglePlacesSearchRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchString"] = this.searchString;
        return data;
    }
}

export interface IGooglePlacesSearchRequest {
    searchString?: string | undefined;
}

export class GooglePlaceSearchResponse implements IGooglePlaceSearchResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    googlePlaces?: GooglePlacesEntity[] | undefined;
    googleSearchSessionToken?: string | undefined;

    constructor(data?: IGooglePlaceSearchResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ErrorDto.fromJS(item));
            }
            this.isSuccess = _data["isSuccess"];
            if (Array.isArray(_data["googlePlaces"])) {
                this.googlePlaces = [] as any;
                for (let item of _data["googlePlaces"])
                    this.googlePlaces!.push(GooglePlacesEntity.fromJS(item));
            }
            this.googleSearchSessionToken = _data["googleSearchSessionToken"];
        }
    }

    static fromJS(data: any): GooglePlaceSearchResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GooglePlaceSearchResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item ? item.toJSON() : <any>undefined);
        }
        data["isSuccess"] = this.isSuccess;
        if (Array.isArray(this.googlePlaces)) {
            data["googlePlaces"] = [];
            for (let item of this.googlePlaces)
                data["googlePlaces"].push(item ? item.toJSON() : <any>undefined);
        }
        data["googleSearchSessionToken"] = this.googleSearchSessionToken;
        return data;
    }
}

export interface IGooglePlaceSearchResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    googlePlaces?: GooglePlacesEntity[] | undefined;
    googleSearchSessionToken?: string | undefined;
}

export class GooglePlaceRequest implements IGooglePlaceRequest {
    googlePlace?: GooglePlacesEntity;
    googleSearchSessionToken?: string | undefined;

    constructor(data?: IGooglePlaceRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.googlePlace = _data["googlePlace"] ? GooglePlacesEntity.fromJS(_data["googlePlace"]) : <any>undefined;
            this.googleSearchSessionToken = _data["googleSearchSessionToken"];
        }
    }

    static fromJS(data: any): GooglePlaceRequest {
        data = typeof data === 'object' ? data : {};
        let result = new GooglePlaceRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["googlePlace"] = this.googlePlace ? this.googlePlace.toJSON() : <any>undefined;
        data["googleSearchSessionToken"] = this.googleSearchSessionToken;
        return data;
    }
}

export interface IGooglePlaceRequest {
    googlePlace?: GooglePlacesEntity;
    googleSearchSessionToken?: string | undefined;
}

export class GooglePlaceDetailsResponse implements IGooglePlaceDetailsResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    name?: string | undefined;
    formattedAddress?: string | undefined;
    phoneNumber?: string | undefined;
    websiteURL?: string | undefined;

    constructor(data?: IGooglePlaceDetailsResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ErrorDto.fromJS(item));
            }
            this.isSuccess = _data["isSuccess"];
            this.name = _data["name"];
            this.formattedAddress = _data["formattedAddress"];
            this.phoneNumber = _data["phoneNumber"];
            this.websiteURL = _data["websiteURL"];
        }
    }

    static fromJS(data: any): GooglePlaceDetailsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GooglePlaceDetailsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item ? item.toJSON() : <any>undefined);
        }
        data["isSuccess"] = this.isSuccess;
        data["name"] = this.name;
        data["formattedAddress"] = this.formattedAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["websiteURL"] = this.websiteURL;
        return data;
    }
}

export interface IGooglePlaceDetailsResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    name?: string | undefined;
    formattedAddress?: string | undefined;
    phoneNumber?: string | undefined;
    websiteURL?: string | undefined;
}

export class NeatBoutiqueSettings implements INeatBoutiqueSettings {
    reCaptchaSecretKey?: string | undefined;
    consumerQuestionsPerVendorPostCount?: number;
    heroAdsPerPage?: number;
    neatBoutiqueFrontEndBaseUrl?: string | undefined;
    neatBoutiqueBackEndBaseUrl?: string | undefined;
    environment?: string | undefined;

    constructor(data?: INeatBoutiqueSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.reCaptchaSecretKey = _data["reCaptchaSecretKey"];
            this.consumerQuestionsPerVendorPostCount = _data["consumerQuestionsPerVendorPostCount"];
            this.heroAdsPerPage = _data["heroAdsPerPage"];
            this.neatBoutiqueFrontEndBaseUrl = _data["neatBoutiqueFrontEndBaseUrl"];
            this.neatBoutiqueBackEndBaseUrl = _data["neatBoutiqueBackEndBaseUrl"];
            this.environment = _data["environment"];
        }
    }

    static fromJS(data: any): NeatBoutiqueSettings {
        data = typeof data === 'object' ? data : {};
        let result = new NeatBoutiqueSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reCaptchaSecretKey"] = this.reCaptchaSecretKey;
        data["consumerQuestionsPerVendorPostCount"] = this.consumerQuestionsPerVendorPostCount;
        data["heroAdsPerPage"] = this.heroAdsPerPage;
        data["neatBoutiqueFrontEndBaseUrl"] = this.neatBoutiqueFrontEndBaseUrl;
        data["neatBoutiqueBackEndBaseUrl"] = this.neatBoutiqueBackEndBaseUrl;
        data["environment"] = this.environment;
        return data;
    }
}

export interface INeatBoutiqueSettings {
    reCaptchaSecretKey?: string | undefined;
    consumerQuestionsPerVendorPostCount?: number;
    heroAdsPerPage?: number;
    neatBoutiqueFrontEndBaseUrl?: string | undefined;
    neatBoutiqueBackEndBaseUrl?: string | undefined;
    environment?: string | undefined;
}

export class GoogleCloudPlatformSettings implements IGoogleCloudPlatformSettings {
    placesKey?: string | undefined;
    storageBucket?: string | undefined;
    storageVendorPhotosFolder?: string | undefined;
    storageVendorLogosFolder?: string | undefined;
    storageConsumerImageFolder?: string | undefined;
    storageBaseURL?: string | undefined;
    storageHeroAdFolder?: string | undefined;

    constructor(data?: IGoogleCloudPlatformSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.placesKey = _data["placesKey"];
            this.storageBucket = _data["storageBucket"];
            this.storageVendorPhotosFolder = _data["storageVendorPhotosFolder"];
            this.storageVendorLogosFolder = _data["storageVendorLogosFolder"];
            this.storageConsumerImageFolder = _data["storageConsumerImageFolder"];
            this.storageBaseURL = _data["storageBaseURL"];
            this.storageHeroAdFolder = _data["storageHeroAdFolder"];
        }
    }

    static fromJS(data: any): GoogleCloudPlatformSettings {
        data = typeof data === 'object' ? data : {};
        let result = new GoogleCloudPlatformSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["placesKey"] = this.placesKey;
        data["storageBucket"] = this.storageBucket;
        data["storageVendorPhotosFolder"] = this.storageVendorPhotosFolder;
        data["storageVendorLogosFolder"] = this.storageVendorLogosFolder;
        data["storageConsumerImageFolder"] = this.storageConsumerImageFolder;
        data["storageBaseURL"] = this.storageBaseURL;
        data["storageHeroAdFolder"] = this.storageHeroAdFolder;
        return data;
    }
}

export interface IGoogleCloudPlatformSettings {
    placesKey?: string | undefined;
    storageBucket?: string | undefined;
    storageVendorPhotosFolder?: string | undefined;
    storageVendorLogosFolder?: string | undefined;
    storageConsumerImageFolder?: string | undefined;
    storageBaseURL?: string | undefined;
    storageHeroAdFolder?: string | undefined;
}

export class MongoDbSettings implements IMongoDbSettings {
    databaseConnectionString?: string | undefined;
    dbName?: string | undefined;
    postsCollectionName?: string | undefined;
    routesCollectionName?: string | undefined;
    routeSelectionVisitsCollectionName?: string | undefined;
    commentsCollectionName?: string | undefined;
    selectionsCollectionName?: string | undefined;
    selectionVotesCollectionName?: string | undefined;
    consumerProfilesCollectionName?: string | undefined;
    vendorProfilesCollectionName?: string | undefined;
    accountsCollectionName?: string | undefined;
    reviewsCollectionName?: string | undefined;
    heroAdsCollectionName?: string | undefined;
    heroAdTemplatesCollectionName?: string | undefined;
    vendorSubscriptionSessionCollectionName?: string | undefined;
    promotionalDiscountsCollectionName?: string | undefined;
    notificationTokensCollectionName?: string | undefined;
    googlePlacesReferencesCollectionName?: string | undefined;
    networksCollectionName?: string | undefined;
    vendorNetworkMembershipsCollectionName?: string | undefined;
    networkInvitesCollectionName?: string | undefined;
    vendorVisitsCollectionName?: string | undefined;

    constructor(data?: IMongoDbSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.databaseConnectionString = _data["databaseConnectionString"];
            this.dbName = _data["dbName"];
            this.postsCollectionName = _data["postsCollectionName"];
            this.routesCollectionName = _data["routesCollectionName"];
            this.routeSelectionVisitsCollectionName = _data["routeSelectionVisitsCollectionName"];
            this.commentsCollectionName = _data["commentsCollectionName"];
            this.selectionsCollectionName = _data["selectionsCollectionName"];
            this.selectionVotesCollectionName = _data["selectionVotesCollectionName"];
            this.consumerProfilesCollectionName = _data["consumerProfilesCollectionName"];
            this.vendorProfilesCollectionName = _data["vendorProfilesCollectionName"];
            this.accountsCollectionName = _data["accountsCollectionName"];
            this.reviewsCollectionName = _data["reviewsCollectionName"];
            this.heroAdsCollectionName = _data["heroAdsCollectionName"];
            this.heroAdTemplatesCollectionName = _data["heroAdTemplatesCollectionName"];
            this.vendorSubscriptionSessionCollectionName = _data["vendorSubscriptionSessionCollectionName"];
            this.promotionalDiscountsCollectionName = _data["promotionalDiscountsCollectionName"];
            this.notificationTokensCollectionName = _data["notificationTokensCollectionName"];
            this.googlePlacesReferencesCollectionName = _data["googlePlacesReferencesCollectionName"];
            this.networksCollectionName = _data["networksCollectionName"];
            this.vendorNetworkMembershipsCollectionName = _data["vendorNetworkMembershipsCollectionName"];
            this.networkInvitesCollectionName = _data["networkInvitesCollectionName"];
            this.vendorVisitsCollectionName = _data["vendorVisitsCollectionName"];
        }
    }

    static fromJS(data: any): MongoDbSettings {
        data = typeof data === 'object' ? data : {};
        let result = new MongoDbSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["databaseConnectionString"] = this.databaseConnectionString;
        data["dbName"] = this.dbName;
        data["postsCollectionName"] = this.postsCollectionName;
        data["routesCollectionName"] = this.routesCollectionName;
        data["routeSelectionVisitsCollectionName"] = this.routeSelectionVisitsCollectionName;
        data["commentsCollectionName"] = this.commentsCollectionName;
        data["selectionsCollectionName"] = this.selectionsCollectionName;
        data["selectionVotesCollectionName"] = this.selectionVotesCollectionName;
        data["consumerProfilesCollectionName"] = this.consumerProfilesCollectionName;
        data["vendorProfilesCollectionName"] = this.vendorProfilesCollectionName;
        data["accountsCollectionName"] = this.accountsCollectionName;
        data["reviewsCollectionName"] = this.reviewsCollectionName;
        data["heroAdsCollectionName"] = this.heroAdsCollectionName;
        data["heroAdTemplatesCollectionName"] = this.heroAdTemplatesCollectionName;
        data["vendorSubscriptionSessionCollectionName"] = this.vendorSubscriptionSessionCollectionName;
        data["promotionalDiscountsCollectionName"] = this.promotionalDiscountsCollectionName;
        data["notificationTokensCollectionName"] = this.notificationTokensCollectionName;
        data["googlePlacesReferencesCollectionName"] = this.googlePlacesReferencesCollectionName;
        data["networksCollectionName"] = this.networksCollectionName;
        data["vendorNetworkMembershipsCollectionName"] = this.vendorNetworkMembershipsCollectionName;
        data["networkInvitesCollectionName"] = this.networkInvitesCollectionName;
        data["vendorVisitsCollectionName"] = this.vendorVisitsCollectionName;
        return data;
    }
}

export interface IMongoDbSettings {
    databaseConnectionString?: string | undefined;
    dbName?: string | undefined;
    postsCollectionName?: string | undefined;
    routesCollectionName?: string | undefined;
    routeSelectionVisitsCollectionName?: string | undefined;
    commentsCollectionName?: string | undefined;
    selectionsCollectionName?: string | undefined;
    selectionVotesCollectionName?: string | undefined;
    consumerProfilesCollectionName?: string | undefined;
    vendorProfilesCollectionName?: string | undefined;
    accountsCollectionName?: string | undefined;
    reviewsCollectionName?: string | undefined;
    heroAdsCollectionName?: string | undefined;
    heroAdTemplatesCollectionName?: string | undefined;
    vendorSubscriptionSessionCollectionName?: string | undefined;
    promotionalDiscountsCollectionName?: string | undefined;
    notificationTokensCollectionName?: string | undefined;
    googlePlacesReferencesCollectionName?: string | undefined;
    networksCollectionName?: string | undefined;
    vendorNetworkMembershipsCollectionName?: string | undefined;
    networkInvitesCollectionName?: string | undefined;
    vendorVisitsCollectionName?: string | undefined;
}

export class StripeSettings implements IStripeSettings {
    publishableKey?: string | undefined;
    secretKey?: string | undefined;
    webHookSecret?: string | undefined;
    couponCode3FreeMonths?: string | undefined;
    couponCode6FreeMonths?: string | undefined;
    couponCodeFreeForever?: string | undefined;
    stripeBypassFreeForeverId?: string | undefined;

    constructor(data?: IStripeSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.publishableKey = _data["publishableKey"];
            this.secretKey = _data["secretKey"];
            this.webHookSecret = _data["webHookSecret"];
            this.couponCode3FreeMonths = _data["couponCode3FreeMonths"];
            this.couponCode6FreeMonths = _data["couponCode6FreeMonths"];
            this.couponCodeFreeForever = _data["couponCodeFreeForever"];
            this.stripeBypassFreeForeverId = _data["stripeBypassFreeForeverId"];
        }
    }

    static fromJS(data: any): StripeSettings {
        data = typeof data === 'object' ? data : {};
        let result = new StripeSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["publishableKey"] = this.publishableKey;
        data["secretKey"] = this.secretKey;
        data["webHookSecret"] = this.webHookSecret;
        data["couponCode3FreeMonths"] = this.couponCode3FreeMonths;
        data["couponCode6FreeMonths"] = this.couponCode6FreeMonths;
        data["couponCodeFreeForever"] = this.couponCodeFreeForever;
        data["stripeBypassFreeForeverId"] = this.stripeBypassFreeForeverId;
        return data;
    }
}

export interface IStripeSettings {
    publishableKey?: string | undefined;
    secretKey?: string | undefined;
    webHookSecret?: string | undefined;
    couponCode3FreeMonths?: string | undefined;
    couponCode6FreeMonths?: string | undefined;
    couponCodeFreeForever?: string | undefined;
    stripeBypassFreeForeverId?: string | undefined;
}

export class Settings implements ISettings {
    neatBoutiqueSettings?: NeatBoutiqueSettings;
    googleCloudPlatformSettings?: GoogleCloudPlatformSettings;
    mongoDbSettings?: MongoDbSettings;
    stripeSettings?: StripeSettings;
    projectId?: string | undefined;

    constructor(data?: ISettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.neatBoutiqueSettings = _data["neatBoutiqueSettings"] ? NeatBoutiqueSettings.fromJS(_data["neatBoutiqueSettings"]) : <any>undefined;
            this.googleCloudPlatformSettings = _data["googleCloudPlatformSettings"] ? GoogleCloudPlatformSettings.fromJS(_data["googleCloudPlatformSettings"]) : <any>undefined;
            this.mongoDbSettings = _data["mongoDbSettings"] ? MongoDbSettings.fromJS(_data["mongoDbSettings"]) : <any>undefined;
            this.stripeSettings = _data["stripeSettings"] ? StripeSettings.fromJS(_data["stripeSettings"]) : <any>undefined;
            this.projectId = _data["projectId"];
        }
    }

    static fromJS(data: any): Settings {
        data = typeof data === 'object' ? data : {};
        let result = new Settings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["neatBoutiqueSettings"] = this.neatBoutiqueSettings ? this.neatBoutiqueSettings.toJSON() : <any>undefined;
        data["googleCloudPlatformSettings"] = this.googleCloudPlatformSettings ? this.googleCloudPlatformSettings.toJSON() : <any>undefined;
        data["mongoDbSettings"] = this.mongoDbSettings ? this.mongoDbSettings.toJSON() : <any>undefined;
        data["stripeSettings"] = this.stripeSettings ? this.stripeSettings.toJSON() : <any>undefined;
        data["projectId"] = this.projectId;
        return data;
    }
}

export interface ISettings {
    neatBoutiqueSettings?: NeatBoutiqueSettings;
    googleCloudPlatformSettings?: GoogleCloudPlatformSettings;
    mongoDbSettings?: MongoDbSettings;
    stripeSettings?: StripeSettings;
    projectId?: string | undefined;
}

export class VendorProfilesRequest implements IVendorProfilesRequest {
    category?: CategoryType;
    pageNumber?: number;
    pageSize?: number;

    constructor(data?: IVendorProfilesRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.category = _data["category"];
            this.pageNumber = _data["pageNumber"];
            this.pageSize = _data["pageSize"];
        }
    }

    static fromJS(data: any): VendorProfilesRequest {
        data = typeof data === 'object' ? data : {};
        let result = new VendorProfilesRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["category"] = this.category;
        data["pageNumber"] = this.pageNumber;
        data["pageSize"] = this.pageSize;
        return data;
    }
}

export interface IVendorProfilesRequest {
    category?: CategoryType;
    pageNumber?: number;
    pageSize?: number;
}

export class VendorProfileWithReviewsResponse implements IVendorProfileWithReviewsResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    vendorProfile?: VendorProfile;
    network?: Network;
    reviews?: Review[] | undefined;

    constructor(data?: IVendorProfileWithReviewsResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ErrorDto.fromJS(item));
            }
            this.isSuccess = _data["isSuccess"];
            this.vendorProfile = _data["vendorProfile"] ? VendorProfile.fromJS(_data["vendorProfile"]) : <any>undefined;
            this.network = _data["network"] ? Network.fromJS(_data["network"]) : <any>undefined;
            if (Array.isArray(_data["reviews"])) {
                this.reviews = [] as any;
                for (let item of _data["reviews"])
                    this.reviews!.push(Review.fromJS(item));
            }
        }
    }

    static fromJS(data: any): VendorProfileWithReviewsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new VendorProfileWithReviewsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item ? item.toJSON() : <any>undefined);
        }
        data["isSuccess"] = this.isSuccess;
        data["vendorProfile"] = this.vendorProfile ? this.vendorProfile.toJSON() : <any>undefined;
        data["network"] = this.network ? this.network.toJSON() : <any>undefined;
        if (Array.isArray(this.reviews)) {
            data["reviews"] = [];
            for (let item of this.reviews)
                data["reviews"].push(item ? item.toJSON() : <any>undefined);
        }
        return data;
    }
}

export interface IVendorProfileWithReviewsResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    vendorProfile?: VendorProfile;
    network?: Network;
    reviews?: Review[] | undefined;
}

export class GetVendorProfileByInfoRequest implements IGetVendorProfileByInfoRequest {
    vendorProfile?: VendorProfile;
    googlePlace?: GooglePlacesEntity;

    constructor(data?: IGetVendorProfileByInfoRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.vendorProfile = _data["vendorProfile"] ? VendorProfile.fromJS(_data["vendorProfile"]) : <any>undefined;
            this.googlePlace = _data["googlePlace"] ? GooglePlacesEntity.fromJS(_data["googlePlace"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetVendorProfileByInfoRequest {
        data = typeof data === 'object' ? data : {};
        let result = new GetVendorProfileByInfoRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vendorProfile"] = this.vendorProfile ? this.vendorProfile.toJSON() : <any>undefined;
        data["googlePlace"] = this.googlePlace ? this.googlePlace.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetVendorProfileByInfoRequest {
    vendorProfile?: VendorProfile;
    googlePlace?: GooglePlacesEntity;
}

export class VendorImageRequest implements IVendorImageRequest {
    vendorId?: string | undefined;
    base64Image?: string | undefined;
    photoPosition?: number;

    constructor(data?: IVendorImageRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.vendorId = _data["vendorId"];
            this.base64Image = _data["base64Image"];
            this.photoPosition = _data["photoPosition"];
        }
    }

    static fromJS(data: any): VendorImageRequest {
        data = typeof data === 'object' ? data : {};
        let result = new VendorImageRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vendorId"] = this.vendorId;
        data["base64Image"] = this.base64Image;
        data["photoPosition"] = this.photoPosition;
        return data;
    }
}

export interface IVendorImageRequest {
    vendorId?: string | undefined;
    base64Image?: string | undefined;
    photoPosition?: number;
}

export class VendorDescriptionRequest implements IVendorDescriptionRequest {
    vendorId?: string | undefined;
    description?: string | undefined;

    constructor(data?: IVendorDescriptionRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.vendorId = _data["vendorId"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): VendorDescriptionRequest {
        data = typeof data === 'object' ? data : {};
        let result = new VendorDescriptionRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vendorId"] = this.vendorId;
        data["description"] = this.description;
        return data;
    }
}

export interface IVendorDescriptionRequest {
    vendorId?: string | undefined;
    description?: string | undefined;
}

export class VendorSocialLinksRequest implements IVendorSocialLinksRequest {
    vendorId?: string | undefined;
    facebookURL?: string | undefined;
    instagramURL?: string | undefined;
    twitterURL?: string | undefined;

    constructor(data?: IVendorSocialLinksRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.vendorId = _data["vendorId"];
            this.facebookURL = _data["facebookURL"];
            this.instagramURL = _data["instagramURL"];
            this.twitterURL = _data["twitterURL"];
        }
    }

    static fromJS(data: any): VendorSocialLinksRequest {
        data = typeof data === 'object' ? data : {};
        let result = new VendorSocialLinksRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vendorId"] = this.vendorId;
        data["facebookURL"] = this.facebookURL;
        data["instagramURL"] = this.instagramURL;
        data["twitterURL"] = this.twitterURL;
        return data;
    }
}

export interface IVendorSocialLinksRequest {
    vendorId?: string | undefined;
    facebookURL?: string | undefined;
    instagramURL?: string | undefined;
    twitterURL?: string | undefined;
}

export class VendorCategoriesRequest implements IVendorCategoriesRequest {
    vendorId?: string | undefined;
    categories?: CategoryType[] | undefined;

    constructor(data?: IVendorCategoriesRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.vendorId = _data["vendorId"];
            if (Array.isArray(_data["categories"])) {
                this.categories = [] as any;
                for (let item of _data["categories"])
                    this.categories!.push(item);
            }
        }
    }

    static fromJS(data: any): VendorCategoriesRequest {
        data = typeof data === 'object' ? data : {};
        let result = new VendorCategoriesRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vendorId"] = this.vendorId;
        if (Array.isArray(this.categories)) {
            data["categories"] = [];
            for (let item of this.categories)
                data["categories"].push(item);
        }
        return data;
    }
}

export interface IVendorCategoriesRequest {
    vendorId?: string | undefined;
    categories?: CategoryType[] | undefined;
}

export class VendorBorderColorRequest implements IVendorBorderColorRequest {
    vendorId?: string | undefined;
    borderColor?: string | undefined;

    constructor(data?: IVendorBorderColorRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.vendorId = _data["vendorId"];
            this.borderColor = _data["borderColor"];
        }
    }

    static fromJS(data: any): VendorBorderColorRequest {
        data = typeof data === 'object' ? data : {};
        let result = new VendorBorderColorRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vendorId"] = this.vendorId;
        data["borderColor"] = this.borderColor;
        return data;
    }
}

export interface IVendorBorderColorRequest {
    vendorId?: string | undefined;
    borderColor?: string | undefined;
}

export class VendorGeneralDiscountsRequest implements IVendorGeneralDiscountsRequest {
    generalDiscounts?: CustomerDiscount[] | undefined;

    constructor(data?: IVendorGeneralDiscountsRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["generalDiscounts"])) {
                this.generalDiscounts = [] as any;
                for (let item of _data["generalDiscounts"])
                    this.generalDiscounts!.push(CustomerDiscount.fromJS(item));
            }
        }
    }

    static fromJS(data: any): VendorGeneralDiscountsRequest {
        data = typeof data === 'object' ? data : {};
        let result = new VendorGeneralDiscountsRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.generalDiscounts)) {
            data["generalDiscounts"] = [];
            for (let item of this.generalDiscounts)
                data["generalDiscounts"].push(item ? item.toJSON() : <any>undefined);
        }
        return data;
    }
}

export interface IVendorGeneralDiscountsRequest {
    generalDiscounts?: CustomerDiscount[] | undefined;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}
// ----- CategoryType enum -----
export enum CategoryType {
    BoutiquesBeauty = "Boutiques & Beauty",
    FoodDrink = "Food & Drink",
    TravelAdventure = "Travel & Adventure",
    NightlifeEntertainment = "Nightlife & Entertainment",
    HealthWellness = "Health & Wellness",
    MaintenanceRepair = "Maintenance & Repair",
    ChurchState = "Church & State",
    ServicesMore = "Services & More",
}
