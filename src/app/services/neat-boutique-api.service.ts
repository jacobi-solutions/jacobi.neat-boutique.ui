/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.6.2.0 (NJsonSchema v10.1.23.0 (Newtonsoft.Json v9.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface INeatBoutiqueApiService {
    /**
     * @param body (optional) 
     * @return Success
     */
    getAccounts(body: Request | undefined): Observable<ProfilesResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    createAccount(body: AccountCreateRequest | undefined): Observable<ProfilesResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    deleteAccountInit(body: AccountDeletionRequest | undefined): Observable<Response>;
    /**
     * @param body (optional) 
     * @return Success
     */
    deleteAccountRollBack(body: AccountDeletionRequest | undefined): Observable<Response>;
    /**
     * @param body (optional) 
     * @return Success
     */
    deleteAccountFinal(body: AccountDeletionRequest | undefined): Observable<Response>;
    /**
     * @param body (optional) 
     * @return Success
     */
    updateEmail(body: Request | undefined): Observable<ProfilesResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    updateUsername(body: Request | undefined): Observable<ProfilesResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    updateAccountNotificationSettings(body: AccountNotificationCategoriesRequest | undefined): Observable<Response>;
    /**
     * @param body (optional) 
     * @return Success
     */
    updateAccountNotificationToken(body: NotificationTokenRequest | undefined): Observable<Response>;
    /**
     * @param body (optional) 
     * @return Success
     */
    updateAccountFeedSettings(body: AccountFeedSettingsRequest | undefined): Observable<Response>;
    /**
     * @param body (optional) 
     * @return Success
     */
    answerQuestionWithVendor(body: AnswerWithVendorRequest | undefined): Observable<ConsumerPostResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    answerQuestionWithGooglePlace(body: AnswerWithGooglePlaceRequest | undefined): Observable<ConsumerPostResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    removeAnswerVoteFromAnswer(body: AnswerVoteRemoveRequest | undefined): Observable<ConsumerPostResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    addCommentToPost(body: CommentRequest | undefined): Observable<CommentResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    removeCommentFromPost(body: CommentRemoveRequest | undefined): Observable<Response>;
    /**
     * @param body (optional) 
     * @return Success
     */
    addLikeToComment(body: CommentLikeAddRequest | undefined): Observable<CommentResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    removeLikeFromComment(body: CommentLikeRemoveRequest | undefined): Observable<CommentResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    updateCommentBodyOnPost(body: CommentUpdateRequest | undefined): Observable<CommentResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    getAllDataForCommunities(body: CommunityRequest | undefined): Observable<CommunityResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    getConsumerPostById(body: ConsumerPostRequest | undefined): Observable<ConsumerPostResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    addVendorToMyPlaces(body: MyPlacesRequest | undefined): Observable<Response>;
    /**
     * @param body (optional) 
     * @return Success
     */
    removeVendorFromMyPlaces(body: MyPlacesRequest | undefined): Observable<Response>;
    /**
     * @param body (optional) 
     * @return Success
     */
    getMyQuestions(body: MyQuestionsRequest | undefined): Observable<ConsumerPostsResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    getConsumerProfileByPath(body: ConsumerProfileRequest | undefined): Observable<ConsumerProfileResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    getRecentActivityByConsumerId(body: ConsumerProfileActivityRequest | undefined): Observable<ConsumerProfileActivityResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    uploadConsumerProfileImage(body: ConsumerImageRequest | undefined): Observable<ConsumerProfileResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    updateConsumerDescription(body: ConsumerDescriptionRequest | undefined): Observable<ConsumerProfileResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    updateConsumerBorderColor(body: ConsumerBorderColorRequest | undefined): Observable<ConsumerProfileResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    updateNotificationSettings(body: ConsumerNotificationSettingsRequest | undefined): Observable<ConsumerProfileResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    updateFeedSettings(body: ConsumerFeedSettingsRequest | undefined): Observable<ConsumerProfileResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    sendContactUs(body: ContactUsRequest | undefined): Observable<Response>;
    /**
     * @param body (optional) 
     * @return Success
     */
    getHeroAdTemplatesForVendor(body: VendorProfileRequest | undefined): Observable<HeroAdTemplatesResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    createHeroAdForVendor(body: CreateHeroAdRequest | undefined): Observable<Response>;
    /**
     * @param body (optional) 
     * @return Success
     */
    createStripeCheckout(body: StripeCheckoutRequest | undefined): Observable<StripeCheckoutResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    applyPromoCode(body: PromoCodeReqeust | undefined): Observable<PromotionalDiscountResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    create3MonthsFreePromotionalDiscount(body: CreatePromotionalDiscountRequest | undefined): Observable<PromotionalDiscountResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    create6MonthsFreePromotionalDiscount(body: CreatePromotionalDiscountRequest | undefined): Observable<PromotionalDiscountResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    createFreeForeverPromotionalDiscount(body: CreatePromotionalDiscountRequest | undefined): Observable<PromotionalDiscountResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    changeVendorSubscriptionToPremium(body: ChangeVendorSubscriptionRequest | undefined): Observable<VendorProfileResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    cancelVendorSubscription(body: VendorProfileCancelRequest | undefined): Observable<VendorProfileResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    changeVendorSubscriptionToStandard(body: ChangeVendorSubscriptionRequest | undefined): Observable<VendorProfileResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    addVendorSubscriptionToAccount(body: StripeCheckoutRequest | undefined): Observable<VendorProfileResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    getVendorSubscriptionId(body: Request | undefined): Observable<VendorSubscriptionResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    createConsumerPost(body: ConsumerPostRequest | undefined): Observable<ConsumerPostResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    createVendorPost(body: VendorPostRequest | undefined): Observable<VendorPostResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    addVoteToPollAnswer(body: PollAnswerRequest | undefined): Observable<PollAnswerResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    removeVoteFromPollAnswer(body: PollAnswerRequest | undefined): Observable<PollAnswerResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    getSampleOfReviews(body: Request | undefined): Observable<ReviewsResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    addReviewToVendor(body: ReviewRequest | undefined): Observable<ReviewResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    removeReviewFromVendor(body: ReviewRemoveRequest | undefined): Observable<Response>;
    /**
     * @param body (optional) 
     * @return Success
     */
    updateReviewOnVendor(body: ReviewUpdateRequest | undefined): Observable<ReviewResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    autocompleteSearchForAnswer(body: AnswerSearchRequest | undefined): Observable<AnswerSearchResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    autocompleteSearchForGooglePlace(body: GooglePlacesSearchRequest | undefined): Observable<GooglePlaceSearchResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    getGooglePlaceDetails(body: GooglePlaceRequest | undefined): Observable<GooglePlaceDetailsResponse>;
    /**
     * @return Success
     */
    changeAnswers(): Observable<Response>;
    /**
     * @return Success
     */
    setVendorProfilePath(): Observable<Response>;
    /**
     * @return Success
     */
    changeVendorPhotos(): Observable<Response>;
    /**
     * @return Success
     */
    updateConsumerProfilesSeedData(): Observable<Response>;
    /**
     * @return Success
     */
    updateConsumerProfilesPathsSeedData(): Observable<Response>;
    /**
     * @return Success
     */
    updateVendorProfilesSeedData(): Observable<Response>;
    /**
     * @return Success
     */
    addHeroAdTemplatesSeedData(): Observable<Response>;
    /**
     * @param body (optional) 
     * @return Success
     */
    getSettings(body: Request | undefined): Observable<Settings>;
    /**
     * @return Success
     */
    stripeWebHook(): Observable<void>;
    /**
     * @return Success
     */
    cancelSession(id: string | null): Observable<void>;
    /**
     * @param body (optional) 
     * @return Success
     */
    getVendorsByCommunityName(body: VendorProfilesRequest | undefined): Observable<VendorProfilesResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    getSampleOfVendors(body: Request | undefined): Observable<VendorProfilesResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    getVendorProfileWithReviewsById(body: VendorProfileRequest | undefined): Observable<VendorProfileWithReviewsResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    getVendorProfileWithReviewsByPath(body: VendorProfileRequest | undefined): Observable<VendorProfileWithReviewsResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    getVendorProfileByVendorInfo(body: GetVendorProfileByInfoRequest | undefined): Observable<VendorProfileResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    getVendorProfilesForMyPlaces(body: Request | undefined): Observable<VendorProfilesResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    uploadVendorPhoto(body: VendorImageRequest | undefined): Observable<VendorProfileResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    uploadVendorLogo(body: VendorImageRequest | undefined): Observable<VendorProfileResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    updateVendorDescription(body: VendorDescriptionRequest | undefined): Observable<VendorProfileResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    updateSocialLinks(body: VendorSocialLinksRequest | undefined): Observable<VendorProfileResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    updateCommunities(body: VendorCommunitiesRequest | undefined): Observable<VendorProfileResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    updateVendorBorderColor(body: VendorBorderColorRequest | undefined): Observable<VendorProfileResponse>;
}

@Injectable()
export class NeatBoutiqueApiService implements INeatBoutiqueApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getAccounts(body: Request | undefined): Observable<ProfilesResponse> {
        let url_ = this.baseUrl + "/Accounts/GetAccountsAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAccounts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAccounts(<any>response_);
                } catch (e) {
                    return <Observable<ProfilesResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProfilesResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetAccounts(response: HttpResponseBase): Observable<ProfilesResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProfilesResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProfilesResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createAccount(body: AccountCreateRequest | undefined): Observable<ProfilesResponse> {
        let url_ = this.baseUrl + "/Accounts/CreateAccountAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateAccount(<any>response_);
                } catch (e) {
                    return <Observable<ProfilesResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProfilesResponse>><any>_observableThrow(response_);
        }));
    }

    protected processCreateAccount(response: HttpResponseBase): Observable<ProfilesResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProfilesResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProfilesResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deleteAccountInit(body: AccountDeletionRequest | undefined): Observable<Response> {
        let url_ = this.baseUrl + "/Accounts/DeleteAccountInitAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAccountInit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAccountInit(<any>response_);
                } catch (e) {
                    return <Observable<Response>><any>_observableThrow(e);
                }
            } else
                return <Observable<Response>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteAccountInit(response: HttpResponseBase): Observable<Response> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Response.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Response>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deleteAccountRollBack(body: AccountDeletionRequest | undefined): Observable<Response> {
        let url_ = this.baseUrl + "/Accounts/DeleteAccountRollBackAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAccountRollBack(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAccountRollBack(<any>response_);
                } catch (e) {
                    return <Observable<Response>><any>_observableThrow(e);
                }
            } else
                return <Observable<Response>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteAccountRollBack(response: HttpResponseBase): Observable<Response> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Response.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Response>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deleteAccountFinal(body: AccountDeletionRequest | undefined): Observable<Response> {
        let url_ = this.baseUrl + "/Accounts/DeleteAccountFinalAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAccountFinal(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAccountFinal(<any>response_);
                } catch (e) {
                    return <Observable<Response>><any>_observableThrow(e);
                }
            } else
                return <Observable<Response>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteAccountFinal(response: HttpResponseBase): Observable<Response> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Response.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Response>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateEmail(body: Request | undefined): Observable<ProfilesResponse> {
        let url_ = this.baseUrl + "/Accounts/UpdateEmailAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateEmail(<any>response_);
                } catch (e) {
                    return <Observable<ProfilesResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProfilesResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateEmail(response: HttpResponseBase): Observable<ProfilesResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProfilesResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProfilesResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateUsername(body: Request | undefined): Observable<ProfilesResponse> {
        let url_ = this.baseUrl + "/Accounts/UpdateUsernameAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUsername(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUsername(<any>response_);
                } catch (e) {
                    return <Observable<ProfilesResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProfilesResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUsername(response: HttpResponseBase): Observable<ProfilesResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProfilesResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProfilesResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateAccountNotificationSettings(body: AccountNotificationCategoriesRequest | undefined): Observable<Response> {
        let url_ = this.baseUrl + "/Accounts/UpdateAccountNotificationSettingsAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAccountNotificationSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAccountNotificationSettings(<any>response_);
                } catch (e) {
                    return <Observable<Response>><any>_observableThrow(e);
                }
            } else
                return <Observable<Response>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAccountNotificationSettings(response: HttpResponseBase): Observable<Response> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Response.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Response>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateAccountNotificationToken(body: NotificationTokenRequest | undefined): Observable<Response> {
        let url_ = this.baseUrl + "/Accounts/UpdateAccountNotificationTokenAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAccountNotificationToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAccountNotificationToken(<any>response_);
                } catch (e) {
                    return <Observable<Response>><any>_observableThrow(e);
                }
            } else
                return <Observable<Response>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAccountNotificationToken(response: HttpResponseBase): Observable<Response> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Response.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Response>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateAccountFeedSettings(body: AccountFeedSettingsRequest | undefined): Observable<Response> {
        let url_ = this.baseUrl + "/Accounts/UpdateAccountFeedSettingsAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAccountFeedSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAccountFeedSettings(<any>response_);
                } catch (e) {
                    return <Observable<Response>><any>_observableThrow(e);
                }
            } else
                return <Observable<Response>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAccountFeedSettings(response: HttpResponseBase): Observable<Response> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Response.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Response>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    answerQuestionWithVendor(body: AnswerWithVendorRequest | undefined): Observable<ConsumerPostResponse> {
        let url_ = this.baseUrl + "/Answers/AnswerQuestionWithVendorAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAnswerQuestionWithVendor(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAnswerQuestionWithVendor(<any>response_);
                } catch (e) {
                    return <Observable<ConsumerPostResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ConsumerPostResponse>><any>_observableThrow(response_);
        }));
    }

    protected processAnswerQuestionWithVendor(response: HttpResponseBase): Observable<ConsumerPostResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ConsumerPostResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ConsumerPostResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    answerQuestionWithGooglePlace(body: AnswerWithGooglePlaceRequest | undefined): Observable<ConsumerPostResponse> {
        let url_ = this.baseUrl + "/Answers/AnswerQuestionWithGooglePlaceAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAnswerQuestionWithGooglePlace(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAnswerQuestionWithGooglePlace(<any>response_);
                } catch (e) {
                    return <Observable<ConsumerPostResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ConsumerPostResponse>><any>_observableThrow(response_);
        }));
    }

    protected processAnswerQuestionWithGooglePlace(response: HttpResponseBase): Observable<ConsumerPostResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ConsumerPostResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ConsumerPostResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    removeAnswerVoteFromAnswer(body: AnswerVoteRemoveRequest | undefined): Observable<ConsumerPostResponse> {
        let url_ = this.baseUrl + "/Answers/RemoveAnswerVoteFromAnswerAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveAnswerVoteFromAnswer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveAnswerVoteFromAnswer(<any>response_);
                } catch (e) {
                    return <Observable<ConsumerPostResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ConsumerPostResponse>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveAnswerVoteFromAnswer(response: HttpResponseBase): Observable<ConsumerPostResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ConsumerPostResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ConsumerPostResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addCommentToPost(body: CommentRequest | undefined): Observable<CommentResponse> {
        let url_ = this.baseUrl + "/Comments/AddCommentToPostAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddCommentToPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddCommentToPost(<any>response_);
                } catch (e) {
                    return <Observable<CommentResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommentResponse>><any>_observableThrow(response_);
        }));
    }

    protected processAddCommentToPost(response: HttpResponseBase): Observable<CommentResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommentResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommentResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    removeCommentFromPost(body: CommentRemoveRequest | undefined): Observable<Response> {
        let url_ = this.baseUrl + "/Comments/RemoveCommentFromPostAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveCommentFromPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveCommentFromPost(<any>response_);
                } catch (e) {
                    return <Observable<Response>><any>_observableThrow(e);
                }
            } else
                return <Observable<Response>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveCommentFromPost(response: HttpResponseBase): Observable<Response> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Response.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Response>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addLikeToComment(body: CommentLikeAddRequest | undefined): Observable<CommentResponse> {
        let url_ = this.baseUrl + "/Comments/AddLikeToCommentAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddLikeToComment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddLikeToComment(<any>response_);
                } catch (e) {
                    return <Observable<CommentResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommentResponse>><any>_observableThrow(response_);
        }));
    }

    protected processAddLikeToComment(response: HttpResponseBase): Observable<CommentResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommentResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommentResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    removeLikeFromComment(body: CommentLikeRemoveRequest | undefined): Observable<CommentResponse> {
        let url_ = this.baseUrl + "/Comments/RemoveLikeFromCommentAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveLikeFromComment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveLikeFromComment(<any>response_);
                } catch (e) {
                    return <Observable<CommentResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommentResponse>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveLikeFromComment(response: HttpResponseBase): Observable<CommentResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommentResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommentResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateCommentBodyOnPost(body: CommentUpdateRequest | undefined): Observable<CommentResponse> {
        let url_ = this.baseUrl + "/Comments/UpdateCommentBodyOnPostAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCommentBodyOnPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCommentBodyOnPost(<any>response_);
                } catch (e) {
                    return <Observable<CommentResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommentResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateCommentBodyOnPost(response: HttpResponseBase): Observable<CommentResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommentResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommentResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getAllDataForCommunities(body: CommunityRequest | undefined): Observable<CommunityResponse> {
        let url_ = this.baseUrl + "/Community/GetAllDataForCommunitiesAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDataForCommunities(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDataForCommunities(<any>response_);
                } catch (e) {
                    return <Observable<CommunityResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommunityResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllDataForCommunities(response: HttpResponseBase): Observable<CommunityResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommunityResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommunityResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getConsumerPostById(body: ConsumerPostRequest | undefined): Observable<ConsumerPostResponse> {
        let url_ = this.baseUrl + "/Community/GetConsumerPostByIdAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetConsumerPostById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetConsumerPostById(<any>response_);
                } catch (e) {
                    return <Observable<ConsumerPostResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ConsumerPostResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetConsumerPostById(response: HttpResponseBase): Observable<ConsumerPostResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ConsumerPostResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ConsumerPostResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addVendorToMyPlaces(body: MyPlacesRequest | undefined): Observable<Response> {
        let url_ = this.baseUrl + "/Consumers/AddVendorToMyPlacesAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddVendorToMyPlaces(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddVendorToMyPlaces(<any>response_);
                } catch (e) {
                    return <Observable<Response>><any>_observableThrow(e);
                }
            } else
                return <Observable<Response>><any>_observableThrow(response_);
        }));
    }

    protected processAddVendorToMyPlaces(response: HttpResponseBase): Observable<Response> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Response.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Response>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    removeVendorFromMyPlaces(body: MyPlacesRequest | undefined): Observable<Response> {
        let url_ = this.baseUrl + "/Consumers/RemoveVendorFromMyPlacesAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveVendorFromMyPlaces(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveVendorFromMyPlaces(<any>response_);
                } catch (e) {
                    return <Observable<Response>><any>_observableThrow(e);
                }
            } else
                return <Observable<Response>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveVendorFromMyPlaces(response: HttpResponseBase): Observable<Response> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Response.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Response>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getMyQuestions(body: MyQuestionsRequest | undefined): Observable<ConsumerPostsResponse> {
        let url_ = this.baseUrl + "/Consumers/GetMyQuestionsAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMyQuestions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMyQuestions(<any>response_);
                } catch (e) {
                    return <Observable<ConsumerPostsResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ConsumerPostsResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetMyQuestions(response: HttpResponseBase): Observable<ConsumerPostsResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ConsumerPostsResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ConsumerPostsResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getConsumerProfileByPath(body: ConsumerProfileRequest | undefined): Observable<ConsumerProfileResponse> {
        let url_ = this.baseUrl + "/Consumers/GetConsumerProfileByPathAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetConsumerProfileByPath(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetConsumerProfileByPath(<any>response_);
                } catch (e) {
                    return <Observable<ConsumerProfileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ConsumerProfileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetConsumerProfileByPath(response: HttpResponseBase): Observable<ConsumerProfileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ConsumerProfileResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ConsumerProfileResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getRecentActivityByConsumerId(body: ConsumerProfileActivityRequest | undefined): Observable<ConsumerProfileActivityResponse> {
        let url_ = this.baseUrl + "/Consumers/GetRecentActivityByConsumerIdAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecentActivityByConsumerId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecentActivityByConsumerId(<any>response_);
                } catch (e) {
                    return <Observable<ConsumerProfileActivityResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ConsumerProfileActivityResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetRecentActivityByConsumerId(response: HttpResponseBase): Observable<ConsumerProfileActivityResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ConsumerProfileActivityResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ConsumerProfileActivityResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    uploadConsumerProfileImage(body: ConsumerImageRequest | undefined): Observable<ConsumerProfileResponse> {
        let url_ = this.baseUrl + "/Consumers/UploadConsumerProfileImageAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadConsumerProfileImage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadConsumerProfileImage(<any>response_);
                } catch (e) {
                    return <Observable<ConsumerProfileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ConsumerProfileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUploadConsumerProfileImage(response: HttpResponseBase): Observable<ConsumerProfileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ConsumerProfileResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ConsumerProfileResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateConsumerDescription(body: ConsumerDescriptionRequest | undefined): Observable<ConsumerProfileResponse> {
        let url_ = this.baseUrl + "/Consumers/UpdateConsumerDescriptionAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateConsumerDescription(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateConsumerDescription(<any>response_);
                } catch (e) {
                    return <Observable<ConsumerProfileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ConsumerProfileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateConsumerDescription(response: HttpResponseBase): Observable<ConsumerProfileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ConsumerProfileResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ConsumerProfileResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateConsumerBorderColor(body: ConsumerBorderColorRequest | undefined): Observable<ConsumerProfileResponse> {
        let url_ = this.baseUrl + "/Consumers/UpdateConsumerBorderColorAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateConsumerBorderColor(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateConsumerBorderColor(<any>response_);
                } catch (e) {
                    return <Observable<ConsumerProfileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ConsumerProfileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateConsumerBorderColor(response: HttpResponseBase): Observable<ConsumerProfileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ConsumerProfileResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ConsumerProfileResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateNotificationSettings(body: ConsumerNotificationSettingsRequest | undefined): Observable<ConsumerProfileResponse> {
        let url_ = this.baseUrl + "/Consumers/UpdateNotificationSettingsAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateNotificationSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateNotificationSettings(<any>response_);
                } catch (e) {
                    return <Observable<ConsumerProfileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ConsumerProfileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateNotificationSettings(response: HttpResponseBase): Observable<ConsumerProfileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ConsumerProfileResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ConsumerProfileResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateFeedSettings(body: ConsumerFeedSettingsRequest | undefined): Observable<ConsumerProfileResponse> {
        let url_ = this.baseUrl + "/Consumers/UpdateFeedSettingsAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateFeedSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateFeedSettings(<any>response_);
                } catch (e) {
                    return <Observable<ConsumerProfileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ConsumerProfileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateFeedSettings(response: HttpResponseBase): Observable<ConsumerProfileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ConsumerProfileResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ConsumerProfileResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendContactUs(body: ContactUsRequest | undefined): Observable<Response> {
        let url_ = this.baseUrl + "/Email/SendContactUsAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendContactUs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendContactUs(<any>response_);
                } catch (e) {
                    return <Observable<Response>><any>_observableThrow(e);
                }
            } else
                return <Observable<Response>><any>_observableThrow(response_);
        }));
    }

    protected processSendContactUs(response: HttpResponseBase): Observable<Response> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Response.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Response>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getHeroAdTemplatesForVendor(body: VendorProfileRequest | undefined): Observable<HeroAdTemplatesResponse> {
        let url_ = this.baseUrl + "/HeroAd/GetHeroAdTemplatesForVendorAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHeroAdTemplatesForVendor(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHeroAdTemplatesForVendor(<any>response_);
                } catch (e) {
                    return <Observable<HeroAdTemplatesResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<HeroAdTemplatesResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetHeroAdTemplatesForVendor(response: HttpResponseBase): Observable<HeroAdTemplatesResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HeroAdTemplatesResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HeroAdTemplatesResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createHeroAdForVendor(body: CreateHeroAdRequest | undefined): Observable<Response> {
        let url_ = this.baseUrl + "/HeroAd/CreateHeroAdForVendorAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateHeroAdForVendor(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateHeroAdForVendor(<any>response_);
                } catch (e) {
                    return <Observable<Response>><any>_observableThrow(e);
                }
            } else
                return <Observable<Response>><any>_observableThrow(response_);
        }));
    }

    protected processCreateHeroAdForVendor(response: HttpResponseBase): Observable<Response> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Response.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Response>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createStripeCheckout(body: StripeCheckoutRequest | undefined): Observable<StripeCheckoutResponse> {
        let url_ = this.baseUrl + "/Payments/CreateStripeCheckoutAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateStripeCheckout(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateStripeCheckout(<any>response_);
                } catch (e) {
                    return <Observable<StripeCheckoutResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<StripeCheckoutResponse>><any>_observableThrow(response_);
        }));
    }

    protected processCreateStripeCheckout(response: HttpResponseBase): Observable<StripeCheckoutResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StripeCheckoutResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StripeCheckoutResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    applyPromoCode(body: PromoCodeReqeust | undefined): Observable<PromotionalDiscountResponse> {
        let url_ = this.baseUrl + "/Payments/ApplyPromoCodeAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApplyPromoCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApplyPromoCode(<any>response_);
                } catch (e) {
                    return <Observable<PromotionalDiscountResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<PromotionalDiscountResponse>><any>_observableThrow(response_);
        }));
    }

    protected processApplyPromoCode(response: HttpResponseBase): Observable<PromotionalDiscountResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PromotionalDiscountResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PromotionalDiscountResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create3MonthsFreePromotionalDiscount(body: CreatePromotionalDiscountRequest | undefined): Observable<PromotionalDiscountResponse> {
        let url_ = this.baseUrl + "/Payments/Create3MonthsFreePromotionalDiscountAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate3MonthsFreePromotionalDiscount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate3MonthsFreePromotionalDiscount(<any>response_);
                } catch (e) {
                    return <Observable<PromotionalDiscountResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<PromotionalDiscountResponse>><any>_observableThrow(response_);
        }));
    }

    protected processCreate3MonthsFreePromotionalDiscount(response: HttpResponseBase): Observable<PromotionalDiscountResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PromotionalDiscountResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PromotionalDiscountResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create6MonthsFreePromotionalDiscount(body: CreatePromotionalDiscountRequest | undefined): Observable<PromotionalDiscountResponse> {
        let url_ = this.baseUrl + "/Payments/Create6MonthsFreePromotionalDiscountAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate6MonthsFreePromotionalDiscount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate6MonthsFreePromotionalDiscount(<any>response_);
                } catch (e) {
                    return <Observable<PromotionalDiscountResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<PromotionalDiscountResponse>><any>_observableThrow(response_);
        }));
    }

    protected processCreate6MonthsFreePromotionalDiscount(response: HttpResponseBase): Observable<PromotionalDiscountResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PromotionalDiscountResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PromotionalDiscountResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createFreeForeverPromotionalDiscount(body: CreatePromotionalDiscountRequest | undefined): Observable<PromotionalDiscountResponse> {
        let url_ = this.baseUrl + "/Payments/CreateFreeForeverPromotionalDiscountAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateFreeForeverPromotionalDiscount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateFreeForeverPromotionalDiscount(<any>response_);
                } catch (e) {
                    return <Observable<PromotionalDiscountResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<PromotionalDiscountResponse>><any>_observableThrow(response_);
        }));
    }

    protected processCreateFreeForeverPromotionalDiscount(response: HttpResponseBase): Observable<PromotionalDiscountResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PromotionalDiscountResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PromotionalDiscountResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changeVendorSubscriptionToPremium(body: ChangeVendorSubscriptionRequest | undefined): Observable<VendorProfileResponse> {
        let url_ = this.baseUrl + "/Payments/ChangeVendorSubscriptionToPremiumAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeVendorSubscriptionToPremium(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeVendorSubscriptionToPremium(<any>response_);
                } catch (e) {
                    return <Observable<VendorProfileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<VendorProfileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processChangeVendorSubscriptionToPremium(response: HttpResponseBase): Observable<VendorProfileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VendorProfileResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VendorProfileResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cancelVendorSubscription(body: VendorProfileCancelRequest | undefined): Observable<VendorProfileResponse> {
        let url_ = this.baseUrl + "/Payments/CancelVendorSubscriptionAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancelVendorSubscription(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancelVendorSubscription(<any>response_);
                } catch (e) {
                    return <Observable<VendorProfileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<VendorProfileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processCancelVendorSubscription(response: HttpResponseBase): Observable<VendorProfileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VendorProfileResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VendorProfileResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changeVendorSubscriptionToStandard(body: ChangeVendorSubscriptionRequest | undefined): Observable<VendorProfileResponse> {
        let url_ = this.baseUrl + "/Payments/ChangeVendorSubscriptionToStandardAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeVendorSubscriptionToStandard(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeVendorSubscriptionToStandard(<any>response_);
                } catch (e) {
                    return <Observable<VendorProfileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<VendorProfileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processChangeVendorSubscriptionToStandard(response: HttpResponseBase): Observable<VendorProfileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VendorProfileResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VendorProfileResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addVendorSubscriptionToAccount(body: StripeCheckoutRequest | undefined): Observable<VendorProfileResponse> {
        let url_ = this.baseUrl + "/Payments/AddVendorSubscriptionToAccountAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddVendorSubscriptionToAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddVendorSubscriptionToAccount(<any>response_);
                } catch (e) {
                    return <Observable<VendorProfileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<VendorProfileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processAddVendorSubscriptionToAccount(response: HttpResponseBase): Observable<VendorProfileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VendorProfileResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VendorProfileResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getVendorSubscriptionId(body: Request | undefined): Observable<VendorSubscriptionResponse> {
        let url_ = this.baseUrl + "/Payments/GetVendorSubscriptionIdAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVendorSubscriptionId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVendorSubscriptionId(<any>response_);
                } catch (e) {
                    return <Observable<VendorSubscriptionResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<VendorSubscriptionResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetVendorSubscriptionId(response: HttpResponseBase): Observable<VendorSubscriptionResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VendorSubscriptionResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VendorSubscriptionResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createConsumerPost(body: ConsumerPostRequest | undefined): Observable<ConsumerPostResponse> {
        let url_ = this.baseUrl + "/Posts/CreateConsumerPostAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateConsumerPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateConsumerPost(<any>response_);
                } catch (e) {
                    return <Observable<ConsumerPostResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ConsumerPostResponse>><any>_observableThrow(response_);
        }));
    }

    protected processCreateConsumerPost(response: HttpResponseBase): Observable<ConsumerPostResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ConsumerPostResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ConsumerPostResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createVendorPost(body: VendorPostRequest | undefined): Observable<VendorPostResponse> {
        let url_ = this.baseUrl + "/Posts/CreateVendorPostAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateVendorPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateVendorPost(<any>response_);
                } catch (e) {
                    return <Observable<VendorPostResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<VendorPostResponse>><any>_observableThrow(response_);
        }));
    }

    protected processCreateVendorPost(response: HttpResponseBase): Observable<VendorPostResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VendorPostResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VendorPostResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addVoteToPollAnswer(body: PollAnswerRequest | undefined): Observable<PollAnswerResponse> {
        let url_ = this.baseUrl + "/Posts/AddVoteToPollAnswerAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddVoteToPollAnswer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddVoteToPollAnswer(<any>response_);
                } catch (e) {
                    return <Observable<PollAnswerResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<PollAnswerResponse>><any>_observableThrow(response_);
        }));
    }

    protected processAddVoteToPollAnswer(response: HttpResponseBase): Observable<PollAnswerResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PollAnswerResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PollAnswerResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    removeVoteFromPollAnswer(body: PollAnswerRequest | undefined): Observable<PollAnswerResponse> {
        let url_ = this.baseUrl + "/Posts/RemoveVoteFromPollAnswerAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveVoteFromPollAnswer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveVoteFromPollAnswer(<any>response_);
                } catch (e) {
                    return <Observable<PollAnswerResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<PollAnswerResponse>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveVoteFromPollAnswer(response: HttpResponseBase): Observable<PollAnswerResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PollAnswerResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PollAnswerResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getSampleOfReviews(body: Request | undefined): Observable<ReviewsResponse> {
        let url_ = this.baseUrl + "/Reviews/GetSampleOfReviewsAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSampleOfReviews(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSampleOfReviews(<any>response_);
                } catch (e) {
                    return <Observable<ReviewsResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ReviewsResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetSampleOfReviews(response: HttpResponseBase): Observable<ReviewsResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReviewsResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReviewsResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addReviewToVendor(body: ReviewRequest | undefined): Observable<ReviewResponse> {
        let url_ = this.baseUrl + "/Reviews/AddReviewToVendorAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddReviewToVendor(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddReviewToVendor(<any>response_);
                } catch (e) {
                    return <Observable<ReviewResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ReviewResponse>><any>_observableThrow(response_);
        }));
    }

    protected processAddReviewToVendor(response: HttpResponseBase): Observable<ReviewResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReviewResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReviewResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    removeReviewFromVendor(body: ReviewRemoveRequest | undefined): Observable<Response> {
        let url_ = this.baseUrl + "/Reviews/RemoveReviewFromVendorAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveReviewFromVendor(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveReviewFromVendor(<any>response_);
                } catch (e) {
                    return <Observable<Response>><any>_observableThrow(e);
                }
            } else
                return <Observable<Response>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveReviewFromVendor(response: HttpResponseBase): Observable<Response> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Response.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Response>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateReviewOnVendor(body: ReviewUpdateRequest | undefined): Observable<ReviewResponse> {
        let url_ = this.baseUrl + "/Reviews/UpdateReviewOnVendorAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateReviewOnVendor(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateReviewOnVendor(<any>response_);
                } catch (e) {
                    return <Observable<ReviewResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ReviewResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateReviewOnVendor(response: HttpResponseBase): Observable<ReviewResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReviewResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReviewResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    autocompleteSearchForAnswer(body: AnswerSearchRequest | undefined): Observable<AnswerSearchResponse> {
        let url_ = this.baseUrl + "/Search/AutocompleteSearchForAnswerAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAutocompleteSearchForAnswer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAutocompleteSearchForAnswer(<any>response_);
                } catch (e) {
                    return <Observable<AnswerSearchResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<AnswerSearchResponse>><any>_observableThrow(response_);
        }));
    }

    protected processAutocompleteSearchForAnswer(response: HttpResponseBase): Observable<AnswerSearchResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AnswerSearchResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AnswerSearchResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    autocompleteSearchForGooglePlace(body: GooglePlacesSearchRequest | undefined): Observable<GooglePlaceSearchResponse> {
        let url_ = this.baseUrl + "/Search/AutocompleteSearchForGooglePlaceAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAutocompleteSearchForGooglePlace(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAutocompleteSearchForGooglePlace(<any>response_);
                } catch (e) {
                    return <Observable<GooglePlaceSearchResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<GooglePlaceSearchResponse>><any>_observableThrow(response_);
        }));
    }

    protected processAutocompleteSearchForGooglePlace(response: HttpResponseBase): Observable<GooglePlaceSearchResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GooglePlaceSearchResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GooglePlaceSearchResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getGooglePlaceDetails(body: GooglePlaceRequest | undefined): Observable<GooglePlaceDetailsResponse> {
        let url_ = this.baseUrl + "/Search/GetGooglePlaceDetailsAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGooglePlaceDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGooglePlaceDetails(<any>response_);
                } catch (e) {
                    return <Observable<GooglePlaceDetailsResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<GooglePlaceDetailsResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetGooglePlaceDetails(response: HttpResponseBase): Observable<GooglePlaceDetailsResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GooglePlaceDetailsResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GooglePlaceDetailsResponse>(<any>null);
    }

    /**
     * @return Success
     */
    changeAnswers(): Observable<Response> {
        let url_ = this.baseUrl + "/SeedData/ChangeAnswersAsync";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeAnswers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeAnswers(<any>response_);
                } catch (e) {
                    return <Observable<Response>><any>_observableThrow(e);
                }
            } else
                return <Observable<Response>><any>_observableThrow(response_);
        }));
    }

    protected processChangeAnswers(response: HttpResponseBase): Observable<Response> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Response.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Response>(<any>null);
    }

    /**
     * @return Success
     */
    setVendorProfilePath(): Observable<Response> {
        let url_ = this.baseUrl + "/SeedData/SetVendorProfilePathAsync";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetVendorProfilePath(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetVendorProfilePath(<any>response_);
                } catch (e) {
                    return <Observable<Response>><any>_observableThrow(e);
                }
            } else
                return <Observable<Response>><any>_observableThrow(response_);
        }));
    }

    protected processSetVendorProfilePath(response: HttpResponseBase): Observable<Response> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Response.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Response>(<any>null);
    }

    /**
     * @return Success
     */
    changeVendorPhotos(): Observable<Response> {
        let url_ = this.baseUrl + "/SeedData/ChangeVendorPhotosAsync";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeVendorPhotos(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeVendorPhotos(<any>response_);
                } catch (e) {
                    return <Observable<Response>><any>_observableThrow(e);
                }
            } else
                return <Observable<Response>><any>_observableThrow(response_);
        }));
    }

    protected processChangeVendorPhotos(response: HttpResponseBase): Observable<Response> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Response.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Response>(<any>null);
    }

    /**
     * @return Success
     */
    updateConsumerProfilesSeedData(): Observable<Response> {
        let url_ = this.baseUrl + "/SeedData/UpdateConsumerProfilesSeedDataAsync";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateConsumerProfilesSeedData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateConsumerProfilesSeedData(<any>response_);
                } catch (e) {
                    return <Observable<Response>><any>_observableThrow(e);
                }
            } else
                return <Observable<Response>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateConsumerProfilesSeedData(response: HttpResponseBase): Observable<Response> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Response.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Response>(<any>null);
    }

    /**
     * @return Success
     */
    updateConsumerProfilesPathsSeedData(): Observable<Response> {
        let url_ = this.baseUrl + "/SeedData/UpdateConsumerProfilesPathsSeedDataAsync";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateConsumerProfilesPathsSeedData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateConsumerProfilesPathsSeedData(<any>response_);
                } catch (e) {
                    return <Observable<Response>><any>_observableThrow(e);
                }
            } else
                return <Observable<Response>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateConsumerProfilesPathsSeedData(response: HttpResponseBase): Observable<Response> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Response.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Response>(<any>null);
    }

    /**
     * @return Success
     */
    updateVendorProfilesSeedData(): Observable<Response> {
        let url_ = this.baseUrl + "/SeedData/UpdateVendorProfilesSeedDataAsync";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateVendorProfilesSeedData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateVendorProfilesSeedData(<any>response_);
                } catch (e) {
                    return <Observable<Response>><any>_observableThrow(e);
                }
            } else
                return <Observable<Response>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateVendorProfilesSeedData(response: HttpResponseBase): Observable<Response> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Response.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Response>(<any>null);
    }

    /**
     * @return Success
     */
    addHeroAdTemplatesSeedData(): Observable<Response> {
        let url_ = this.baseUrl + "/SeedData/AddHeroAdTemplatesSeedDataAsync";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddHeroAdTemplatesSeedData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddHeroAdTemplatesSeedData(<any>response_);
                } catch (e) {
                    return <Observable<Response>><any>_observableThrow(e);
                }
            } else
                return <Observable<Response>><any>_observableThrow(response_);
        }));
    }

    protected processAddHeroAdTemplatesSeedData(response: HttpResponseBase): Observable<Response> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Response.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Response>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getSettings(body: Request | undefined): Observable<Settings> {
        let url_ = this.baseUrl + "/Settings/GetSettingsAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSettings(<any>response_);
                } catch (e) {
                    return <Observable<Settings>><any>_observableThrow(e);
                }
            } else
                return <Observable<Settings>><any>_observableThrow(response_);
        }));
    }

    protected processGetSettings(response: HttpResponseBase): Observable<Settings> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Settings.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Settings>(<any>null);
    }

    /**
     * @return Success
     */
    stripeWebHook(): Observable<void> {
        let url_ = this.baseUrl + "/StripeWebHook";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStripeWebHook(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStripeWebHook(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processStripeWebHook(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    cancelSession(id: string | null): Observable<void> {
        let url_ = this.baseUrl + "/StripeWebHook/CancelSessionAsync/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancelSession(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancelSession(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCancelSession(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getVendorsByCommunityName(body: VendorProfilesRequest | undefined): Observable<VendorProfilesResponse> {
        let url_ = this.baseUrl + "/Vendors/GetVendorsByCommunityNameAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVendorsByCommunityName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVendorsByCommunityName(<any>response_);
                } catch (e) {
                    return <Observable<VendorProfilesResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<VendorProfilesResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetVendorsByCommunityName(response: HttpResponseBase): Observable<VendorProfilesResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VendorProfilesResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VendorProfilesResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getSampleOfVendors(body: Request | undefined): Observable<VendorProfilesResponse> {
        let url_ = this.baseUrl + "/Vendors/GetSampleOfVendorsAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSampleOfVendors(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSampleOfVendors(<any>response_);
                } catch (e) {
                    return <Observable<VendorProfilesResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<VendorProfilesResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetSampleOfVendors(response: HttpResponseBase): Observable<VendorProfilesResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VendorProfilesResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VendorProfilesResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getVendorProfileWithReviewsById(body: VendorProfileRequest | undefined): Observable<VendorProfileWithReviewsResponse> {
        let url_ = this.baseUrl + "/Vendors/GetVendorProfileWithReviewsByIdAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVendorProfileWithReviewsById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVendorProfileWithReviewsById(<any>response_);
                } catch (e) {
                    return <Observable<VendorProfileWithReviewsResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<VendorProfileWithReviewsResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetVendorProfileWithReviewsById(response: HttpResponseBase): Observable<VendorProfileWithReviewsResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VendorProfileWithReviewsResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VendorProfileWithReviewsResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getVendorProfileWithReviewsByPath(body: VendorProfileRequest | undefined): Observable<VendorProfileWithReviewsResponse> {
        let url_ = this.baseUrl + "/Vendors/GetVendorProfileWithReviewsByPathAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVendorProfileWithReviewsByPath(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVendorProfileWithReviewsByPath(<any>response_);
                } catch (e) {
                    return <Observable<VendorProfileWithReviewsResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<VendorProfileWithReviewsResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetVendorProfileWithReviewsByPath(response: HttpResponseBase): Observable<VendorProfileWithReviewsResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VendorProfileWithReviewsResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VendorProfileWithReviewsResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getVendorProfileByVendorInfo(body: GetVendorProfileByInfoRequest | undefined): Observable<VendorProfileResponse> {
        let url_ = this.baseUrl + "/Vendors/GetVendorProfileByVendorInfoAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVendorProfileByVendorInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVendorProfileByVendorInfo(<any>response_);
                } catch (e) {
                    return <Observable<VendorProfileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<VendorProfileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetVendorProfileByVendorInfo(response: HttpResponseBase): Observable<VendorProfileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VendorProfileResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VendorProfileResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getVendorProfilesForMyPlaces(body: Request | undefined): Observable<VendorProfilesResponse> {
        let url_ = this.baseUrl + "/Vendors/GetVendorProfilesForMyPlacesAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVendorProfilesForMyPlaces(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVendorProfilesForMyPlaces(<any>response_);
                } catch (e) {
                    return <Observable<VendorProfilesResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<VendorProfilesResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetVendorProfilesForMyPlaces(response: HttpResponseBase): Observable<VendorProfilesResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VendorProfilesResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VendorProfilesResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    uploadVendorPhoto(body: VendorImageRequest | undefined): Observable<VendorProfileResponse> {
        let url_ = this.baseUrl + "/Vendors/UploadVendorPhotoAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadVendorPhoto(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadVendorPhoto(<any>response_);
                } catch (e) {
                    return <Observable<VendorProfileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<VendorProfileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUploadVendorPhoto(response: HttpResponseBase): Observable<VendorProfileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VendorProfileResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VendorProfileResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    uploadVendorLogo(body: VendorImageRequest | undefined): Observable<VendorProfileResponse> {
        let url_ = this.baseUrl + "/Vendors/UploadVendorLogoAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadVendorLogo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadVendorLogo(<any>response_);
                } catch (e) {
                    return <Observable<VendorProfileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<VendorProfileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUploadVendorLogo(response: HttpResponseBase): Observable<VendorProfileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VendorProfileResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VendorProfileResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateVendorDescription(body: VendorDescriptionRequest | undefined): Observable<VendorProfileResponse> {
        let url_ = this.baseUrl + "/Vendors/UpdateVendorDescriptionAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateVendorDescription(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateVendorDescription(<any>response_);
                } catch (e) {
                    return <Observable<VendorProfileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<VendorProfileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateVendorDescription(response: HttpResponseBase): Observable<VendorProfileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VendorProfileResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VendorProfileResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateSocialLinks(body: VendorSocialLinksRequest | undefined): Observable<VendorProfileResponse> {
        let url_ = this.baseUrl + "/Vendors/UpdateSocialLinksAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateSocialLinks(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSocialLinks(<any>response_);
                } catch (e) {
                    return <Observable<VendorProfileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<VendorProfileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateSocialLinks(response: HttpResponseBase): Observable<VendorProfileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VendorProfileResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VendorProfileResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateCommunities(body: VendorCommunitiesRequest | undefined): Observable<VendorProfileResponse> {
        let url_ = this.baseUrl + "/Vendors/UpdateCommunitiesAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCommunities(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCommunities(<any>response_);
                } catch (e) {
                    return <Observable<VendorProfileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<VendorProfileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateCommunities(response: HttpResponseBase): Observable<VendorProfileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VendorProfileResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VendorProfileResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateVendorBorderColor(body: VendorBorderColorRequest | undefined): Observable<VendorProfileResponse> {
        let url_ = this.baseUrl + "/Vendors/UpdateVendorBorderColorAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateVendorBorderColor(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateVendorBorderColor(<any>response_);
                } catch (e) {
                    return <Observable<VendorProfileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<VendorProfileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateVendorBorderColor(response: HttpResponseBase): Observable<VendorProfileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VendorProfileResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VendorProfileResponse>(<any>null);
    }
}

export class Request implements IRequest {

    constructor(data?: IRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): Request {
        data = typeof data === 'object' ? data : {};
        let result = new Request();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export interface IRequest {
}

export class ErrorDto implements IErrorDto {
    errorMessage?: string | undefined;
    errorCode?: string | undefined;

    constructor(data?: IErrorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
        }
    }

    static fromJS(data: any): ErrorDto {
        data = typeof data === 'object' ? data : {};
        let result = new ErrorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        return data; 
    }
}

export interface IErrorDto {
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
}

export class ConsumerProfile implements IConsumerProfile {
    id?: string | undefined;
    createdDateUtc?: Date;
    lastUpdatedDateUtc?: Date;
    name?: string | undefined;
    avatarSourceURL?: string | undefined;
    email?: string | undefined;
    emailVerified?: boolean;
    myPlacesVendorIds?: string[] | undefined;
    profilePath?: string | undefined;
    hometown?: string | undefined;
    borderColor?: string | undefined;
    description?: string | undefined;
    notificationsForAnsweredQuestions?: boolean;
    questionsAskedCount?: number;
    questionsAnsweredCount?: number;
    reviewsCount?: number;

    constructor(data?: IConsumerProfile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdDateUtc = _data["createdDateUtc"] ? new Date(_data["createdDateUtc"].toString()) : <any>undefined;
            this.lastUpdatedDateUtc = _data["lastUpdatedDateUtc"] ? new Date(_data["lastUpdatedDateUtc"].toString()) : <any>undefined;
            this.name = _data["name"];
            this.avatarSourceURL = _data["avatarSourceURL"];
            this.email = _data["email"];
            this.emailVerified = _data["emailVerified"];
            if (Array.isArray(_data["myPlacesVendorIds"])) {
                this.myPlacesVendorIds = [] as any;
                for (let item of _data["myPlacesVendorIds"])
                    this.myPlacesVendorIds!.push(item);
            }
            this.profilePath = _data["profilePath"];
            this.hometown = _data["hometown"];
            this.borderColor = _data["borderColor"];
            this.description = _data["description"];
            this.notificationsForAnsweredQuestions = _data["notificationsForAnsweredQuestions"];
            this.questionsAskedCount = _data["questionsAskedCount"];
            this.questionsAnsweredCount = _data["questionsAnsweredCount"];
            this.reviewsCount = _data["reviewsCount"];
        }
    }

    static fromJS(data: any): ConsumerProfile {
        data = typeof data === 'object' ? data : {};
        let result = new ConsumerProfile();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdDateUtc"] = this.createdDateUtc ? this.createdDateUtc.toISOString() : <any>undefined;
        data["lastUpdatedDateUtc"] = this.lastUpdatedDateUtc ? this.lastUpdatedDateUtc.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["avatarSourceURL"] = this.avatarSourceURL;
        data["email"] = this.email;
        data["emailVerified"] = this.emailVerified;
        if (Array.isArray(this.myPlacesVendorIds)) {
            data["myPlacesVendorIds"] = [];
            for (let item of this.myPlacesVendorIds)
                data["myPlacesVendorIds"].push(item);
        }
        data["profilePath"] = this.profilePath;
        data["hometown"] = this.hometown;
        data["borderColor"] = this.borderColor;
        data["description"] = this.description;
        data["notificationsForAnsweredQuestions"] = this.notificationsForAnsweredQuestions;
        data["questionsAskedCount"] = this.questionsAskedCount;
        data["questionsAnsweredCount"] = this.questionsAnsweredCount;
        data["reviewsCount"] = this.reviewsCount;
        return data; 
    }
}

export interface IConsumerProfile {
    id?: string | undefined;
    createdDateUtc?: Date;
    lastUpdatedDateUtc?: Date;
    name?: string | undefined;
    avatarSourceURL?: string | undefined;
    email?: string | undefined;
    emailVerified?: boolean;
    myPlacesVendorIds?: string[] | undefined;
    profilePath?: string | undefined;
    hometown?: string | undefined;
    borderColor?: string | undefined;
    description?: string | undefined;
    notificationsForAnsweredQuestions?: boolean;
    questionsAskedCount?: number;
    questionsAnsweredCount?: number;
    reviewsCount?: number;
}

export class VendorProfile implements IVendorProfile {
    id?: string | undefined;
    createdDateUtc?: Date;
    lastUpdatedDateUtc?: Date;
    googlePlaceId?: string | undefined;
    googlePlaceSearchReference?: string | undefined;
    vendorSubscriptionPlan?: string | undefined;
    stripeSubscriptionItemId?: string | undefined;
    name?: string | undefined;
    address?: string | undefined;
    city?: string | undefined;
    state?: string | undefined;
    country?: string | undefined;
    zip?: string | undefined;
    phoneNumber?: string | undefined;
    websiteURL?: string | undefined;
    businessEmail?: string | undefined;
    facebookURL?: string | undefined;
    instagramURL?: string | undefined;
    twitterURL?: string | undefined;
    photosDictionary?: { [key: string]: string; } | undefined;
    description?: string | undefined;
    avatarSourceURL?: string | undefined;
    profilePath?: string | undefined;
    borderColor?: string | undefined;
    communities?: string[] | undefined;
    reviewCount?: number;
    reviewRatingTotal?: number;
    questionsAnsweredCount?: number;

    constructor(data?: IVendorProfile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdDateUtc = _data["createdDateUtc"] ? new Date(_data["createdDateUtc"].toString()) : <any>undefined;
            this.lastUpdatedDateUtc = _data["lastUpdatedDateUtc"] ? new Date(_data["lastUpdatedDateUtc"].toString()) : <any>undefined;
            this.googlePlaceId = _data["googlePlaceId"];
            this.googlePlaceSearchReference = _data["googlePlaceSearchReference"];
            this.vendorSubscriptionPlan = _data["vendorSubscriptionPlan"];
            this.stripeSubscriptionItemId = _data["stripeSubscriptionItemId"];
            this.name = _data["name"];
            this.address = _data["address"];
            this.city = _data["city"];
            this.state = _data["state"];
            this.country = _data["country"];
            this.zip = _data["zip"];
            this.phoneNumber = _data["phoneNumber"];
            this.websiteURL = _data["websiteURL"];
            this.businessEmail = _data["businessEmail"];
            this.facebookURL = _data["facebookURL"];
            this.instagramURL = _data["instagramURL"];
            this.twitterURL = _data["twitterURL"];
            if (_data["photosDictionary"]) {
                this.photosDictionary = {} as any;
                for (let key in _data["photosDictionary"]) {
                    if (_data["photosDictionary"].hasOwnProperty(key))
                        this.photosDictionary![key] = _data["photosDictionary"][key];
                }
            }
            this.description = _data["description"];
            this.avatarSourceURL = _data["avatarSourceURL"];
            this.profilePath = _data["profilePath"];
            this.borderColor = _data["borderColor"];
            if (Array.isArray(_data["communities"])) {
                this.communities = [] as any;
                for (let item of _data["communities"])
                    this.communities!.push(item);
            }
            this.reviewCount = _data["reviewCount"];
            this.reviewRatingTotal = _data["reviewRatingTotal"];
            this.questionsAnsweredCount = _data["questionsAnsweredCount"];
        }
    }

    static fromJS(data: any): VendorProfile {
        data = typeof data === 'object' ? data : {};
        let result = new VendorProfile();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdDateUtc"] = this.createdDateUtc ? this.createdDateUtc.toISOString() : <any>undefined;
        data["lastUpdatedDateUtc"] = this.lastUpdatedDateUtc ? this.lastUpdatedDateUtc.toISOString() : <any>undefined;
        data["googlePlaceId"] = this.googlePlaceId;
        data["googlePlaceSearchReference"] = this.googlePlaceSearchReference;
        data["vendorSubscriptionPlan"] = this.vendorSubscriptionPlan;
        data["stripeSubscriptionItemId"] = this.stripeSubscriptionItemId;
        data["name"] = this.name;
        data["address"] = this.address;
        data["city"] = this.city;
        data["state"] = this.state;
        data["country"] = this.country;
        data["zip"] = this.zip;
        data["phoneNumber"] = this.phoneNumber;
        data["websiteURL"] = this.websiteURL;
        data["businessEmail"] = this.businessEmail;
        data["facebookURL"] = this.facebookURL;
        data["instagramURL"] = this.instagramURL;
        data["twitterURL"] = this.twitterURL;
        if (this.photosDictionary) {
            data["photosDictionary"] = {};
            for (let key in this.photosDictionary) {
                if (this.photosDictionary.hasOwnProperty(key))
                    data["photosDictionary"][key] = this.photosDictionary[key];
            }
        }
        data["description"] = this.description;
        data["avatarSourceURL"] = this.avatarSourceURL;
        data["profilePath"] = this.profilePath;
        data["borderColor"] = this.borderColor;
        if (Array.isArray(this.communities)) {
            data["communities"] = [];
            for (let item of this.communities)
                data["communities"].push(item);
        }
        data["reviewCount"] = this.reviewCount;
        data["reviewRatingTotal"] = this.reviewRatingTotal;
        data["questionsAnsweredCount"] = this.questionsAnsweredCount;
        return data; 
    }
}

export interface IVendorProfile {
    id?: string | undefined;
    createdDateUtc?: Date;
    lastUpdatedDateUtc?: Date;
    googlePlaceId?: string | undefined;
    googlePlaceSearchReference?: string | undefined;
    vendorSubscriptionPlan?: string | undefined;
    stripeSubscriptionItemId?: string | undefined;
    name?: string | undefined;
    address?: string | undefined;
    city?: string | undefined;
    state?: string | undefined;
    country?: string | undefined;
    zip?: string | undefined;
    phoneNumber?: string | undefined;
    websiteURL?: string | undefined;
    businessEmail?: string | undefined;
    facebookURL?: string | undefined;
    instagramURL?: string | undefined;
    twitterURL?: string | undefined;
    photosDictionary?: { [key: string]: string; } | undefined;
    description?: string | undefined;
    avatarSourceURL?: string | undefined;
    profilePath?: string | undefined;
    borderColor?: string | undefined;
    communities?: string[] | undefined;
    reviewCount?: number;
    reviewRatingTotal?: number;
    questionsAnsweredCount?: number;
}

export class ProfilesResponse implements IProfilesResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    consumerProfile?: ConsumerProfile;
    vendorProfiles?: VendorProfile[] | undefined;
    notificationCategories?: string[] | undefined;
    feedCategoriesToShow?: string[] | undefined;
    notificationsForAnsweredQuestions?: boolean;
    isAdmin?: boolean;

    constructor(data?: IProfilesResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ErrorDto.fromJS(item));
            }
            this.isSuccess = _data["isSuccess"];
            this.consumerProfile = _data["consumerProfile"] ? ConsumerProfile.fromJS(_data["consumerProfile"]) : <any>undefined;
            if (Array.isArray(_data["vendorProfiles"])) {
                this.vendorProfiles = [] as any;
                for (let item of _data["vendorProfiles"])
                    this.vendorProfiles!.push(VendorProfile.fromJS(item));
            }
            if (Array.isArray(_data["notificationCategories"])) {
                this.notificationCategories = [] as any;
                for (let item of _data["notificationCategories"])
                    this.notificationCategories!.push(item);
            }
            if (Array.isArray(_data["feedCategoriesToShow"])) {
                this.feedCategoriesToShow = [] as any;
                for (let item of _data["feedCategoriesToShow"])
                    this.feedCategoriesToShow!.push(item);
            }
            this.notificationsForAnsweredQuestions = _data["notificationsForAnsweredQuestions"];
            this.isAdmin = _data["isAdmin"];
        }
    }

    static fromJS(data: any): ProfilesResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ProfilesResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        data["isSuccess"] = this.isSuccess;
        data["consumerProfile"] = this.consumerProfile ? this.consumerProfile.toJSON() : <any>undefined;
        if (Array.isArray(this.vendorProfiles)) {
            data["vendorProfiles"] = [];
            for (let item of this.vendorProfiles)
                data["vendorProfiles"].push(item.toJSON());
        }
        if (Array.isArray(this.notificationCategories)) {
            data["notificationCategories"] = [];
            for (let item of this.notificationCategories)
                data["notificationCategories"].push(item);
        }
        if (Array.isArray(this.feedCategoriesToShow)) {
            data["feedCategoriesToShow"] = [];
            for (let item of this.feedCategoriesToShow)
                data["feedCategoriesToShow"].push(item);
        }
        data["notificationsForAnsweredQuestions"] = this.notificationsForAnsweredQuestions;
        data["isAdmin"] = this.isAdmin;
        return data; 
    }
}

export interface IProfilesResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    consumerProfile?: ConsumerProfile;
    vendorProfiles?: VendorProfile[] | undefined;
    notificationCategories?: string[] | undefined;
    feedCategoriesToShow?: string[] | undefined;
    notificationsForAnsweredQuestions?: boolean;
    isAdmin?: boolean;
}

export class AccountCreateRequest implements IAccountCreateRequest {
    googleAuthUserId?: string | undefined;
    username?: string | undefined;
    email?: string | undefined;

    constructor(data?: IAccountCreateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.googleAuthUserId = _data["googleAuthUserId"];
            this.username = _data["username"];
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): AccountCreateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AccountCreateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["googleAuthUserId"] = this.googleAuthUserId;
        data["username"] = this.username;
        data["email"] = this.email;
        return data; 
    }
}

export interface IAccountCreateRequest {
    googleAuthUserId?: string | undefined;
    username?: string | undefined;
    email?: string | undefined;
}

export class AccountDeletionRequest implements IAccountDeletionRequest {
    userId?: string | undefined;
    token?: string | undefined;

    constructor(data?: IAccountDeletionRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.token = _data["token"];
        }
    }

    static fromJS(data: any): AccountDeletionRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AccountDeletionRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["token"] = this.token;
        return data; 
    }
}

export interface IAccountDeletionRequest {
    userId?: string | undefined;
    token?: string | undefined;
}

export class Response implements IResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;

    constructor(data?: IResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ErrorDto.fromJS(item));
            }
            this.isSuccess = _data["isSuccess"];
        }
    }

    static fromJS(data: any): Response {
        data = typeof data === 'object' ? data : {};
        let result = new Response();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        data["isSuccess"] = this.isSuccess;
        return data; 
    }
}

export interface IResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
}

export class AccountNotificationCategoriesRequest implements IAccountNotificationCategoriesRequest {
    notificationToken?: string | undefined;
    notificationCategories?: string[] | undefined;
    notificationsForAnsweredQuestions?: boolean;

    constructor(data?: IAccountNotificationCategoriesRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.notificationToken = _data["notificationToken"];
            if (Array.isArray(_data["notificationCategories"])) {
                this.notificationCategories = [] as any;
                for (let item of _data["notificationCategories"])
                    this.notificationCategories!.push(item);
            }
            this.notificationsForAnsweredQuestions = _data["notificationsForAnsweredQuestions"];
        }
    }

    static fromJS(data: any): AccountNotificationCategoriesRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AccountNotificationCategoriesRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["notificationToken"] = this.notificationToken;
        if (Array.isArray(this.notificationCategories)) {
            data["notificationCategories"] = [];
            for (let item of this.notificationCategories)
                data["notificationCategories"].push(item);
        }
        data["notificationsForAnsweredQuestions"] = this.notificationsForAnsweredQuestions;
        return data; 
    }
}

export interface IAccountNotificationCategoriesRequest {
    notificationToken?: string | undefined;
    notificationCategories?: string[] | undefined;
    notificationsForAnsweredQuestions?: boolean;
}

export class NotificationTokenRequest implements INotificationTokenRequest {
    notificationToken?: string | undefined;

    constructor(data?: INotificationTokenRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.notificationToken = _data["notificationToken"];
        }
    }

    static fromJS(data: any): NotificationTokenRequest {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationTokenRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["notificationToken"] = this.notificationToken;
        return data; 
    }
}

export interface INotificationTokenRequest {
    notificationToken?: string | undefined;
}

export class AccountFeedSettingsRequest implements IAccountFeedSettingsRequest {
    feedCategoriesToShow?: string[] | undefined;

    constructor(data?: IAccountFeedSettingsRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["feedCategoriesToShow"])) {
                this.feedCategoriesToShow = [] as any;
                for (let item of _data["feedCategoriesToShow"])
                    this.feedCategoriesToShow!.push(item);
            }
        }
    }

    static fromJS(data: any): AccountFeedSettingsRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AccountFeedSettingsRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.feedCategoriesToShow)) {
            data["feedCategoriesToShow"] = [];
            for (let item of this.feedCategoriesToShow)
                data["feedCategoriesToShow"].push(item);
        }
        return data; 
    }
}

export interface IAccountFeedSettingsRequest {
    feedCategoriesToShow?: string[] | undefined;
}

export class NeatBoutiqueEntity implements INeatBoutiqueEntity {
    id?: string | undefined;
    role?: string | undefined;
    name?: string | undefined;
    avatarSourceURL?: string | undefined;
    profilePath?: string | undefined;
    borderColor?: string | undefined;

    constructor(data?: INeatBoutiqueEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.role = _data["role"];
            this.name = _data["name"];
            this.avatarSourceURL = _data["avatarSourceURL"];
            this.profilePath = _data["profilePath"];
            this.borderColor = _data["borderColor"];
        }
    }

    static fromJS(data: any): NeatBoutiqueEntity {
        data = typeof data === 'object' ? data : {};
        let result = new NeatBoutiqueEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["role"] = this.role;
        data["name"] = this.name;
        data["avatarSourceURL"] = this.avatarSourceURL;
        data["profilePath"] = this.profilePath;
        data["borderColor"] = this.borderColor;
        return data; 
    }
}

export interface INeatBoutiqueEntity {
    id?: string | undefined;
    role?: string | undefined;
    name?: string | undefined;
    avatarSourceURL?: string | undefined;
    profilePath?: string | undefined;
    borderColor?: string | undefined;
}

export class AnswerWithVendorRequest implements IAnswerWithVendorRequest {
    postId?: string | undefined;
    vendor?: NeatBoutiqueEntity;
    voteRanking?: string | undefined;

    constructor(data?: IAnswerWithVendorRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.postId = _data["postId"];
            this.vendor = _data["vendor"] ? NeatBoutiqueEntity.fromJS(_data["vendor"]) : <any>undefined;
            this.voteRanking = _data["voteRanking"];
        }
    }

    static fromJS(data: any): AnswerWithVendorRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AnswerWithVendorRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["postId"] = this.postId;
        data["vendor"] = this.vendor ? this.vendor.toJSON() : <any>undefined;
        data["voteRanking"] = this.voteRanking;
        return data; 
    }
}

export interface IAnswerWithVendorRequest {
    postId?: string | undefined;
    vendor?: NeatBoutiqueEntity;
    voteRanking?: string | undefined;
}

export class Comment implements IComment {
    id?: string | undefined;
    createdDateUtc?: Date;
    lastUpdatedDateUtc?: Date;
    postId?: string | undefined;
    body?: string | undefined;
    author?: NeatBoutiqueEntity;
    likers?: NeatBoutiqueEntity[] | undefined;

    constructor(data?: IComment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdDateUtc = _data["createdDateUtc"] ? new Date(_data["createdDateUtc"].toString()) : <any>undefined;
            this.lastUpdatedDateUtc = _data["lastUpdatedDateUtc"] ? new Date(_data["lastUpdatedDateUtc"].toString()) : <any>undefined;
            this.postId = _data["postId"];
            this.body = _data["body"];
            this.author = _data["author"] ? NeatBoutiqueEntity.fromJS(_data["author"]) : <any>undefined;
            if (Array.isArray(_data["likers"])) {
                this.likers = [] as any;
                for (let item of _data["likers"])
                    this.likers!.push(NeatBoutiqueEntity.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Comment {
        data = typeof data === 'object' ? data : {};
        let result = new Comment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdDateUtc"] = this.createdDateUtc ? this.createdDateUtc.toISOString() : <any>undefined;
        data["lastUpdatedDateUtc"] = this.lastUpdatedDateUtc ? this.lastUpdatedDateUtc.toISOString() : <any>undefined;
        data["postId"] = this.postId;
        data["body"] = this.body;
        data["author"] = this.author ? this.author.toJSON() : <any>undefined;
        if (Array.isArray(this.likers)) {
            data["likers"] = [];
            for (let item of this.likers)
                data["likers"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IComment {
    id?: string | undefined;
    createdDateUtc?: Date;
    lastUpdatedDateUtc?: Date;
    postId?: string | undefined;
    body?: string | undefined;
    author?: NeatBoutiqueEntity;
    likers?: NeatBoutiqueEntity[] | undefined;
}

export class GooglePlacesEntity implements IGooglePlacesEntity {
    placeId?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;

    constructor(data?: IGooglePlacesEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.placeId = _data["placeId"];
            this.name = _data["name"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): GooglePlacesEntity {
        data = typeof data === 'object' ? data : {};
        let result = new GooglePlacesEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["placeId"] = this.placeId;
        data["name"] = this.name;
        data["description"] = this.description;
        return data; 
    }
}

export interface IGooglePlacesEntity {
    placeId?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
}

export class AnswerVote implements IAnswerVote {
    id?: string | undefined;
    createdDateUtc?: Date;
    lastUpdatedDateUtc?: Date;
    postId?: string | undefined;
    answerId?: string | undefined;
    voter?: NeatBoutiqueEntity;
    voteRanking?: string | undefined;

    constructor(data?: IAnswerVote) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdDateUtc = _data["createdDateUtc"] ? new Date(_data["createdDateUtc"].toString()) : <any>undefined;
            this.lastUpdatedDateUtc = _data["lastUpdatedDateUtc"] ? new Date(_data["lastUpdatedDateUtc"].toString()) : <any>undefined;
            this.postId = _data["postId"];
            this.answerId = _data["answerId"];
            this.voter = _data["voter"] ? NeatBoutiqueEntity.fromJS(_data["voter"]) : <any>undefined;
            this.voteRanking = _data["voteRanking"];
        }
    }

    static fromJS(data: any): AnswerVote {
        data = typeof data === 'object' ? data : {};
        let result = new AnswerVote();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdDateUtc"] = this.createdDateUtc ? this.createdDateUtc.toISOString() : <any>undefined;
        data["lastUpdatedDateUtc"] = this.lastUpdatedDateUtc ? this.lastUpdatedDateUtc.toISOString() : <any>undefined;
        data["postId"] = this.postId;
        data["answerId"] = this.answerId;
        data["voter"] = this.voter ? this.voter.toJSON() : <any>undefined;
        data["voteRanking"] = this.voteRanking;
        return data; 
    }
}

export interface IAnswerVote {
    id?: string | undefined;
    createdDateUtc?: Date;
    lastUpdatedDateUtc?: Date;
    postId?: string | undefined;
    answerId?: string | undefined;
    voter?: NeatBoutiqueEntity;
    voteRanking?: string | undefined;
}

export class Answer implements IAnswer {
    id?: string | undefined;
    createdDateUtc?: Date;
    lastUpdatedDateUtc?: Date;
    postId?: string | undefined;
    vendor?: NeatBoutiqueEntity;
    googlePlace?: GooglePlacesEntity;
    votes?: AnswerVote[] | undefined;

    constructor(data?: IAnswer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdDateUtc = _data["createdDateUtc"] ? new Date(_data["createdDateUtc"].toString()) : <any>undefined;
            this.lastUpdatedDateUtc = _data["lastUpdatedDateUtc"] ? new Date(_data["lastUpdatedDateUtc"].toString()) : <any>undefined;
            this.postId = _data["postId"];
            this.vendor = _data["vendor"] ? NeatBoutiqueEntity.fromJS(_data["vendor"]) : <any>undefined;
            this.googlePlace = _data["googlePlace"] ? GooglePlacesEntity.fromJS(_data["googlePlace"]) : <any>undefined;
            if (Array.isArray(_data["votes"])) {
                this.votes = [] as any;
                for (let item of _data["votes"])
                    this.votes!.push(AnswerVote.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Answer {
        data = typeof data === 'object' ? data : {};
        let result = new Answer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdDateUtc"] = this.createdDateUtc ? this.createdDateUtc.toISOString() : <any>undefined;
        data["lastUpdatedDateUtc"] = this.lastUpdatedDateUtc ? this.lastUpdatedDateUtc.toISOString() : <any>undefined;
        data["postId"] = this.postId;
        data["vendor"] = this.vendor ? this.vendor.toJSON() : <any>undefined;
        data["googlePlace"] = this.googlePlace ? this.googlePlace.toJSON() : <any>undefined;
        if (Array.isArray(this.votes)) {
            data["votes"] = [];
            for (let item of this.votes)
                data["votes"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IAnswer {
    id?: string | undefined;
    createdDateUtc?: Date;
    lastUpdatedDateUtc?: Date;
    postId?: string | undefined;
    vendor?: NeatBoutiqueEntity;
    googlePlace?: GooglePlacesEntity;
    votes?: AnswerVote[] | undefined;
}

export class ConsumerPost implements IConsumerPost {
    id?: string | undefined;
    createdDateUtc?: Date;
    lastUpdatedDateUtc?: Date;
    question?: string | undefined;
    communityName?: string | undefined;
    author?: NeatBoutiqueEntity;
    comments?: Comment[] | undefined;
    answers?: Answer[] | undefined;

    constructor(data?: IConsumerPost) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdDateUtc = _data["createdDateUtc"] ? new Date(_data["createdDateUtc"].toString()) : <any>undefined;
            this.lastUpdatedDateUtc = _data["lastUpdatedDateUtc"] ? new Date(_data["lastUpdatedDateUtc"].toString()) : <any>undefined;
            this.question = _data["question"];
            this.communityName = _data["communityName"];
            this.author = _data["author"] ? NeatBoutiqueEntity.fromJS(_data["author"]) : <any>undefined;
            if (Array.isArray(_data["comments"])) {
                this.comments = [] as any;
                for (let item of _data["comments"])
                    this.comments!.push(Comment.fromJS(item));
            }
            if (Array.isArray(_data["answers"])) {
                this.answers = [] as any;
                for (let item of _data["answers"])
                    this.answers!.push(Answer.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ConsumerPost {
        data = typeof data === 'object' ? data : {};
        let result = new ConsumerPost();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdDateUtc"] = this.createdDateUtc ? this.createdDateUtc.toISOString() : <any>undefined;
        data["lastUpdatedDateUtc"] = this.lastUpdatedDateUtc ? this.lastUpdatedDateUtc.toISOString() : <any>undefined;
        data["question"] = this.question;
        data["communityName"] = this.communityName;
        data["author"] = this.author ? this.author.toJSON() : <any>undefined;
        if (Array.isArray(this.comments)) {
            data["comments"] = [];
            for (let item of this.comments)
                data["comments"].push(item.toJSON());
        }
        if (Array.isArray(this.answers)) {
            data["answers"] = [];
            for (let item of this.answers)
                data["answers"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IConsumerPost {
    id?: string | undefined;
    createdDateUtc?: Date;
    lastUpdatedDateUtc?: Date;
    question?: string | undefined;
    communityName?: string | undefined;
    author?: NeatBoutiqueEntity;
    comments?: Comment[] | undefined;
    answers?: Answer[] | undefined;
}

export class ConsumerPostResponse implements IConsumerPostResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    post?: ConsumerPost;

    constructor(data?: IConsumerPostResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ErrorDto.fromJS(item));
            }
            this.isSuccess = _data["isSuccess"];
            this.post = _data["post"] ? ConsumerPost.fromJS(_data["post"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ConsumerPostResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ConsumerPostResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        data["isSuccess"] = this.isSuccess;
        data["post"] = this.post ? this.post.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IConsumerPostResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    post?: ConsumerPost;
}

export class AnswerWithGooglePlaceRequest implements IAnswerWithGooglePlaceRequest {
    postId?: string | undefined;
    googlePlace?: GooglePlacesEntity;
    googleSearchSessionToken?: string | undefined;
    voteRanking?: string | undefined;

    constructor(data?: IAnswerWithGooglePlaceRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.postId = _data["postId"];
            this.googlePlace = _data["googlePlace"] ? GooglePlacesEntity.fromJS(_data["googlePlace"]) : <any>undefined;
            this.googleSearchSessionToken = _data["googleSearchSessionToken"];
            this.voteRanking = _data["voteRanking"];
        }
    }

    static fromJS(data: any): AnswerWithGooglePlaceRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AnswerWithGooglePlaceRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["postId"] = this.postId;
        data["googlePlace"] = this.googlePlace ? this.googlePlace.toJSON() : <any>undefined;
        data["googleSearchSessionToken"] = this.googleSearchSessionToken;
        data["voteRanking"] = this.voteRanking;
        return data; 
    }
}

export interface IAnswerWithGooglePlaceRequest {
    postId?: string | undefined;
    googlePlace?: GooglePlacesEntity;
    googleSearchSessionToken?: string | undefined;
    voteRanking?: string | undefined;
}

export class AnswerVoteRemoveRequest implements IAnswerVoteRemoveRequest {
    answerVote?: AnswerVote;

    constructor(data?: IAnswerVoteRemoveRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.answerVote = _data["answerVote"] ? AnswerVote.fromJS(_data["answerVote"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AnswerVoteRemoveRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AnswerVoteRemoveRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["answerVote"] = this.answerVote ? this.answerVote.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IAnswerVoteRemoveRequest {
    answerVote?: AnswerVote;
}

export class CommentRequest implements ICommentRequest {
    postId?: string | undefined;
    body?: string | undefined;
    authorRole?: string | undefined;
    authorId?: string | undefined;

    constructor(data?: ICommentRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.postId = _data["postId"];
            this.body = _data["body"];
            this.authorRole = _data["authorRole"];
            this.authorId = _data["authorId"];
        }
    }

    static fromJS(data: any): CommentRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CommentRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["postId"] = this.postId;
        data["body"] = this.body;
        data["authorRole"] = this.authorRole;
        data["authorId"] = this.authorId;
        return data; 
    }
}

export interface ICommentRequest {
    postId?: string | undefined;
    body?: string | undefined;
    authorRole?: string | undefined;
    authorId?: string | undefined;
}

export class CommentResponse implements ICommentResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    comment?: Comment;

    constructor(data?: ICommentResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ErrorDto.fromJS(item));
            }
            this.isSuccess = _data["isSuccess"];
            this.comment = _data["comment"] ? Comment.fromJS(_data["comment"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CommentResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CommentResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        data["isSuccess"] = this.isSuccess;
        data["comment"] = this.comment ? this.comment.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ICommentResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    comment?: Comment;
}

export class CommentRemoveRequest implements ICommentRemoveRequest {
    commentId?: string | undefined;
    authorId?: string | undefined;

    constructor(data?: ICommentRemoveRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.commentId = _data["commentId"];
            this.authorId = _data["authorId"];
        }
    }

    static fromJS(data: any): CommentRemoveRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CommentRemoveRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commentId"] = this.commentId;
        data["authorId"] = this.authorId;
        return data; 
    }
}

export interface ICommentRemoveRequest {
    commentId?: string | undefined;
    authorId?: string | undefined;
}

export class CommentLikeAddRequest implements ICommentLikeAddRequest {
    commentId?: string | undefined;
    likerId?: string | undefined;
    likerRole?: string | undefined;

    constructor(data?: ICommentLikeAddRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.commentId = _data["commentId"];
            this.likerId = _data["likerId"];
            this.likerRole = _data["likerRole"];
        }
    }

    static fromJS(data: any): CommentLikeAddRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CommentLikeAddRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commentId"] = this.commentId;
        data["likerId"] = this.likerId;
        data["likerRole"] = this.likerRole;
        return data; 
    }
}

export interface ICommentLikeAddRequest {
    commentId?: string | undefined;
    likerId?: string | undefined;
    likerRole?: string | undefined;
}

export class CommentLikeRemoveRequest implements ICommentLikeRemoveRequest {
    commentId?: string | undefined;
    likerId?: string | undefined;

    constructor(data?: ICommentLikeRemoveRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.commentId = _data["commentId"];
            this.likerId = _data["likerId"];
        }
    }

    static fromJS(data: any): CommentLikeRemoveRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CommentLikeRemoveRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commentId"] = this.commentId;
        data["likerId"] = this.likerId;
        return data; 
    }
}

export interface ICommentLikeRemoveRequest {
    commentId?: string | undefined;
    likerId?: string | undefined;
}

export class CommentUpdateRequest implements ICommentUpdateRequest {
    commentId?: string | undefined;
    authorId?: string | undefined;
    body?: string | undefined;

    constructor(data?: ICommentUpdateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.commentId = _data["commentId"];
            this.authorId = _data["authorId"];
            this.body = _data["body"];
        }
    }

    static fromJS(data: any): CommentUpdateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CommentUpdateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commentId"] = this.commentId;
        data["authorId"] = this.authorId;
        data["body"] = this.body;
        return data; 
    }
}

export interface ICommentUpdateRequest {
    commentId?: string | undefined;
    authorId?: string | undefined;
    body?: string | undefined;
}

export class CommunityRequest implements ICommunityRequest {
    communityNames?: string[] | undefined;
    pageNumber?: number;
    pageSize?: number;
    includeRecentPostsCount?: number;

    constructor(data?: ICommunityRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["communityNames"])) {
                this.communityNames = [] as any;
                for (let item of _data["communityNames"])
                    this.communityNames!.push(item);
            }
            this.pageNumber = _data["pageNumber"];
            this.pageSize = _data["pageSize"];
            this.includeRecentPostsCount = _data["includeRecentPostsCount"];
        }
    }

    static fromJS(data: any): CommunityRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CommunityRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.communityNames)) {
            data["communityNames"] = [];
            for (let item of this.communityNames)
                data["communityNames"].push(item);
        }
        data["pageNumber"] = this.pageNumber;
        data["pageSize"] = this.pageSize;
        data["includeRecentPostsCount"] = this.includeRecentPostsCount;
        return data; 
    }
}

export interface ICommunityRequest {
    communityNames?: string[] | undefined;
    pageNumber?: number;
    pageSize?: number;
    includeRecentPostsCount?: number;
}

export class PollAnswer implements IPollAnswer {
    id?: string | undefined;
    answerText?: string | undefined;
    voters?: NeatBoutiqueEntity[] | undefined;

    constructor(data?: IPollAnswer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.answerText = _data["answerText"];
            if (Array.isArray(_data["voters"])) {
                this.voters = [] as any;
                for (let item of _data["voters"])
                    this.voters!.push(NeatBoutiqueEntity.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PollAnswer {
        data = typeof data === 'object' ? data : {};
        let result = new PollAnswer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["answerText"] = this.answerText;
        if (Array.isArray(this.voters)) {
            data["voters"] = [];
            for (let item of this.voters)
                data["voters"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPollAnswer {
    id?: string | undefined;
    answerText?: string | undefined;
    voters?: NeatBoutiqueEntity[] | undefined;
}

export class VendorPost implements IVendorPost {
    id?: string | undefined;
    createdDateUtc?: Date;
    lastUpdatedDateUtc?: Date;
    question?: string | undefined;
    communityName?: string | undefined;
    campaignStartDateUtc?: Date;
    campaignEndDateUtc?: Date;
    author?: NeatBoutiqueEntity;
    answers?: PollAnswer[] | undefined;
    comments?: Comment[] | undefined;

    constructor(data?: IVendorPost) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdDateUtc = _data["createdDateUtc"] ? new Date(_data["createdDateUtc"].toString()) : <any>undefined;
            this.lastUpdatedDateUtc = _data["lastUpdatedDateUtc"] ? new Date(_data["lastUpdatedDateUtc"].toString()) : <any>undefined;
            this.question = _data["question"];
            this.communityName = _data["communityName"];
            this.campaignStartDateUtc = _data["campaignStartDateUtc"] ? new Date(_data["campaignStartDateUtc"].toString()) : <any>undefined;
            this.campaignEndDateUtc = _data["campaignEndDateUtc"] ? new Date(_data["campaignEndDateUtc"].toString()) : <any>undefined;
            this.author = _data["author"] ? NeatBoutiqueEntity.fromJS(_data["author"]) : <any>undefined;
            if (Array.isArray(_data["answers"])) {
                this.answers = [] as any;
                for (let item of _data["answers"])
                    this.answers!.push(PollAnswer.fromJS(item));
            }
            if (Array.isArray(_data["comments"])) {
                this.comments = [] as any;
                for (let item of _data["comments"])
                    this.comments!.push(Comment.fromJS(item));
            }
        }
    }

    static fromJS(data: any): VendorPost {
        data = typeof data === 'object' ? data : {};
        let result = new VendorPost();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdDateUtc"] = this.createdDateUtc ? this.createdDateUtc.toISOString() : <any>undefined;
        data["lastUpdatedDateUtc"] = this.lastUpdatedDateUtc ? this.lastUpdatedDateUtc.toISOString() : <any>undefined;
        data["question"] = this.question;
        data["communityName"] = this.communityName;
        data["campaignStartDateUtc"] = this.campaignStartDateUtc ? this.campaignStartDateUtc.toISOString() : <any>undefined;
        data["campaignEndDateUtc"] = this.campaignEndDateUtc ? this.campaignEndDateUtc.toISOString() : <any>undefined;
        data["author"] = this.author ? this.author.toJSON() : <any>undefined;
        if (Array.isArray(this.answers)) {
            data["answers"] = [];
            for (let item of this.answers)
                data["answers"].push(item.toJSON());
        }
        if (Array.isArray(this.comments)) {
            data["comments"] = [];
            for (let item of this.comments)
                data["comments"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IVendorPost {
    id?: string | undefined;
    createdDateUtc?: Date;
    lastUpdatedDateUtc?: Date;
    question?: string | undefined;
    communityName?: string | undefined;
    campaignStartDateUtc?: Date;
    campaignEndDateUtc?: Date;
    author?: NeatBoutiqueEntity;
    answers?: PollAnswer[] | undefined;
    comments?: Comment[] | undefined;
}

export class AdTagline implements IAdTagline {
    primaryAdTagline?: string | undefined;
    secondaryAdTagline?: string | undefined;

    constructor(data?: IAdTagline) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.primaryAdTagline = _data["primaryAdTagline"];
            this.secondaryAdTagline = _data["secondaryAdTagline"];
        }
    }

    static fromJS(data: any): AdTagline {
        data = typeof data === 'object' ? data : {};
        let result = new AdTagline();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["primaryAdTagline"] = this.primaryAdTagline;
        data["secondaryAdTagline"] = this.secondaryAdTagline;
        return data; 
    }
}

export interface IAdTagline {
    primaryAdTagline?: string | undefined;
    secondaryAdTagline?: string | undefined;
}

export class HeroAd implements IHeroAd {
    id?: string | undefined;
    createdDateUtc?: Date;
    lastUpdatedDateUtc?: Date;
    vendor?: NeatBoutiqueEntity;
    campaignStartDateUtc?: Date;
    campaignEndDateUtc?: Date;
    isActive?: boolean;
    imageUrl?: string | undefined;
    adTagline?: AdTagline;
    callToAction?: string | undefined;
    communityName?: string | undefined;

    constructor(data?: IHeroAd) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdDateUtc = _data["createdDateUtc"] ? new Date(_data["createdDateUtc"].toString()) : <any>undefined;
            this.lastUpdatedDateUtc = _data["lastUpdatedDateUtc"] ? new Date(_data["lastUpdatedDateUtc"].toString()) : <any>undefined;
            this.vendor = _data["vendor"] ? NeatBoutiqueEntity.fromJS(_data["vendor"]) : <any>undefined;
            this.campaignStartDateUtc = _data["campaignStartDateUtc"] ? new Date(_data["campaignStartDateUtc"].toString()) : <any>undefined;
            this.campaignEndDateUtc = _data["campaignEndDateUtc"] ? new Date(_data["campaignEndDateUtc"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
            this.imageUrl = _data["imageUrl"];
            this.adTagline = _data["adTagline"] ? AdTagline.fromJS(_data["adTagline"]) : <any>undefined;
            this.callToAction = _data["callToAction"];
            this.communityName = _data["communityName"];
        }
    }

    static fromJS(data: any): HeroAd {
        data = typeof data === 'object' ? data : {};
        let result = new HeroAd();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdDateUtc"] = this.createdDateUtc ? this.createdDateUtc.toISOString() : <any>undefined;
        data["lastUpdatedDateUtc"] = this.lastUpdatedDateUtc ? this.lastUpdatedDateUtc.toISOString() : <any>undefined;
        data["vendor"] = this.vendor ? this.vendor.toJSON() : <any>undefined;
        data["campaignStartDateUtc"] = this.campaignStartDateUtc ? this.campaignStartDateUtc.toISOString() : <any>undefined;
        data["campaignEndDateUtc"] = this.campaignEndDateUtc ? this.campaignEndDateUtc.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        data["imageUrl"] = this.imageUrl;
        data["adTagline"] = this.adTagline ? this.adTagline.toJSON() : <any>undefined;
        data["callToAction"] = this.callToAction;
        data["communityName"] = this.communityName;
        return data; 
    }
}

export interface IHeroAd {
    id?: string | undefined;
    createdDateUtc?: Date;
    lastUpdatedDateUtc?: Date;
    vendor?: NeatBoutiqueEntity;
    campaignStartDateUtc?: Date;
    campaignEndDateUtc?: Date;
    isActive?: boolean;
    imageUrl?: string | undefined;
    adTagline?: AdTagline;
    callToAction?: string | undefined;
    communityName?: string | undefined;
}

export class CommunityResponse implements ICommunityResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    consumerPosts?: ConsumerPost[] | undefined;
    vendorPosts?: VendorPost[] | undefined;
    recentConsumerPosts?: ConsumerPost[] | undefined;
    heroAds?: HeroAd[] | undefined;

    constructor(data?: ICommunityResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ErrorDto.fromJS(item));
            }
            this.isSuccess = _data["isSuccess"];
            if (Array.isArray(_data["consumerPosts"])) {
                this.consumerPosts = [] as any;
                for (let item of _data["consumerPosts"])
                    this.consumerPosts!.push(ConsumerPost.fromJS(item));
            }
            if (Array.isArray(_data["vendorPosts"])) {
                this.vendorPosts = [] as any;
                for (let item of _data["vendorPosts"])
                    this.vendorPosts!.push(VendorPost.fromJS(item));
            }
            if (Array.isArray(_data["recentConsumerPosts"])) {
                this.recentConsumerPosts = [] as any;
                for (let item of _data["recentConsumerPosts"])
                    this.recentConsumerPosts!.push(ConsumerPost.fromJS(item));
            }
            if (Array.isArray(_data["heroAds"])) {
                this.heroAds = [] as any;
                for (let item of _data["heroAds"])
                    this.heroAds!.push(HeroAd.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CommunityResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CommunityResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        data["isSuccess"] = this.isSuccess;
        if (Array.isArray(this.consumerPosts)) {
            data["consumerPosts"] = [];
            for (let item of this.consumerPosts)
                data["consumerPosts"].push(item.toJSON());
        }
        if (Array.isArray(this.vendorPosts)) {
            data["vendorPosts"] = [];
            for (let item of this.vendorPosts)
                data["vendorPosts"].push(item.toJSON());
        }
        if (Array.isArray(this.recentConsumerPosts)) {
            data["recentConsumerPosts"] = [];
            for (let item of this.recentConsumerPosts)
                data["recentConsumerPosts"].push(item.toJSON());
        }
        if (Array.isArray(this.heroAds)) {
            data["heroAds"] = [];
            for (let item of this.heroAds)
                data["heroAds"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICommunityResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    consumerPosts?: ConsumerPost[] | undefined;
    vendorPosts?: VendorPost[] | undefined;
    recentConsumerPosts?: ConsumerPost[] | undefined;
    heroAds?: HeroAd[] | undefined;
}

export class ConsumerPostRequest implements IConsumerPostRequest {
    postId?: string | undefined;
    post?: ConsumerPost;

    constructor(data?: IConsumerPostRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.postId = _data["postId"];
            this.post = _data["post"] ? ConsumerPost.fromJS(_data["post"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ConsumerPostRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ConsumerPostRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["postId"] = this.postId;
        data["post"] = this.post ? this.post.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IConsumerPostRequest {
    postId?: string | undefined;
    post?: ConsumerPost;
}

export class MyPlacesRequest implements IMyPlacesRequest {
    vendorId?: string | undefined;

    constructor(data?: IMyPlacesRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.vendorId = _data["vendorId"];
        }
    }

    static fromJS(data: any): MyPlacesRequest {
        data = typeof data === 'object' ? data : {};
        let result = new MyPlacesRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vendorId"] = this.vendorId;
        return data; 
    }
}

export interface IMyPlacesRequest {
    vendorId?: string | undefined;
}

export class MyQuestionsRequest implements IMyQuestionsRequest {
    pageNumber?: number;
    pageSize?: number;

    constructor(data?: IMyQuestionsRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageNumber = _data["pageNumber"];
            this.pageSize = _data["pageSize"];
        }
    }

    static fromJS(data: any): MyQuestionsRequest {
        data = typeof data === 'object' ? data : {};
        let result = new MyQuestionsRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageNumber"] = this.pageNumber;
        data["pageSize"] = this.pageSize;
        return data; 
    }
}

export interface IMyQuestionsRequest {
    pageNumber?: number;
    pageSize?: number;
}

export class ConsumerPostsResponse implements IConsumerPostsResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    posts?: ConsumerPost[] | undefined;

    constructor(data?: IConsumerPostsResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ErrorDto.fromJS(item));
            }
            this.isSuccess = _data["isSuccess"];
            if (Array.isArray(_data["posts"])) {
                this.posts = [] as any;
                for (let item of _data["posts"])
                    this.posts!.push(ConsumerPost.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ConsumerPostsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ConsumerPostsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        data["isSuccess"] = this.isSuccess;
        if (Array.isArray(this.posts)) {
            data["posts"] = [];
            for (let item of this.posts)
                data["posts"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IConsumerPostsResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    posts?: ConsumerPost[] | undefined;
}

export class ConsumerProfileRequest implements IConsumerProfileRequest {
    profilePath?: string | undefined;

    constructor(data?: IConsumerProfileRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.profilePath = _data["profilePath"];
        }
    }

    static fromJS(data: any): ConsumerProfileRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ConsumerProfileRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["profilePath"] = this.profilePath;
        return data; 
    }
}

export interface IConsumerProfileRequest {
    profilePath?: string | undefined;
}

export class ConsumerProfileResponse implements IConsumerProfileResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    consumerProfile?: ConsumerProfile;

    constructor(data?: IConsumerProfileResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ErrorDto.fromJS(item));
            }
            this.isSuccess = _data["isSuccess"];
            this.consumerProfile = _data["consumerProfile"] ? ConsumerProfile.fromJS(_data["consumerProfile"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ConsumerProfileResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ConsumerProfileResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        data["isSuccess"] = this.isSuccess;
        data["consumerProfile"] = this.consumerProfile ? this.consumerProfile.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IConsumerProfileResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    consumerProfile?: ConsumerProfile;
}

export class ConsumerProfileActivityRequest implements IConsumerProfileActivityRequest {
    consumerId?: string | undefined;
    pageNumber?: number;
    pageSize?: number;

    constructor(data?: IConsumerProfileActivityRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.consumerId = _data["consumerId"];
            this.pageNumber = _data["pageNumber"];
            this.pageSize = _data["pageSize"];
        }
    }

    static fromJS(data: any): ConsumerProfileActivityRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ConsumerProfileActivityRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["consumerId"] = this.consumerId;
        data["pageNumber"] = this.pageNumber;
        data["pageSize"] = this.pageSize;
        return data; 
    }
}

export interface IConsumerProfileActivityRequest {
    consumerId?: string | undefined;
    pageNumber?: number;
    pageSize?: number;
}

export class Review implements IReview {
    id?: string | undefined;
    createdDateUtc?: Date;
    lastUpdatedDateUtc?: Date;
    vendorId?: string | undefined;
    author?: NeatBoutiqueEntity;
    title?: string | undefined;
    body?: string | undefined;
    rating?: number;

    constructor(data?: IReview) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdDateUtc = _data["createdDateUtc"] ? new Date(_data["createdDateUtc"].toString()) : <any>undefined;
            this.lastUpdatedDateUtc = _data["lastUpdatedDateUtc"] ? new Date(_data["lastUpdatedDateUtc"].toString()) : <any>undefined;
            this.vendorId = _data["vendorId"];
            this.author = _data["author"] ? NeatBoutiqueEntity.fromJS(_data["author"]) : <any>undefined;
            this.title = _data["title"];
            this.body = _data["body"];
            this.rating = _data["rating"];
        }
    }

    static fromJS(data: any): Review {
        data = typeof data === 'object' ? data : {};
        let result = new Review();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdDateUtc"] = this.createdDateUtc ? this.createdDateUtc.toISOString() : <any>undefined;
        data["lastUpdatedDateUtc"] = this.lastUpdatedDateUtc ? this.lastUpdatedDateUtc.toISOString() : <any>undefined;
        data["vendorId"] = this.vendorId;
        data["author"] = this.author ? this.author.toJSON() : <any>undefined;
        data["title"] = this.title;
        data["body"] = this.body;
        data["rating"] = this.rating;
        return data; 
    }
}

export interface IReview {
    id?: string | undefined;
    createdDateUtc?: Date;
    lastUpdatedDateUtc?: Date;
    vendorId?: string | undefined;
    author?: NeatBoutiqueEntity;
    title?: string | undefined;
    body?: string | undefined;
    rating?: number;
}

export class ConsumerProfileActivityResponse implements IConsumerProfileActivityResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    recentQuestions?: ConsumerPost[] | undefined;
    recentAnswers?: ConsumerPost[] | undefined;
    recentReviews?: Review[] | undefined;
    questionsAskedCount?: number;
    questionsAnsweredCount?: number;
    reviewsCount?: number;

    constructor(data?: IConsumerProfileActivityResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ErrorDto.fromJS(item));
            }
            this.isSuccess = _data["isSuccess"];
            if (Array.isArray(_data["recentQuestions"])) {
                this.recentQuestions = [] as any;
                for (let item of _data["recentQuestions"])
                    this.recentQuestions!.push(ConsumerPost.fromJS(item));
            }
            if (Array.isArray(_data["recentAnswers"])) {
                this.recentAnswers = [] as any;
                for (let item of _data["recentAnswers"])
                    this.recentAnswers!.push(ConsumerPost.fromJS(item));
            }
            if (Array.isArray(_data["recentReviews"])) {
                this.recentReviews = [] as any;
                for (let item of _data["recentReviews"])
                    this.recentReviews!.push(Review.fromJS(item));
            }
            this.questionsAskedCount = _data["questionsAskedCount"];
            this.questionsAnsweredCount = _data["questionsAnsweredCount"];
            this.reviewsCount = _data["reviewsCount"];
        }
    }

    static fromJS(data: any): ConsumerProfileActivityResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ConsumerProfileActivityResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        data["isSuccess"] = this.isSuccess;
        if (Array.isArray(this.recentQuestions)) {
            data["recentQuestions"] = [];
            for (let item of this.recentQuestions)
                data["recentQuestions"].push(item.toJSON());
        }
        if (Array.isArray(this.recentAnswers)) {
            data["recentAnswers"] = [];
            for (let item of this.recentAnswers)
                data["recentAnswers"].push(item.toJSON());
        }
        if (Array.isArray(this.recentReviews)) {
            data["recentReviews"] = [];
            for (let item of this.recentReviews)
                data["recentReviews"].push(item.toJSON());
        }
        data["questionsAskedCount"] = this.questionsAskedCount;
        data["questionsAnsweredCount"] = this.questionsAnsweredCount;
        data["reviewsCount"] = this.reviewsCount;
        return data; 
    }
}

export interface IConsumerProfileActivityResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    recentQuestions?: ConsumerPost[] | undefined;
    recentAnswers?: ConsumerPost[] | undefined;
    recentReviews?: Review[] | undefined;
    questionsAskedCount?: number;
    questionsAnsweredCount?: number;
    reviewsCount?: number;
}

export class ConsumerImageRequest implements IConsumerImageRequest {
    base64Image?: string | undefined;

    constructor(data?: IConsumerImageRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.base64Image = _data["base64Image"];
        }
    }

    static fromJS(data: any): ConsumerImageRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ConsumerImageRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["base64Image"] = this.base64Image;
        return data; 
    }
}

export interface IConsumerImageRequest {
    base64Image?: string | undefined;
}

export class ConsumerDescriptionRequest implements IConsumerDescriptionRequest {
    description?: string | undefined;

    constructor(data?: IConsumerDescriptionRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): ConsumerDescriptionRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ConsumerDescriptionRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        return data; 
    }
}

export interface IConsumerDescriptionRequest {
    description?: string | undefined;
}

export class ConsumerBorderColorRequest implements IConsumerBorderColorRequest {
    borderColor?: string | undefined;

    constructor(data?: IConsumerBorderColorRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.borderColor = _data["borderColor"];
        }
    }

    static fromJS(data: any): ConsumerBorderColorRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ConsumerBorderColorRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["borderColor"] = this.borderColor;
        return data; 
    }
}

export interface IConsumerBorderColorRequest {
    borderColor?: string | undefined;
}

export class ConsumerNotificationSettingsRequest implements IConsumerNotificationSettingsRequest {
    notificationToken?: string | undefined;
    notificationCategories?: string[] | undefined;
    notificationsForAnsweredQuestions?: boolean;

    constructor(data?: IConsumerNotificationSettingsRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.notificationToken = _data["notificationToken"];
            if (Array.isArray(_data["notificationCategories"])) {
                this.notificationCategories = [] as any;
                for (let item of _data["notificationCategories"])
                    this.notificationCategories!.push(item);
            }
            this.notificationsForAnsweredQuestions = _data["notificationsForAnsweredQuestions"];
        }
    }

    static fromJS(data: any): ConsumerNotificationSettingsRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ConsumerNotificationSettingsRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["notificationToken"] = this.notificationToken;
        if (Array.isArray(this.notificationCategories)) {
            data["notificationCategories"] = [];
            for (let item of this.notificationCategories)
                data["notificationCategories"].push(item);
        }
        data["notificationsForAnsweredQuestions"] = this.notificationsForAnsweredQuestions;
        return data; 
    }
}

export interface IConsumerNotificationSettingsRequest {
    notificationToken?: string | undefined;
    notificationCategories?: string[] | undefined;
    notificationsForAnsweredQuestions?: boolean;
}

export class ConsumerFeedSettingsRequest implements IConsumerFeedSettingsRequest {
    feedCategoriesToShow?: string[] | undefined;

    constructor(data?: IConsumerFeedSettingsRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["feedCategoriesToShow"])) {
                this.feedCategoriesToShow = [] as any;
                for (let item of _data["feedCategoriesToShow"])
                    this.feedCategoriesToShow!.push(item);
            }
        }
    }

    static fromJS(data: any): ConsumerFeedSettingsRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ConsumerFeedSettingsRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.feedCategoriesToShow)) {
            data["feedCategoriesToShow"] = [];
            for (let item of this.feedCategoriesToShow)
                data["feedCategoriesToShow"].push(item);
        }
        return data; 
    }
}

export interface IConsumerFeedSettingsRequest {
    feedCategoriesToShow?: string[] | undefined;
}

export class ContactUsRequest implements IContactUsRequest {
    email?: string | undefined;
    name?: string | undefined;
    body?: string | undefined;
    reCaptchaToken?: string | undefined;

    constructor(data?: IContactUsRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.name = _data["name"];
            this.body = _data["body"];
            this.reCaptchaToken = _data["reCaptchaToken"];
        }
    }

    static fromJS(data: any): ContactUsRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ContactUsRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["name"] = this.name;
        data["body"] = this.body;
        data["reCaptchaToken"] = this.reCaptchaToken;
        return data; 
    }
}

export interface IContactUsRequest {
    email?: string | undefined;
    name?: string | undefined;
    body?: string | undefined;
    reCaptchaToken?: string | undefined;
}

export class VendorProfileRequest implements IVendorProfileRequest {
    vendorId?: string | undefined;
    profilePath?: string | undefined;

    constructor(data?: IVendorProfileRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.vendorId = _data["vendorId"];
            this.profilePath = _data["profilePath"];
        }
    }

    static fromJS(data: any): VendorProfileRequest {
        data = typeof data === 'object' ? data : {};
        let result = new VendorProfileRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vendorId"] = this.vendorId;
        data["profilePath"] = this.profilePath;
        return data; 
    }
}

export interface IVendorProfileRequest {
    vendorId?: string | undefined;
    profilePath?: string | undefined;
}

export class HeroAdTemplate implements IHeroAdTemplate {
    id?: string | undefined;
    createdDateUtc?: Date;
    lastUpdatedDateUtc?: Date;
    imageUrls?: string[] | undefined;
    adTaglines?: AdTagline[] | undefined;
    callsToAction?: string[] | undefined;
    communityName?: string | undefined;

    constructor(data?: IHeroAdTemplate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdDateUtc = _data["createdDateUtc"] ? new Date(_data["createdDateUtc"].toString()) : <any>undefined;
            this.lastUpdatedDateUtc = _data["lastUpdatedDateUtc"] ? new Date(_data["lastUpdatedDateUtc"].toString()) : <any>undefined;
            if (Array.isArray(_data["imageUrls"])) {
                this.imageUrls = [] as any;
                for (let item of _data["imageUrls"])
                    this.imageUrls!.push(item);
            }
            if (Array.isArray(_data["adTaglines"])) {
                this.adTaglines = [] as any;
                for (let item of _data["adTaglines"])
                    this.adTaglines!.push(AdTagline.fromJS(item));
            }
            if (Array.isArray(_data["callsToAction"])) {
                this.callsToAction = [] as any;
                for (let item of _data["callsToAction"])
                    this.callsToAction!.push(item);
            }
            this.communityName = _data["communityName"];
        }
    }

    static fromJS(data: any): HeroAdTemplate {
        data = typeof data === 'object' ? data : {};
        let result = new HeroAdTemplate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdDateUtc"] = this.createdDateUtc ? this.createdDateUtc.toISOString() : <any>undefined;
        data["lastUpdatedDateUtc"] = this.lastUpdatedDateUtc ? this.lastUpdatedDateUtc.toISOString() : <any>undefined;
        if (Array.isArray(this.imageUrls)) {
            data["imageUrls"] = [];
            for (let item of this.imageUrls)
                data["imageUrls"].push(item);
        }
        if (Array.isArray(this.adTaglines)) {
            data["adTaglines"] = [];
            for (let item of this.adTaglines)
                data["adTaglines"].push(item.toJSON());
        }
        if (Array.isArray(this.callsToAction)) {
            data["callsToAction"] = [];
            for (let item of this.callsToAction)
                data["callsToAction"].push(item);
        }
        data["communityName"] = this.communityName;
        return data; 
    }
}

export interface IHeroAdTemplate {
    id?: string | undefined;
    createdDateUtc?: Date;
    lastUpdatedDateUtc?: Date;
    imageUrls?: string[] | undefined;
    adTaglines?: AdTagline[] | undefined;
    callsToAction?: string[] | undefined;
    communityName?: string | undefined;
}

export class HeroAdTemplatesResponse implements IHeroAdTemplatesResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    templates?: HeroAdTemplate[] | undefined;

    constructor(data?: IHeroAdTemplatesResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ErrorDto.fromJS(item));
            }
            this.isSuccess = _data["isSuccess"];
            if (Array.isArray(_data["templates"])) {
                this.templates = [] as any;
                for (let item of _data["templates"])
                    this.templates!.push(HeroAdTemplate.fromJS(item));
            }
        }
    }

    static fromJS(data: any): HeroAdTemplatesResponse {
        data = typeof data === 'object' ? data : {};
        let result = new HeroAdTemplatesResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        data["isSuccess"] = this.isSuccess;
        if (Array.isArray(this.templates)) {
            data["templates"] = [];
            for (let item of this.templates)
                data["templates"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IHeroAdTemplatesResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    templates?: HeroAdTemplate[] | undefined;
}

export class CreateHeroAdRequest implements ICreateHeroAdRequest {
    communityName?: string | undefined;
    adTagline?: AdTagline;
    callToAction?: string | undefined;
    imageUrl?: string | undefined;
    vendorProfileId?: string | undefined;

    constructor(data?: ICreateHeroAdRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.communityName = _data["communityName"];
            this.adTagline = _data["adTagline"] ? AdTagline.fromJS(_data["adTagline"]) : <any>undefined;
            this.callToAction = _data["callToAction"];
            this.imageUrl = _data["imageUrl"];
            this.vendorProfileId = _data["vendorProfileId"];
        }
    }

    static fromJS(data: any): CreateHeroAdRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateHeroAdRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["communityName"] = this.communityName;
        data["adTagline"] = this.adTagline ? this.adTagline.toJSON() : <any>undefined;
        data["callToAction"] = this.callToAction;
        data["imageUrl"] = this.imageUrl;
        data["vendorProfileId"] = this.vendorProfileId;
        return data; 
    }
}

export interface ICreateHeroAdRequest {
    communityName?: string | undefined;
    adTagline?: AdTagline;
    callToAction?: string | undefined;
    imageUrl?: string | undefined;
    vendorProfileId?: string | undefined;
}

export class StripeCheckoutRequest implements IStripeCheckoutRequest {
    stripePriceId?: string | undefined;
    planTier?: string | undefined;
    promoCode?: string | undefined;
    vendorProfile?: VendorProfile;
    googlePlace?: GooglePlacesEntity;

    constructor(data?: IStripeCheckoutRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.stripePriceId = _data["stripePriceId"];
            this.planTier = _data["planTier"];
            this.promoCode = _data["promoCode"];
            this.vendorProfile = _data["vendorProfile"] ? VendorProfile.fromJS(_data["vendorProfile"]) : <any>undefined;
            this.googlePlace = _data["googlePlace"] ? GooglePlacesEntity.fromJS(_data["googlePlace"]) : <any>undefined;
        }
    }

    static fromJS(data: any): StripeCheckoutRequest {
        data = typeof data === 'object' ? data : {};
        let result = new StripeCheckoutRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["stripePriceId"] = this.stripePriceId;
        data["planTier"] = this.planTier;
        data["promoCode"] = this.promoCode;
        data["vendorProfile"] = this.vendorProfile ? this.vendorProfile.toJSON() : <any>undefined;
        data["googlePlace"] = this.googlePlace ? this.googlePlace.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IStripeCheckoutRequest {
    stripePriceId?: string | undefined;
    planTier?: string | undefined;
    promoCode?: string | undefined;
    vendorProfile?: VendorProfile;
    googlePlace?: GooglePlacesEntity;
}

export class StripeCheckoutResponse implements IStripeCheckoutResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    stripeSessionUrl?: string | undefined;
    isStripeBypassFreeForever?: boolean;

    constructor(data?: IStripeCheckoutResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ErrorDto.fromJS(item));
            }
            this.isSuccess = _data["isSuccess"];
            this.stripeSessionUrl = _data["stripeSessionUrl"];
            this.isStripeBypassFreeForever = _data["isStripeBypassFreeForever"];
        }
    }

    static fromJS(data: any): StripeCheckoutResponse {
        data = typeof data === 'object' ? data : {};
        let result = new StripeCheckoutResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        data["isSuccess"] = this.isSuccess;
        data["stripeSessionUrl"] = this.stripeSessionUrl;
        data["isStripeBypassFreeForever"] = this.isStripeBypassFreeForever;
        return data; 
    }
}

export interface IStripeCheckoutResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    stripeSessionUrl?: string | undefined;
    isStripeBypassFreeForever?: boolean;
}

export class PromoCodeReqeust implements IPromoCodeReqeust {
    promoCode?: string | undefined;

    constructor(data?: IPromoCodeReqeust) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.promoCode = _data["promoCode"];
        }
    }

    static fromJS(data: any): PromoCodeReqeust {
        data = typeof data === 'object' ? data : {};
        let result = new PromoCodeReqeust();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["promoCode"] = this.promoCode;
        return data; 
    }
}

export interface IPromoCodeReqeust {
    promoCode?: string | undefined;
}

export class PromotionalDiscount implements IPromotionalDiscount {
    id?: string | undefined;
    createdDateUtc?: Date;
    lastUpdatedDateUtc?: Date;
    promoCode?: string | undefined;
    message?: string | undefined;

    constructor(data?: IPromotionalDiscount) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdDateUtc = _data["createdDateUtc"] ? new Date(_data["createdDateUtc"].toString()) : <any>undefined;
            this.lastUpdatedDateUtc = _data["lastUpdatedDateUtc"] ? new Date(_data["lastUpdatedDateUtc"].toString()) : <any>undefined;
            this.promoCode = _data["promoCode"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): PromotionalDiscount {
        data = typeof data === 'object' ? data : {};
        let result = new PromotionalDiscount();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdDateUtc"] = this.createdDateUtc ? this.createdDateUtc.toISOString() : <any>undefined;
        data["lastUpdatedDateUtc"] = this.lastUpdatedDateUtc ? this.lastUpdatedDateUtc.toISOString() : <any>undefined;
        data["promoCode"] = this.promoCode;
        data["message"] = this.message;
        return data; 
    }
}

export interface IPromotionalDiscount {
    id?: string | undefined;
    createdDateUtc?: Date;
    lastUpdatedDateUtc?: Date;
    promoCode?: string | undefined;
    message?: string | undefined;
}

export class PromotionalDiscountResponse implements IPromotionalDiscountResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    promotionalDiscount?: PromotionalDiscount;

    constructor(data?: IPromotionalDiscountResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ErrorDto.fromJS(item));
            }
            this.isSuccess = _data["isSuccess"];
            this.promotionalDiscount = _data["promotionalDiscount"] ? PromotionalDiscount.fromJS(_data["promotionalDiscount"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PromotionalDiscountResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PromotionalDiscountResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        data["isSuccess"] = this.isSuccess;
        data["promotionalDiscount"] = this.promotionalDiscount ? this.promotionalDiscount.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IPromotionalDiscountResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    promotionalDiscount?: PromotionalDiscount;
}

export class CreatePromotionalDiscountRequest implements ICreatePromotionalDiscountRequest {
    message?: string | undefined;

    constructor(data?: ICreatePromotionalDiscountRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): CreatePromotionalDiscountRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePromotionalDiscountRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message;
        return data; 
    }
}

export interface ICreatePromotionalDiscountRequest {
    message?: string | undefined;
}

export class ChangeVendorSubscriptionRequest implements IChangeVendorSubscriptionRequest {
    stripePriceId?: string | undefined;
    vendorProfileId?: string | undefined;

    constructor(data?: IChangeVendorSubscriptionRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.stripePriceId = _data["stripePriceId"];
            this.vendorProfileId = _data["vendorProfileId"];
        }
    }

    static fromJS(data: any): ChangeVendorSubscriptionRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeVendorSubscriptionRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["stripePriceId"] = this.stripePriceId;
        data["vendorProfileId"] = this.vendorProfileId;
        return data; 
    }
}

export interface IChangeVendorSubscriptionRequest {
    stripePriceId?: string | undefined;
    vendorProfileId?: string | undefined;
}

export class VendorProfileResponse implements IVendorProfileResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    vendorProfile?: VendorProfile;

    constructor(data?: IVendorProfileResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ErrorDto.fromJS(item));
            }
            this.isSuccess = _data["isSuccess"];
            this.vendorProfile = _data["vendorProfile"] ? VendorProfile.fromJS(_data["vendorProfile"]) : <any>undefined;
        }
    }

    static fromJS(data: any): VendorProfileResponse {
        data = typeof data === 'object' ? data : {};
        let result = new VendorProfileResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        data["isSuccess"] = this.isSuccess;
        data["vendorProfile"] = this.vendorProfile ? this.vendorProfile.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IVendorProfileResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    vendorProfile?: VendorProfile;
}

export class VendorProfileCancelRequest implements IVendorProfileCancelRequest {
    vendorProfileId?: string | undefined;

    constructor(data?: IVendorProfileCancelRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.vendorProfileId = _data["vendorProfileId"];
        }
    }

    static fromJS(data: any): VendorProfileCancelRequest {
        data = typeof data === 'object' ? data : {};
        let result = new VendorProfileCancelRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vendorProfileId"] = this.vendorProfileId;
        return data; 
    }
}

export interface IVendorProfileCancelRequest {
    vendorProfileId?: string | undefined;
}

export class VendorSubscriptionResponse implements IVendorSubscriptionResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    vendorSubscriptionId?: string | undefined;

    constructor(data?: IVendorSubscriptionResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ErrorDto.fromJS(item));
            }
            this.isSuccess = _data["isSuccess"];
            this.vendorSubscriptionId = _data["vendorSubscriptionId"];
        }
    }

    static fromJS(data: any): VendorSubscriptionResponse {
        data = typeof data === 'object' ? data : {};
        let result = new VendorSubscriptionResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        data["isSuccess"] = this.isSuccess;
        data["vendorSubscriptionId"] = this.vendorSubscriptionId;
        return data; 
    }
}

export interface IVendorSubscriptionResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    vendorSubscriptionId?: string | undefined;
}

export class VendorPostRequest implements IVendorPostRequest {
    post?: VendorPost;

    constructor(data?: IVendorPostRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.post = _data["post"] ? VendorPost.fromJS(_data["post"]) : <any>undefined;
        }
    }

    static fromJS(data: any): VendorPostRequest {
        data = typeof data === 'object' ? data : {};
        let result = new VendorPostRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["post"] = this.post ? this.post.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IVendorPostRequest {
    post?: VendorPost;
}

export class VendorPostResponse implements IVendorPostResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    post?: VendorPost;

    constructor(data?: IVendorPostResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ErrorDto.fromJS(item));
            }
            this.isSuccess = _data["isSuccess"];
            this.post = _data["post"] ? VendorPost.fromJS(_data["post"]) : <any>undefined;
        }
    }

    static fromJS(data: any): VendorPostResponse {
        data = typeof data === 'object' ? data : {};
        let result = new VendorPostResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        data["isSuccess"] = this.isSuccess;
        data["post"] = this.post ? this.post.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IVendorPostResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    post?: VendorPost;
}

export class PollAnswerRequest implements IPollAnswerRequest {
    postId?: string | undefined;
    pollAnswerId?: string | undefined;

    constructor(data?: IPollAnswerRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.postId = _data["postId"];
            this.pollAnswerId = _data["pollAnswerId"];
        }
    }

    static fromJS(data: any): PollAnswerRequest {
        data = typeof data === 'object' ? data : {};
        let result = new PollAnswerRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["postId"] = this.postId;
        data["pollAnswerId"] = this.pollAnswerId;
        return data; 
    }
}

export interface IPollAnswerRequest {
    postId?: string | undefined;
    pollAnswerId?: string | undefined;
}

export class PollAnswerResponse implements IPollAnswerResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    pollAnswer?: PollAnswer;

    constructor(data?: IPollAnswerResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ErrorDto.fromJS(item));
            }
            this.isSuccess = _data["isSuccess"];
            this.pollAnswer = _data["pollAnswer"] ? PollAnswer.fromJS(_data["pollAnswer"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PollAnswerResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PollAnswerResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        data["isSuccess"] = this.isSuccess;
        data["pollAnswer"] = this.pollAnswer ? this.pollAnswer.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IPollAnswerResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    pollAnswer?: PollAnswer;
}

export class ReviewsResponse implements IReviewsResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    reviews?: Review[] | undefined;

    constructor(data?: IReviewsResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ErrorDto.fromJS(item));
            }
            this.isSuccess = _data["isSuccess"];
            if (Array.isArray(_data["reviews"])) {
                this.reviews = [] as any;
                for (let item of _data["reviews"])
                    this.reviews!.push(Review.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ReviewsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ReviewsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        data["isSuccess"] = this.isSuccess;
        if (Array.isArray(this.reviews)) {
            data["reviews"] = [];
            for (let item of this.reviews)
                data["reviews"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IReviewsResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    reviews?: Review[] | undefined;
}

export class ReviewRequest implements IReviewRequest {
    vendorId?: string | undefined;
    title?: string | undefined;
    body?: string | undefined;
    rating?: number;
    authorId?: string | undefined;

    constructor(data?: IReviewRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.vendorId = _data["vendorId"];
            this.title = _data["title"];
            this.body = _data["body"];
            this.rating = _data["rating"];
            this.authorId = _data["authorId"];
        }
    }

    static fromJS(data: any): ReviewRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ReviewRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vendorId"] = this.vendorId;
        data["title"] = this.title;
        data["body"] = this.body;
        data["rating"] = this.rating;
        data["authorId"] = this.authorId;
        return data; 
    }
}

export interface IReviewRequest {
    vendorId?: string | undefined;
    title?: string | undefined;
    body?: string | undefined;
    rating?: number;
    authorId?: string | undefined;
}

export class ReviewResponse implements IReviewResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    review?: Review;

    constructor(data?: IReviewResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ErrorDto.fromJS(item));
            }
            this.isSuccess = _data["isSuccess"];
            this.review = _data["review"] ? Review.fromJS(_data["review"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ReviewResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ReviewResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        data["isSuccess"] = this.isSuccess;
        data["review"] = this.review ? this.review.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IReviewResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    review?: Review;
}

export class ReviewRemoveRequest implements IReviewRemoveRequest {
    reviewId?: string | undefined;
    authorId?: string | undefined;

    constructor(data?: IReviewRemoveRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.reviewId = _data["reviewId"];
            this.authorId = _data["authorId"];
        }
    }

    static fromJS(data: any): ReviewRemoveRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ReviewRemoveRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reviewId"] = this.reviewId;
        data["authorId"] = this.authorId;
        return data; 
    }
}

export interface IReviewRemoveRequest {
    reviewId?: string | undefined;
    authorId?: string | undefined;
}

export class ReviewUpdateRequest implements IReviewUpdateRequest {
    reviewId?: string | undefined;
    authorId?: string | undefined;
    body?: string | undefined;
    title?: string | undefined;
    rating?: number;

    constructor(data?: IReviewUpdateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.reviewId = _data["reviewId"];
            this.authorId = _data["authorId"];
            this.body = _data["body"];
            this.title = _data["title"];
            this.rating = _data["rating"];
        }
    }

    static fromJS(data: any): ReviewUpdateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ReviewUpdateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reviewId"] = this.reviewId;
        data["authorId"] = this.authorId;
        data["body"] = this.body;
        data["title"] = this.title;
        data["rating"] = this.rating;
        return data; 
    }
}

export interface IReviewUpdateRequest {
    reviewId?: string | undefined;
    authorId?: string | undefined;
    body?: string | undefined;
    title?: string | undefined;
    rating?: number;
}

export class AnswerSearchRequest implements IAnswerSearchRequest {
    communityName?: string | undefined;
    searchString?: string | undefined;

    constructor(data?: IAnswerSearchRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.communityName = _data["communityName"];
            this.searchString = _data["searchString"];
        }
    }

    static fromJS(data: any): AnswerSearchRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AnswerSearchRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["communityName"] = this.communityName;
        data["searchString"] = this.searchString;
        return data; 
    }
}

export interface IAnswerSearchRequest {
    communityName?: string | undefined;
    searchString?: string | undefined;
}

export class AnswerSearchResponse implements IAnswerSearchResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    vendors?: NeatBoutiqueEntity[] | undefined;
    googlePlaces?: GooglePlacesEntity[] | undefined;

    constructor(data?: IAnswerSearchResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ErrorDto.fromJS(item));
            }
            this.isSuccess = _data["isSuccess"];
            if (Array.isArray(_data["vendors"])) {
                this.vendors = [] as any;
                for (let item of _data["vendors"])
                    this.vendors!.push(NeatBoutiqueEntity.fromJS(item));
            }
            if (Array.isArray(_data["googlePlaces"])) {
                this.googlePlaces = [] as any;
                for (let item of _data["googlePlaces"])
                    this.googlePlaces!.push(GooglePlacesEntity.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AnswerSearchResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AnswerSearchResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        data["isSuccess"] = this.isSuccess;
        if (Array.isArray(this.vendors)) {
            data["vendors"] = [];
            for (let item of this.vendors)
                data["vendors"].push(item.toJSON());
        }
        if (Array.isArray(this.googlePlaces)) {
            data["googlePlaces"] = [];
            for (let item of this.googlePlaces)
                data["googlePlaces"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IAnswerSearchResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    vendors?: NeatBoutiqueEntity[] | undefined;
    googlePlaces?: GooglePlacesEntity[] | undefined;
}

export class GooglePlacesSearchRequest implements IGooglePlacesSearchRequest {
    searchString?: string | undefined;

    constructor(data?: IGooglePlacesSearchRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.searchString = _data["searchString"];
        }
    }

    static fromJS(data: any): GooglePlacesSearchRequest {
        data = typeof data === 'object' ? data : {};
        let result = new GooglePlacesSearchRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchString"] = this.searchString;
        return data; 
    }
}

export interface IGooglePlacesSearchRequest {
    searchString?: string | undefined;
}

export class GooglePlaceSearchResponse implements IGooglePlaceSearchResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    googlePlaces?: GooglePlacesEntity[] | undefined;
    googleSearchSessionToken?: string | undefined;

    constructor(data?: IGooglePlaceSearchResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ErrorDto.fromJS(item));
            }
            this.isSuccess = _data["isSuccess"];
            if (Array.isArray(_data["googlePlaces"])) {
                this.googlePlaces = [] as any;
                for (let item of _data["googlePlaces"])
                    this.googlePlaces!.push(GooglePlacesEntity.fromJS(item));
            }
            this.googleSearchSessionToken = _data["googleSearchSessionToken"];
        }
    }

    static fromJS(data: any): GooglePlaceSearchResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GooglePlaceSearchResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        data["isSuccess"] = this.isSuccess;
        if (Array.isArray(this.googlePlaces)) {
            data["googlePlaces"] = [];
            for (let item of this.googlePlaces)
                data["googlePlaces"].push(item.toJSON());
        }
        data["googleSearchSessionToken"] = this.googleSearchSessionToken;
        return data; 
    }
}

export interface IGooglePlaceSearchResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    googlePlaces?: GooglePlacesEntity[] | undefined;
    googleSearchSessionToken?: string | undefined;
}

export class GooglePlaceRequest implements IGooglePlaceRequest {
    googlePlace?: GooglePlacesEntity;
    googleSearchSessionToken?: string | undefined;

    constructor(data?: IGooglePlaceRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.googlePlace = _data["googlePlace"] ? GooglePlacesEntity.fromJS(_data["googlePlace"]) : <any>undefined;
            this.googleSearchSessionToken = _data["googleSearchSessionToken"];
        }
    }

    static fromJS(data: any): GooglePlaceRequest {
        data = typeof data === 'object' ? data : {};
        let result = new GooglePlaceRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["googlePlace"] = this.googlePlace ? this.googlePlace.toJSON() : <any>undefined;
        data["googleSearchSessionToken"] = this.googleSearchSessionToken;
        return data; 
    }
}

export interface IGooglePlaceRequest {
    googlePlace?: GooglePlacesEntity;
    googleSearchSessionToken?: string | undefined;
}

export class GooglePlaceDetailsResponse implements IGooglePlaceDetailsResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    name?: string | undefined;
    formattedAddress?: string | undefined;
    phoneNumber?: string | undefined;
    websiteURL?: string | undefined;

    constructor(data?: IGooglePlaceDetailsResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ErrorDto.fromJS(item));
            }
            this.isSuccess = _data["isSuccess"];
            this.name = _data["name"];
            this.formattedAddress = _data["formattedAddress"];
            this.phoneNumber = _data["phoneNumber"];
            this.websiteURL = _data["websiteURL"];
        }
    }

    static fromJS(data: any): GooglePlaceDetailsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GooglePlaceDetailsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        data["isSuccess"] = this.isSuccess;
        data["name"] = this.name;
        data["formattedAddress"] = this.formattedAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["websiteURL"] = this.websiteURL;
        return data; 
    }
}

export interface IGooglePlaceDetailsResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    name?: string | undefined;
    formattedAddress?: string | undefined;
    phoneNumber?: string | undefined;
    websiteURL?: string | undefined;
}

export class NeatBoutiqueSettings implements INeatBoutiqueSettings {
    reCaptchaSecretKey?: string | undefined;
    consumerPostsPerVendorPostCount?: number;
    heroAdsPerPage?: number;
    neatBoutiqueFrontEndBaseUrl?: string | undefined;
    neatBoutiqueBackEndBaseUrl?: string | undefined;
    environment?: string | undefined;

    constructor(data?: INeatBoutiqueSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.reCaptchaSecretKey = _data["reCaptchaSecretKey"];
            this.consumerPostsPerVendorPostCount = _data["consumerPostsPerVendorPostCount"];
            this.heroAdsPerPage = _data["heroAdsPerPage"];
            this.neatBoutiqueFrontEndBaseUrl = _data["neatBoutiqueFrontEndBaseUrl"];
            this.neatBoutiqueBackEndBaseUrl = _data["neatBoutiqueBackEndBaseUrl"];
            this.environment = _data["environment"];
        }
    }

    static fromJS(data: any): NeatBoutiqueSettings {
        data = typeof data === 'object' ? data : {};
        let result = new NeatBoutiqueSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reCaptchaSecretKey"] = this.reCaptchaSecretKey;
        data["consumerPostsPerVendorPostCount"] = this.consumerPostsPerVendorPostCount;
        data["heroAdsPerPage"] = this.heroAdsPerPage;
        data["neatBoutiqueFrontEndBaseUrl"] = this.neatBoutiqueFrontEndBaseUrl;
        data["neatBoutiqueBackEndBaseUrl"] = this.neatBoutiqueBackEndBaseUrl;
        data["environment"] = this.environment;
        return data; 
    }
}

export interface INeatBoutiqueSettings {
    reCaptchaSecretKey?: string | undefined;
    consumerPostsPerVendorPostCount?: number;
    heroAdsPerPage?: number;
    neatBoutiqueFrontEndBaseUrl?: string | undefined;
    neatBoutiqueBackEndBaseUrl?: string | undefined;
    environment?: string | undefined;
}

export class GoogleCloudPlatformSettings implements IGoogleCloudPlatformSettings {
    placesKey?: string | undefined;
    storageBucket?: string | undefined;
    storageVendorPhotosFolder?: string | undefined;
    storageVendorLogosFolder?: string | undefined;
    storageConsumerImageFolder?: string | undefined;
    storageBaseURL?: string | undefined;
    storageHeroAdFolder?: string | undefined;

    constructor(data?: IGoogleCloudPlatformSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.placesKey = _data["placesKey"];
            this.storageBucket = _data["storageBucket"];
            this.storageVendorPhotosFolder = _data["storageVendorPhotosFolder"];
            this.storageVendorLogosFolder = _data["storageVendorLogosFolder"];
            this.storageConsumerImageFolder = _data["storageConsumerImageFolder"];
            this.storageBaseURL = _data["storageBaseURL"];
            this.storageHeroAdFolder = _data["storageHeroAdFolder"];
        }
    }

    static fromJS(data: any): GoogleCloudPlatformSettings {
        data = typeof data === 'object' ? data : {};
        let result = new GoogleCloudPlatformSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["placesKey"] = this.placesKey;
        data["storageBucket"] = this.storageBucket;
        data["storageVendorPhotosFolder"] = this.storageVendorPhotosFolder;
        data["storageVendorLogosFolder"] = this.storageVendorLogosFolder;
        data["storageConsumerImageFolder"] = this.storageConsumerImageFolder;
        data["storageBaseURL"] = this.storageBaseURL;
        data["storageHeroAdFolder"] = this.storageHeroAdFolder;
        return data; 
    }
}

export interface IGoogleCloudPlatformSettings {
    placesKey?: string | undefined;
    storageBucket?: string | undefined;
    storageVendorPhotosFolder?: string | undefined;
    storageVendorLogosFolder?: string | undefined;
    storageConsumerImageFolder?: string | undefined;
    storageBaseURL?: string | undefined;
    storageHeroAdFolder?: string | undefined;
}

export class MongoDbSettings implements IMongoDbSettings {
    databaseConnectionString?: string | undefined;
    dbName?: string | undefined;
    consumerPostsCollectionName?: string | undefined;
    vendorPostsCollectionName?: string | undefined;
    commentsCollectionName?: string | undefined;
    answersCollectionName?: string | undefined;
    answerVotesCollectionName?: string | undefined;
    consumerProfilesCollectionName?: string | undefined;
    vendorProfilesCollectionName?: string | undefined;
    accountsCollectionName?: string | undefined;
    reviewsCollectionName?: string | undefined;
    heroAdsCollectionName?: string | undefined;
    heroAdTemplatesCollectionName?: string | undefined;
    vendorSubscriptionSessionCollectionName?: string | undefined;
    promotionalDiscountsCollectionName?: string | undefined;
    notificationTokensCollectionName?: string | undefined;

    constructor(data?: IMongoDbSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.databaseConnectionString = _data["databaseConnectionString"];
            this.dbName = _data["dbName"];
            this.consumerPostsCollectionName = _data["consumerPostsCollectionName"];
            this.vendorPostsCollectionName = _data["vendorPostsCollectionName"];
            this.commentsCollectionName = _data["commentsCollectionName"];
            this.answersCollectionName = _data["answersCollectionName"];
            this.answerVotesCollectionName = _data["answerVotesCollectionName"];
            this.consumerProfilesCollectionName = _data["consumerProfilesCollectionName"];
            this.vendorProfilesCollectionName = _data["vendorProfilesCollectionName"];
            this.accountsCollectionName = _data["accountsCollectionName"];
            this.reviewsCollectionName = _data["reviewsCollectionName"];
            this.heroAdsCollectionName = _data["heroAdsCollectionName"];
            this.heroAdTemplatesCollectionName = _data["heroAdTemplatesCollectionName"];
            this.vendorSubscriptionSessionCollectionName = _data["vendorSubscriptionSessionCollectionName"];
            this.promotionalDiscountsCollectionName = _data["promotionalDiscountsCollectionName"];
            this.notificationTokensCollectionName = _data["notificationTokensCollectionName"];
        }
    }

    static fromJS(data: any): MongoDbSettings {
        data = typeof data === 'object' ? data : {};
        let result = new MongoDbSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["databaseConnectionString"] = this.databaseConnectionString;
        data["dbName"] = this.dbName;
        data["consumerPostsCollectionName"] = this.consumerPostsCollectionName;
        data["vendorPostsCollectionName"] = this.vendorPostsCollectionName;
        data["commentsCollectionName"] = this.commentsCollectionName;
        data["answersCollectionName"] = this.answersCollectionName;
        data["answerVotesCollectionName"] = this.answerVotesCollectionName;
        data["consumerProfilesCollectionName"] = this.consumerProfilesCollectionName;
        data["vendorProfilesCollectionName"] = this.vendorProfilesCollectionName;
        data["accountsCollectionName"] = this.accountsCollectionName;
        data["reviewsCollectionName"] = this.reviewsCollectionName;
        data["heroAdsCollectionName"] = this.heroAdsCollectionName;
        data["heroAdTemplatesCollectionName"] = this.heroAdTemplatesCollectionName;
        data["vendorSubscriptionSessionCollectionName"] = this.vendorSubscriptionSessionCollectionName;
        data["promotionalDiscountsCollectionName"] = this.promotionalDiscountsCollectionName;
        data["notificationTokensCollectionName"] = this.notificationTokensCollectionName;
        return data; 
    }
}

export interface IMongoDbSettings {
    databaseConnectionString?: string | undefined;
    dbName?: string | undefined;
    consumerPostsCollectionName?: string | undefined;
    vendorPostsCollectionName?: string | undefined;
    commentsCollectionName?: string | undefined;
    answersCollectionName?: string | undefined;
    answerVotesCollectionName?: string | undefined;
    consumerProfilesCollectionName?: string | undefined;
    vendorProfilesCollectionName?: string | undefined;
    accountsCollectionName?: string | undefined;
    reviewsCollectionName?: string | undefined;
    heroAdsCollectionName?: string | undefined;
    heroAdTemplatesCollectionName?: string | undefined;
    vendorSubscriptionSessionCollectionName?: string | undefined;
    promotionalDiscountsCollectionName?: string | undefined;
    notificationTokensCollectionName?: string | undefined;
}

export class StripeSettings implements IStripeSettings {
    publishableKey?: string | undefined;
    secretKey?: string | undefined;
    webHookSecret?: string | undefined;
    couponCode3FreeMonths?: string | undefined;
    couponCode6FreeMonths?: string | undefined;
    couponCodeFreeForever?: string | undefined;
    couponCode3FreeMonthsGF?: string | undefined;
    couponCode6FreeMonthsGF?: string | undefined;
    couponCodeFreeForeverGF?: string | undefined;
    stripeBypassFreeForeverId?: string | undefined;

    constructor(data?: IStripeSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.publishableKey = _data["publishableKey"];
            this.secretKey = _data["secretKey"];
            this.webHookSecret = _data["webHookSecret"];
            this.couponCode3FreeMonths = _data["couponCode3FreeMonths"];
            this.couponCode6FreeMonths = _data["couponCode6FreeMonths"];
            this.couponCodeFreeForever = _data["couponCodeFreeForever"];
            this.couponCode3FreeMonthsGF = _data["couponCode3FreeMonthsGF"];
            this.couponCode6FreeMonthsGF = _data["couponCode6FreeMonthsGF"];
            this.couponCodeFreeForeverGF = _data["couponCodeFreeForeverGF"];
            this.stripeBypassFreeForeverId = _data["stripeBypassFreeForeverId"];
        }
    }

    static fromJS(data: any): StripeSettings {
        data = typeof data === 'object' ? data : {};
        let result = new StripeSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["publishableKey"] = this.publishableKey;
        data["secretKey"] = this.secretKey;
        data["webHookSecret"] = this.webHookSecret;
        data["couponCode3FreeMonths"] = this.couponCode3FreeMonths;
        data["couponCode6FreeMonths"] = this.couponCode6FreeMonths;
        data["couponCodeFreeForever"] = this.couponCodeFreeForever;
        data["couponCode3FreeMonthsGF"] = this.couponCode3FreeMonthsGF;
        data["couponCode6FreeMonthsGF"] = this.couponCode6FreeMonthsGF;
        data["couponCodeFreeForeverGF"] = this.couponCodeFreeForeverGF;
        data["stripeBypassFreeForeverId"] = this.stripeBypassFreeForeverId;
        return data; 
    }
}

export interface IStripeSettings {
    publishableKey?: string | undefined;
    secretKey?: string | undefined;
    webHookSecret?: string | undefined;
    couponCode3FreeMonths?: string | undefined;
    couponCode6FreeMonths?: string | undefined;
    couponCodeFreeForever?: string | undefined;
    couponCode3FreeMonthsGF?: string | undefined;
    couponCode6FreeMonthsGF?: string | undefined;
    couponCodeFreeForeverGF?: string | undefined;
    stripeBypassFreeForeverId?: string | undefined;
}

export class Settings implements ISettings {
    neatBoutiqueSettings?: NeatBoutiqueSettings;
    googleCloudPlatformSettings?: GoogleCloudPlatformSettings;
    mongoDbSettings?: MongoDbSettings;
    stripeSettings?: StripeSettings;
    projectId?: string | undefined;

    constructor(data?: ISettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.neatBoutiqueSettings = _data["neatBoutiqueSettings"] ? NeatBoutiqueSettings.fromJS(_data["neatBoutiqueSettings"]) : <any>undefined;
            this.googleCloudPlatformSettings = _data["googleCloudPlatformSettings"] ? GoogleCloudPlatformSettings.fromJS(_data["googleCloudPlatformSettings"]) : <any>undefined;
            this.mongoDbSettings = _data["mongoDbSettings"] ? MongoDbSettings.fromJS(_data["mongoDbSettings"]) : <any>undefined;
            this.stripeSettings = _data["stripeSettings"] ? StripeSettings.fromJS(_data["stripeSettings"]) : <any>undefined;
            this.projectId = _data["projectId"];
        }
    }

    static fromJS(data: any): Settings {
        data = typeof data === 'object' ? data : {};
        let result = new Settings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["neatBoutiqueSettings"] = this.neatBoutiqueSettings ? this.neatBoutiqueSettings.toJSON() : <any>undefined;
        data["googleCloudPlatformSettings"] = this.googleCloudPlatformSettings ? this.googleCloudPlatformSettings.toJSON() : <any>undefined;
        data["mongoDbSettings"] = this.mongoDbSettings ? this.mongoDbSettings.toJSON() : <any>undefined;
        data["stripeSettings"] = this.stripeSettings ? this.stripeSettings.toJSON() : <any>undefined;
        data["projectId"] = this.projectId;
        return data; 
    }
}

export interface ISettings {
    neatBoutiqueSettings?: NeatBoutiqueSettings;
    googleCloudPlatformSettings?: GoogleCloudPlatformSettings;
    mongoDbSettings?: MongoDbSettings;
    stripeSettings?: StripeSettings;
    projectId?: string | undefined;
}

export class VendorProfilesRequest implements IVendorProfilesRequest {
    communityName?: string | undefined;
    pageNumber?: number;
    pageSize?: number;

    constructor(data?: IVendorProfilesRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.communityName = _data["communityName"];
            this.pageNumber = _data["pageNumber"];
            this.pageSize = _data["pageSize"];
        }
    }

    static fromJS(data: any): VendorProfilesRequest {
        data = typeof data === 'object' ? data : {};
        let result = new VendorProfilesRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["communityName"] = this.communityName;
        data["pageNumber"] = this.pageNumber;
        data["pageSize"] = this.pageSize;
        return data; 
    }
}

export interface IVendorProfilesRequest {
    communityName?: string | undefined;
    pageNumber?: number;
    pageSize?: number;
}

export class VendorProfilesResponse implements IVendorProfilesResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    vendorProfiles?: VendorProfile[] | undefined;

    constructor(data?: IVendorProfilesResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ErrorDto.fromJS(item));
            }
            this.isSuccess = _data["isSuccess"];
            if (Array.isArray(_data["vendorProfiles"])) {
                this.vendorProfiles = [] as any;
                for (let item of _data["vendorProfiles"])
                    this.vendorProfiles!.push(VendorProfile.fromJS(item));
            }
        }
    }

    static fromJS(data: any): VendorProfilesResponse {
        data = typeof data === 'object' ? data : {};
        let result = new VendorProfilesResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        data["isSuccess"] = this.isSuccess;
        if (Array.isArray(this.vendorProfiles)) {
            data["vendorProfiles"] = [];
            for (let item of this.vendorProfiles)
                data["vendorProfiles"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IVendorProfilesResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    vendorProfiles?: VendorProfile[] | undefined;
}

export class VendorProfileWithReviewsResponse implements IVendorProfileWithReviewsResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    vendorProfile?: VendorProfile;
    reviews?: Review[] | undefined;

    constructor(data?: IVendorProfileWithReviewsResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ErrorDto.fromJS(item));
            }
            this.isSuccess = _data["isSuccess"];
            this.vendorProfile = _data["vendorProfile"] ? VendorProfile.fromJS(_data["vendorProfile"]) : <any>undefined;
            if (Array.isArray(_data["reviews"])) {
                this.reviews = [] as any;
                for (let item of _data["reviews"])
                    this.reviews!.push(Review.fromJS(item));
            }
        }
    }

    static fromJS(data: any): VendorProfileWithReviewsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new VendorProfileWithReviewsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        data["isSuccess"] = this.isSuccess;
        data["vendorProfile"] = this.vendorProfile ? this.vendorProfile.toJSON() : <any>undefined;
        if (Array.isArray(this.reviews)) {
            data["reviews"] = [];
            for (let item of this.reviews)
                data["reviews"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IVendorProfileWithReviewsResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    vendorProfile?: VendorProfile;
    reviews?: Review[] | undefined;
}

export class GetVendorProfileByInfoRequest implements IGetVendorProfileByInfoRequest {
    vendorProfile?: VendorProfile;
    googlePlace?: GooglePlacesEntity;

    constructor(data?: IGetVendorProfileByInfoRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.vendorProfile = _data["vendorProfile"] ? VendorProfile.fromJS(_data["vendorProfile"]) : <any>undefined;
            this.googlePlace = _data["googlePlace"] ? GooglePlacesEntity.fromJS(_data["googlePlace"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetVendorProfileByInfoRequest {
        data = typeof data === 'object' ? data : {};
        let result = new GetVendorProfileByInfoRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vendorProfile"] = this.vendorProfile ? this.vendorProfile.toJSON() : <any>undefined;
        data["googlePlace"] = this.googlePlace ? this.googlePlace.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetVendorProfileByInfoRequest {
    vendorProfile?: VendorProfile;
    googlePlace?: GooglePlacesEntity;
}

export class VendorImageRequest implements IVendorImageRequest {
    vendorId?: string | undefined;
    base64Image?: string | undefined;
    photoPosition?: number;

    constructor(data?: IVendorImageRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.vendorId = _data["vendorId"];
            this.base64Image = _data["base64Image"];
            this.photoPosition = _data["photoPosition"];
        }
    }

    static fromJS(data: any): VendorImageRequest {
        data = typeof data === 'object' ? data : {};
        let result = new VendorImageRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vendorId"] = this.vendorId;
        data["base64Image"] = this.base64Image;
        data["photoPosition"] = this.photoPosition;
        return data; 
    }
}

export interface IVendorImageRequest {
    vendorId?: string | undefined;
    base64Image?: string | undefined;
    photoPosition?: number;
}

export class VendorDescriptionRequest implements IVendorDescriptionRequest {
    vendorId?: string | undefined;
    description?: string | undefined;

    constructor(data?: IVendorDescriptionRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.vendorId = _data["vendorId"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): VendorDescriptionRequest {
        data = typeof data === 'object' ? data : {};
        let result = new VendorDescriptionRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vendorId"] = this.vendorId;
        data["description"] = this.description;
        return data; 
    }
}

export interface IVendorDescriptionRequest {
    vendorId?: string | undefined;
    description?: string | undefined;
}

export class VendorSocialLinksRequest implements IVendorSocialLinksRequest {
    vendorId?: string | undefined;
    facebookURL?: string | undefined;
    instagramURL?: string | undefined;
    twitterURL?: string | undefined;

    constructor(data?: IVendorSocialLinksRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.vendorId = _data["vendorId"];
            this.facebookURL = _data["facebookURL"];
            this.instagramURL = _data["instagramURL"];
            this.twitterURL = _data["twitterURL"];
        }
    }

    static fromJS(data: any): VendorSocialLinksRequest {
        data = typeof data === 'object' ? data : {};
        let result = new VendorSocialLinksRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vendorId"] = this.vendorId;
        data["facebookURL"] = this.facebookURL;
        data["instagramURL"] = this.instagramURL;
        data["twitterURL"] = this.twitterURL;
        return data; 
    }
}

export interface IVendorSocialLinksRequest {
    vendorId?: string | undefined;
    facebookURL?: string | undefined;
    instagramURL?: string | undefined;
    twitterURL?: string | undefined;
}

export class VendorCommunitiesRequest implements IVendorCommunitiesRequest {
    vendorId?: string | undefined;
    communities?: string[] | undefined;

    constructor(data?: IVendorCommunitiesRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.vendorId = _data["vendorId"];
            if (Array.isArray(_data["communities"])) {
                this.communities = [] as any;
                for (let item of _data["communities"])
                    this.communities!.push(item);
            }
        }
    }

    static fromJS(data: any): VendorCommunitiesRequest {
        data = typeof data === 'object' ? data : {};
        let result = new VendorCommunitiesRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vendorId"] = this.vendorId;
        if (Array.isArray(this.communities)) {
            data["communities"] = [];
            for (let item of this.communities)
                data["communities"].push(item);
        }
        return data; 
    }
}

export interface IVendorCommunitiesRequest {
    vendorId?: string | undefined;
    communities?: string[] | undefined;
}

export class VendorBorderColorRequest implements IVendorBorderColorRequest {
    vendorId?: string | undefined;
    borderColor?: string | undefined;

    constructor(data?: IVendorBorderColorRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.vendorId = _data["vendorId"];
            this.borderColor = _data["borderColor"];
        }
    }

    static fromJS(data: any): VendorBorderColorRequest {
        data = typeof data === 'object' ? data : {};
        let result = new VendorBorderColorRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vendorId"] = this.vendorId;
        data["borderColor"] = this.borderColor;
        return data; 
    }
}

export interface IVendorBorderColorRequest {
    vendorId?: string | undefined;
    borderColor?: string | undefined;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}